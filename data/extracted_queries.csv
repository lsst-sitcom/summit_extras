name,query,type
Header sequence,"SELECT ""url"" FROM ""efd"".""autogen"".""lsst.sal.ATHeaderService.logevent_largeFileObjectAvailable"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
"Currents 3, 4, 5 - Static","SELECT ""motorCurrent3"", ""motorCurrent4"", ""motorCurrent5"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.electrical"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Moving,"SELECT ""motorCurrent0"", ""motorCurrent1"", ""motorCurrent2"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.electrical"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
HVAC,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
PMD:1,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.PMD.logevent_summaryState"" WHERE salIndex = 1 ORDER BY DESC LIMIT 1",influxql
ATMCS-Tracking,"SELECT ""state"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.logevent_atMountState"" ORDER BY DESC LIMIT 1",influxql
Azimuth,"SELECT ""azimuthCalculatedAngle99"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.mount_AzEl_Encoders"" ORDER BY DESC LIMIT 1",influxql
GenericCamera:1,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.GenericCamera.logevent_summaryState"" WHERE ""salIndex"" = 1 ORDER BY DESC LIMIT 1",influxql
ATAOS,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATHexapod,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATHexapod.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATDome,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATDome.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATPtg,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATPtg.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATDomeTrajectory,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATDomeTrajectory.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATMCS,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATMonochromator,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATMonochromator.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATHeaderService,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATHeaderService.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATOODS,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATOODS.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATCamera,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
Electrometer:201,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.Electrometer.logevent_summaryState"" where salIndex = 201 ORDER BY DESC LIMIT 1",influxql
ATSpectrograph,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATSpectrograph.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATPneumatics,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATPneumatics.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
FiberSpectrograph,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.FiberSpectrograph.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
Scheduler:2,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.Scheduler.logevent_summaryState"" WHERE salIndex = 2 ORDER BY DESC LIMIT 1",influxql
ATOCPS,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.OCPS.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
Position 4  (Z),"SELECT ""position5"" FROM ""efd"".""autogen"".""lsst.sal.PMD.position"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Position 3 (Z),"SELECT ""position3"" FROM ""efd"".""autogen"".""lsst.sal.PMD.position"" WHERE time > :dashboardTime:",influxql
Position 2 (Z-motion),"SELECT ""position2"" FROM ""efd"".""autogen"".""lsst.sal.PMD.position"" WHERE time > :dashboardTime:",influxql
Position 1,"SELECT ""position1"" FROM ""efd"".""autogen"".""lsst.sal.PMD.position"" WHERE time > :dashboardTime:",influxql
Log messages,"SELECT ""level"", ""message"" FROM ""efd"".""autogen"".""lsst.sal.PMD.logevent_logMessage"" WHERE time > :dashboardTime:",influxql
Position 0,"SELECT ""position0"" FROM ""efd"".""autogen"".""lsst.sal.PMD.position"" WHERE time > :dashboardTime: ",influxql
Main Shutter Opening Percentage,"SELECT ""mainDoorOpeningPercentage"" FROM ""efd"".""autogen"".""lsst.sal.ATDome.position"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dome position,"SELECT ""azimuthPosition"" FROM ""efd"".""autogen"".""lsst.sal.ATDome.position"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dropout Shutter Open Percentage,"SELECT ""dropoutDoorOpeningPercentage"" FROM ""efd"".""autogen"".""lsst.sal.ATDome.position"" ORDER BY time DESC LIMIT 1",influxql
Dome Status,"SELECT ""inPosition"" FROM ""efd"".""autogen"".""lsst.sal.ATDome.logevent_allAxesInPosition"" ORDER BY time DESC LIMIT 1",influxql
Azimuth Position,"SELECT ""azimuthPosition"" FROM ""efd"".""autogen"".""lsst.sal.ATDome.position"" ORDER BY time DESC LIMIT 1",influxql
Main Shutter Open Percentage,"SELECT ""mainDoorOpeningPercentage"" FROM ""efd"".""autogen"".""lsst.sal.ATDome.position"" ORDER BY time DESC LIMIT 1",influxql
Emergency Stop,"SELECT ""active"" FROM ""efd"".""autogen"".""lsst.sal.ATDome.logevent_emergencyStop"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
CamHexapod Motor currents ,"SELECT mean(""motorCurrent0"") AS ""mean_motorCurrent0"", mean(""motorCurrent1"") AS ""mean_motorCurrent1"", mean(""motorCurrent2"") AS ""mean_motorCurrent2"", mean(""motorCurrent3"") AS ""mean_motorCurrent3"", mean(""motorCurrent4"") AS ""mean_motorCurrent4"", mean(""motorCurrent5"") AS ""mean_motorCurrent5"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.electrical"" WHERE salIndex=1 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M2 Tangent Link Temperatures,"SELECT ""temperatureItem1"", ""temperatureItem2"", ""temperatureItem3"", ""temperatureItem4"", ""temperatureItem5"", ""temperatureItem6"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 106 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Camera Hexapod Temperatures,"SELECT ""temperatureItem5"" as ""Strut 12 temp"", ""temperatureItem4"" as ""Strut 11 temp"", ""temperatureItem3"" as ""Strut 10 temp"", ""temperatureItem2"" as ""Strut 9 temp"", ""temperatureItem1"" as ""Strut 8 temp"", ""temperatureItem0"" as ""Strut 7 temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 1 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTRotator Temperatures,"SELECT ""temperatureItem6"" as ""Motor 1 temp"", ""temperatureItem7"" as ""Motor 2 temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 1 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dome Temperature,"SELECT ""temperatureItem0"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 113 and time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
Voltages,"SELECT ""gDV0"", ""oDV0"", ""oGV0"", ""rDV0"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.focal_plane_Ccd"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Temperature,"SELECT ""temp0"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.focal_plane_Ccd"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Untitled Graph,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Untitled Graph,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Untitled Graph,"SELECT mean(""temperature"") AS ""mean_temperature"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.vacuum_Cold2"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Untitled Graph,"SELECT mean(""temperature"") AS ""mean_temperature"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.vacuum_Cold1"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 Detailed State - ,"SELECT ""detailedState"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.logevent_detailedState"" ORDER BY time DESC LIMIT 1",influxql
M2 Closed Loop Status - 1: Idle. 2: Telemetry only. 3: Open-loop. 4: Closed-loop - Last 10,"SELECT ""mode"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_closedLoopControlMode"" ORDER BY time DESC LIMIT 1",influxql
Azimuth Velocity,"SELECT ""actualVelocity"", ""demandVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Azimuth Position,"SELECT ""actualPosition"", ""demandPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Elevation Velocity,"SELECT ""actualVelocity"", ""demandVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Elevation Position,"SELECT ""actualPosition"", ""demandPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Elevation Motion Graph,"SELECT mean(""private_efdStamp"") AS ""mean_private_efdStamp"", mean(""private_identity"") AS ""mean_private_identity"", mean(""private_kafkaStamp"") AS ""mean_private_kafkaStamp"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.command_stop"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Azimuth Motion Table,"SELECT ""actualPosition"", ""actualVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Azimuth Motion Graph,"SELECT ""actualPosition"", ""actualVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Elevation Motion Table,"SELECT ""actualVelocity"", ""actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTHexapod Compensation,"// CSC states
// STANDBY = 5
// OFFLINE = 4
// FAULT = 3
// ENABLED = 2
// DISABLED = 1

import ""strings""

from(bucket: ""efd/autogen"")
  |> range(start: -inf)
  |> filter(fn: (r) => r._measurement == ""lsst.sal.MTHexapod.logevent_compensationMode"")
  |> filter(fn: (r) => r._field == ""enabled"" or r._field == ""salIndex"")
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> filter(fn: (r) => r.salIndex==int(v: v.SalIndex))
  |> map(fn: (r) => ({
    r with
    state:
      if r.enabled == true then ""Enabled""
      else ""Disabled"",
    })
) |> sort(desc: true)
",flux
Bus voltages,"SELECT /busVoltage/ FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.electrical"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Motor currents,"SELECT /motorCurrent/ FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.electrical"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Pivot position,"SELECT pivotX, pivotY, pivotZ FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_configuration"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
"Compensation inputs: Mount AZ,EL; Rotator angle","SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:sampling:) FILL(null)",influxql
"Compensation inputs: Mount AZ,EL; Rotator angle","SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
"Compensation inputs: Mount AZ,EL; Rotator angle","SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.rotation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Calibrated Actuator Position (linear encoder),"SELECT mean(calibrated0) as mean_calibrated0, mean(calibrated1) as mean_calibrated1, mean(calibrated2) as mean_calibrated2, mean(calibrated3) as mean_calibrated3, mean(calibrated4) as mean_calibrated4, mean(calibrated5) as mean_calibrated5 FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.actuators"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:sampling:) FILL(null)",influxql
Hexapod Temperatures,"SELECT ""temperatureItem5"" as ""Strut 12 temp"", ""temperatureItem4"" as ""Strut 11 temp"", ""temperatureItem3"" as ""Strut 10 temp"", ""temperatureItem2"" as ""Strut 9 temp"", ""temperatureItem1"" as ""Strut 8 temp"", ""temperatureItem0"" as ""Strut 7 temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Hexapod Temperatures,"SELECT mean(avg1M) as mean_airTemperature FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.airTemperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
MTHexapod.command_setCompensationMode,"SELECT enable FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.command_setCompensationMode"" WHERE salIndex = :SalIndex: ORDER BY DESC LIMIT 20",influxql
Pivot command,"SELECT x, y, z FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.command_setPivot"" WHERE salIndex = :SalIndex: ORDER BY DESC LIMIT 20",influxql
command_stop,"SELECT private_seqNum, private_identity FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.command_stop"" WHERE salIndex = :SalIndex: ORDER BY DESC LIMIT 5",influxql
Connected,"SELECT connected FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_connected"" WHERE salIndex = :SalIndex: ORDER BY DESC LIMIT 3;",influxql
Position in w [deg],"SELECT mean(position5) as mean_w FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:sampling:) FILL(null)",influxql
Position in v [deg],"SELECT mean(position4) as mean_v FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:sampling:) FILL(null)",influxql
Position in u [deg],"SELECT mean(position3) as mean_u FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:sampling:) FILL(null)",influxql
Position in Y [um],"SELECT mean(position1) as mean_y FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
commandableByDDS,"SELECT state FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_commandableByDDS"" WHERE salIndex = :SalIndex: ORDER BY DESC LIMIT 3;",influxql
Position in Z [um],"SELECT mean(position2) as mean_z FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Position in X [um],"SELECT mean(position0) as mean_x FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:sampling:) FILL(null)",influxql
MTHexapod Summary State,"// CSC states
// STANDBY = 5
// OFFLINE = 4
// FAULT = 3
// ENABLED = 2
// DISABLED = 1

import ""strings""

from(bucket: ""efd/autogen"")
  |> range(start: -inf)
  |> filter(fn: (r) => r._measurement == ""lsst.sal.MTHexapod.logevent_summaryState"")
  |> filter(fn: (r) => r._field == ""summaryState"" or r._field == ""salIndex"")
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> filter(fn: (r) => r.salIndex==int(v: v.SalIndex))
  |> map(fn: (r) => ({
    r with
    state:
      if r.summaryState == 5 then ""5 (STANDBY)""
      else if r.summaryState == 4 then ""4 (OFFLINE)""
      else if r.summaryState == 3 then ""3 (FAULT)""
      else if r.summaryState == 2 then ""2 (ENABLED)""
      else if r.summaryState == 1 then ""1 (DISABLED)""
      else ""UNKNOWN"",
    })
) |> sort(desc: true)
",flux
Script logevents,"SELECT ""salIndex"", ""level"", ""message"", ""traceback"" FROM ""efd"".""autogen"".""lsst.sal.Script.logevent_logMessage"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex < 200000",influxql
MTHexapod Heartbeat,"SELECT count(""heartbeat"") FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_heartbeat"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:sampling:) FILL(null)",influxql
controllerState,"SELECT ""controllerState"", ""enabledSubstate"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_controllerState"" WHERE salIndex =:SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
"Logevent ""inPosition""","SELECT ""inPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_inPosition"" WHERE salIndex = :SalIndex: ORDER BY DESC LIMIT 1000",influxql
MTHexapod log messages,"SELECT ""level"", ""message"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_logMessage"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTHexapod.command_move,"SELECT mean(x) as mean_x, mean(y) as mean_y, mean(z) as mean_z, mean(u) as mean_u, mean(v) as mean_v, mean(w) as mean_w FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.command_move"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime:  GROUP BY time(:sampling:) FILL(null)",influxql
Actutators raw (mean),"SELECT mean(""raw0"") AS ""mean_raw0"", mean(""raw1"") AS ""mean_raw1"", mean(""raw2"") AS ""mean_raw2"", mean(""raw3"") AS ""mean_raw3"", mean(""raw4"") AS ""mean_raw4"", mean(""raw5"") AS ""mean_raw5"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.actuators"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:sampling:) FILL(null)",influxql
Raw Acutators,"SELECT mean(""raw0"") as mean_raw0, mean(""raw1"") as mean_raw1, mean(""raw2"") as mean_raw2, mean(""raw3"") as mean_raw3, mean(""raw4"") as mean_raw4, mean(""raw5"") as mean_raw5 FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.actuators"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime:  GROUP BY time(:sampling:) FILL(null)",influxql
Copley Drive Status,"SELECT /copleyStatusWordDrive/ FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.electrical"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
tracking speed test (elevation),"SELECT ""demandVelocity"", ""actualVelocity"", ""actualPosition"", ""demandPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Tracking speed test,"SELECT ""actualPosition"", ""actualVelocity"", ""demandPosition"", ""demandVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
M2 Hexapod (index:2),"SELECT last(""mode"") AS ""last_mode"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_simulationMode"" WHERE salIndex = 2",influxql
MTDomeTrajectory,"SELECT last(""mode"") AS ""last_mode"" FROM ""efd"".""autogen"".""lsst.sal.MTDomeTrajectory.logevent_simulationMode""",influxql
MTAOS,"SELECT last(""mode"") AS ""last_mode"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_simulationMode""",influxql
MTDome,"SELECT last(""mode"") AS ""last_mode"" FROM ""efd"".""autogen"".""lsst.sal.MTDome.logevent_simulationMode""",influxql
M1M3,"SELECT last(""mode"") AS ""last_mode"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.logevent_simulationMode""",influxql
MTMount,"SELECT last(""mode"") AS ""last_mode"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_simulationMode""",influxql
M2,"SELECT last(""mode"") AS ""last_mode"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_simulationMode""",influxql
MTRotator,"SELECT last(""mode"") AS ""last_mode"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_simulationMode""",influxql
Camera Hexapod (index:1),"SELECT last(""mode"") AS ""last_mode"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_simulationMode"" WHERE salIndex = 1",influxql
Glycol delivered temp,"SELECT mean(""glycolTemperaturePier0001"") AS ""Glycol General Temp 0001"", mean(""glycolTemperaturePier0002"") AS ""Glycol General Temp 0002"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.generalPurposeGlycolWater"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Glycol delivered temp,"SELECT mean(""ambientTemperature"") AS ""Azimuth Floor Air Ambient Temp"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.topEndChiller"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Glycol delivered temp,"SELECT mean(""glycolTemperaturePier0101"") AS ""Cold Glycol Temp 0101"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.cooling"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Glycol delivered temp,"SELECT mean(""absoluteTemperature0"") AS ""mean_absoluteTemperature0"", mean(""absoluteTemperature1"") AS ""mean_absoluteTemperature1"", mean(""absoluteTemperature10"") AS ""mean_absoluteTemperature10"", mean(""absoluteTemperature11"") AS ""mean_absoluteTemperature11"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.thermalData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
HP compressor presure,"SELECT ""breakawayPressure5"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointMonitorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
M1M3 air temp,"SELECT mean(""temperatureItem0"") AS ""M1M3 air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 113 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Outside air temp,"SELECT mean(""temperatureItem0"") AS ""Outside air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 temps,"SELECT mean(""temperatureItem0"") AS ""Outside air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 temps,"SELECT mean(""temperatureItem0"") AS ""Camera air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 111 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 temps,"SELECT mean(""temperatureItem0"") AS ""M2 air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 112 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 temps,"SELECT mean(""temperatureItem0"") AS ""M1M3 air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 113 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 temps,"SELECT mean(""absoluteTemperature0"") AS ""mean_absoluteTemperature0"", mean(""absoluteTemperature10"") AS ""mean_absoluteTemperature10"", mean(""absoluteTemperature20"") AS ""mean_absoluteTemperature20"", mean(""absoluteTemperature30"") AS ""mean_absoluteTemperature30"", mean(""absoluteTemperature40"") AS ""mean_absoluteTemperature40"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.thermalData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Rubin - Sun Elevation,"SELECT mean(""sunAltitude"") AS ""mean_sunAltitude"", mean(""moonAltitude"") AS ""mean_moonAltitude"" FROM ""efd"".""autogen"".""lsst.sal.ATPtg.skyEnvironment"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Scheduler Validation Failures,"SELECT ""message"" FROM ""efd"".""autogen"".""lsst.sal.Scheduler.logevent_logMessage"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: and message =~ /failed validation/",influxql
TMA Azimuth,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.azimuth"")
  |> filter(fn: (r) => r[""_field""] == ""actualPosition"")


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoints Forces,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /measuredForce./)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
TMA Elevation,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevation"")
  |> filter(fn: (r) => r[""_field""] == ""actualPosition"")

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Exposure sequence,"SELECT ""expTime"", ""numImages"", ""shutter"", ""keyValueMap"", ""obsNote"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.command_takeImages"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Wind Speed - Average 2min,"SELECT ""value"" FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.windSpeed"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Wind Speed - Average 2min,"SELECT ""min2M"" FROM ""efd"".""autogen"".""lsst.sal.Environment.windSpeed"" WHERE time > :dashboardTime:",influxql
Min Temperature,"SELECT ""min24H"" FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.airTemperature"" WHERE ""salIndex"" = 1 ORDER BY time DESC LIMIT 1",influxql
Dewpoint,"SELECT ""avg1M""+1.4 FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.dewPoint"" WHERE ""salIndex"" = 1 ORDER BY time DESC LIMIT 1",influxql
Relative Humidity,"SELECT ""avg1M""/0.90 FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.relativeHumidity"" WHERE time > :dashboardTime:",influxql
Wind Direction (avg2M),"SELECT ""avg2M"" FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.windDirection"" WHERE ""salIndex"" =1 ORDER BY time DESC LIMIT 1",influxql
Humidity,"SELECT ""humidity"" FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.weather"" WHERE ""salIndex"" = 1 ORDER BY time DESC LIMIT 1",influxql
Max Temperature,"SELECT ""max24H"" FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.airTemperature"" WHERE ""salIndex"" = 1 ORDER BY time DESC LIMIT 1",influxql
Average Temperatures,"SELECT ""avg1M"" FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.airTemperature"" WHERE time > :dashboardTime:",influxql
Average Temperatures,"SELECT ""avg1M""+1.4 FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.dewPoint"" WHERE time > :dashboardTime: ",influxql
Number of earthquakes last month,"SELECT count(""magnitude"") FROM ""lsst.backpack"".""autogen"".""lsst.backpack.usgs_earthquake_data"" WHERE time > now()-30d ",influxql
Earthquake events in the last year,"SELECT ""magnitude"" FROM ""lsst.backpack"".""autogen"".""lsst.backpack.usgs_earthquake_data"" WHERE time > now()-365d ",influxql
Largest earthquake,"SELECT max(""magnitude"") FROM ""lsst.backpack"".""autogen"".""lsst.backpack.usgs_earthquake_data"" WHERE time > now()-365d ",influxql
Position and Velocity,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"", mean(""demandPosition"") AS ""mean_demandPosition"", mean(""actualVelocity"") AS ""mean_actualVelocity"", mean(""demandVelocity"") AS ""mean_demandVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.cameraCableWrap"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Torque,"SELECT mean(""actualTorquePercentage0"") AS ""mean_actualTorquePercentage0"", mean(""actualTorquePercentage1"") AS ""mean_actualTorquePercentage1"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.cameraCableWrap"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
TMA - EL position,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Untitled Graph,"SELECT mean(""azimuthPosition"") AS ""mean_azimuthPosition"" FROM ""efd"".""autogen"".""lsst.sal.ATDome.position"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Untitled Graph,"SELECT ""active"" FROM ""efd"".""autogen"".""lsst.sal.ATDome.logevent_emergencyStop"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Filter Names,"SELECT ""filterNames"" FROM ""efd"".""autogen"".""lsst.sal.ATSpectrograph.logevent_settingsAppliedValues"" ORDER BY time DESC LIMIT 1",influxql
Linear Stage State,"SELECT ""state"" FROM ""efd"".""autogen"".""lsst.sal.ATSpectrograph.logevent_lsState"" ORDER BY time DESC LIMIT 1",influxql
Grating Wheel State,"SELECT ""state"" FROM ""efd"".""autogen"".""lsst.sal.ATSpectrograph.logevent_gwState"" ORDER BY time DESC LIMIT 1",influxql
Filter Wheel State,"SELECT ""state"" FROM ""efd"".""autogen"".""lsst.sal.ATSpectrograph.logevent_fwState"" ORDER BY time DESC LIMIT 1",influxql
Linear Stage,"SELECT ""position"" FROM ""efd"".""autogen"".""lsst.sal.ATSpectrograph.logevent_reportedLinearStagePosition"" ORDER BY time DESC LIMIT 1",influxql
Filter,"SELECT ""name"", ""position"" FROM ""efd"".""autogen"".""lsst.sal.ATSpectrograph.logevent_reportedFilterPosition"" ORDER BY time DESC LIMIT 1",influxql
Disperser,"SELECT ""name"", ""position"" FROM ""efd"".""autogen"".""lsst.sal.ATSpectrograph.logevent_reportedDisperserPosition"" ORDER BY time DESC LIMIT 1",influxql
Grating Names,"SELECT ""gratingNames"" FROM ""efd"".""autogen"".""lsst.sal.ATSpectrograph.logevent_settingsAppliedValues"" ORDER BY time DESC LIMIT 1",influxql
Pier Ground A,"SELECT mean(""rawAccelerometer0"") AS ""mean_rawAccelerometer0"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.accelerometerData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
OSS Main Tank Level [mm] Gauge TMA_FA_OS_CLM_5001,"SELECT ""oilLevelFacilities5001"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.oilSupplySystem"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
TMA EL_TOR:A ,"SELECT mean(""actualTorque"") AS ""mean_actualTorque"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
TMA EL_POS:A&D,"SELECT ""actualPosition"", ""demandPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
TMA AZ_POS:A&D,"SELECT ""actualPosition"", ""demandPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
TMA AZ_TOR:A,"SELECT mean(""actualTorque"") AS ""mean_actualTorque"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
TMA EL_VEL:A&D,"SELECT ""actualVelocity"", ""demandVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
TMA AZ_VEL:A&D,"SELECT ""actualVelocity"", ""demandVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
M2 TANGENT LINKS MONITORING,"SELECT /force/ FROM ""efd"".""autogen"".""lsst.sal.MTM2.forceErrorTangent"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
OIL LEVEL (L1) Liters estimation,"SELECT mean(""oilLevelFacilities5001"")*1.15*2.38 AS ""mean_oilLevelFacilities5001"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.oilSupplySystem"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
OIL LEVEL (L1),"SELECT mean(""oilLevelFacilities5001"") AS ""mean_oilLevelFacilities5001"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.oilSupplySystem"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Oil Pressure,"SELECT ""oilPressureFacilities5001"", ""oilPressureFacilities5002"", ""oilPressureFacilities5003"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.oilSupplySystem"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Oil Chiller Temperature 5012 and 5013,"SELECT ""oilChillerTemperature5012"", ""oilChillerTemperature5013"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.oilSupplySystem"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Circulation Pump Power STATE,"SELECT mean(""circulationPumpPowerState"") AS ""mean_circulationPumpPowerState"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_oilSupplySystemState"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
"Oil Temperature 5001,5002,5011,5121","SELECT ""oilTemperatureFacilities5001"", ""oilTemperatureFacilities5002"", ""oilTemperatureFacilities5011"", ""oilTemperatureFacilities5121"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.oilSupplySystem"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Oil Bearing Temperatures,"SELECT mean(""oilTemperatureAzimuth5001"") AS ""mean_oilTemperatureAzimuth5001"", mean(""oilTemperatureAzimuth5011"") AS ""mean_oilTemperatureAzimuth5011"", mean(""oilTemperatureAzimuth5021"") AS ""mean_oilTemperatureAzimuth5021"", mean(""oilTemperatureAzimuth5031"") AS ""mean_oilTemperatureAzimuth5031"", mean(""oilTemperatureAzimuth5041"") AS ""mean_oilTemperatureAzimuth5041"", mean(""oilTemperatureAzimuth5051"") AS ""mean_oilTemperatureAzimuth5051"", mean(""oilTemperatureElevation5001"") AS ""mean_oilTemperatureElevation5001"", mean(""oilTemperatureElevation5011"") AS ""mean_oilTemperatureElevation5011"", mean(""oilTemperatureElevation5021"") AS ""mean_oilTemperatureElevation5021"", mean(""oilTemperatureElevation5031"") AS ""mean_oilTemperatureElevation5031"", mean(""oilTemperatureElevation5101"") AS ""mean_oilTemperatureElevation5101"", mean(""oilTemperatureElevation5111"") AS ""mean_oilTemperatureElevation5111"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.oilSupplySystem"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Ingest sequence,"SELECT ""obsid"", ""raft"", ""sensor"", ""statusCode"", ""description"" FROM ""efd"".""autogen"".""lsst.sal.CCOODS.logevent_imageInOODS"" WHERE time > :dashboardTime:",influxql
Slit2 width in mm,"SELECT ""slitPosition"" FROM ""efd"".""autogen"".""lsst.sal.ATMonochromator.logevent_slitWidth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND ""slit"" = 2",influxql
Slit 1 width in mm.,"SELECT ""slitPosition"" FROM ""efd"".""autogen"".""lsst.sal.ATMonochromator.logevent_slitWidth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND ""slit"" = 1",influxql
Wavelength in nm,"SELECT ""wavelength"" FROM ""efd"".""autogen"".""lsst.sal.ATMonochromator.logevent_wavelength"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
"Grating - 0:Mirror, 1:Blue grating, 2:red grating","SELECT ""gratingType"" FROM ""efd"".""autogen"".""lsst.sal.ATMonochromator.logevent_selectedGrating"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
hardpoint std,"SELECT stddev(""measuredForce0"") AS ""std_measuredForce0"", stddev(""measuredForce1"") AS ""std_measuredForce1"", stddev(""measuredForce2"") AS ""std_measuredForce2"", stddev(""measuredForce3"") AS ""std_measuredForce3"", stddev(""measuredForce4"") AS ""std_measuredForce4"", stddev(""measuredForce5"") AS ""std_measuredForce5"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(2s) FILL(null)",influxql
hardpoint force,"SELECT ""measuredForce0"", ""measuredForce1"", ""measuredForce2"", ""measuredForce3"", ""measuredForce4"", ""measuredForce5"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
elevation,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(1s) FILL(null)",influxql
hmd pressureSensor,"SELECT mean(/pressureSensor/) FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointMonitorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
hmd breakawayPressure,"SELECT mean(/breakawayPressure/) FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointMonitorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
hmc displacementLVDT,"SELECT mean(/displacementLVDT/) FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointMonitorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
az,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Balance Forces,"SELECT ""forceMagnitude"", ""fy"", ""fz"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.appliedBalanceForces"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
TMA Elevation,"SELECT ""actualPosition"", ""actualTorque"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
M2 Closed_Loop_Status / 1 Idle./ 2 Telemetry_only / 3 Open-loop / 4 Closed-loop (clone 1),"SELECT ""mode"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_closedLoopControlMode"" ORDER BY time DESC LIMIT 5",influxql
M2 Closed_Loop_Status / 1 Idle./ 2 Telemetry_only / 3 Open-loop / 4 Closed-loop,"SELECT ""mode"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_closedLoopControlMode"" ORDER BY time DESC LIMIT 1",influxql
Speed,"SELECT ""speed"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Max Wind Speed,"SELECT ""maxSpeed"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Min Temperature,"SELECT min(""temperatureItem0"") as ""maxAirTemperature"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:  FILL(null)",influxql
Heartbeat ESS:301,"SELECT count(""heartbeat"") FROM ""efd"".""autogen"".""lsst.sal.ESS.logevent_heartbeat"" WHERE salIndex = 301 AND time > :dashboardTime: GROUP BY time(5s) ORDER BY DESC LIMIT 1",influxql
Wind Direction,"SELECT mean(""direction"") AS ""mean_direction"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Dewpoint & Temperature,"SELECT mean(""dewPointItem"") AS ""mean_dewPointItem"" FROM ""efd"".""autogen"".""lsst.sal.ESS.dewPoint"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Dewpoint & Temperature,"SELECT mean(""temperatureItem0"") AS ""mean_temperatureItem0"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Relative Humidity,"SELECT ""relativeHumidityItem"" FROM ""efd"".""autogen"".""lsst.sal.ESS.relativeHumidity"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Wind Direction,"SELECT ""direction"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow""  WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:  FILL(null)",influxql
Wind Speed,"SELECT ""speed"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:  FILL(null)",influxql
Barometric Pressure,"SELECT ""pressureItem0"" / 100.0 FROM ""efd"".""autogen"".""lsst.sal.ESS.pressure"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Max Temperature,"SELECT max(""temperatureItem0"") as ""maxAirTemperature"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: FILL(null)",influxql
Air Temperature,"SELECT ""temperatureItem0"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Air Temperature,"SELECT mean(""dewPointItem"") AS ""mean_dewPointItem"" FROM ""efd"".""autogen"".""lsst.sal.ESS.dewPoint"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Rubin - Sun Elevation,"SELECT mean(""sunAltitude"") AS ""mean_sunAltitude"", mean(""moonAltitude"") AS ""mean_moonAltitude"" FROM ""efd"".""autogen"".""lsst.sal.ATPtg.skyEnvironment"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Exposure sequence,"SELECT ""imageName"", ""exposureTime"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.logevent_endReadout"" WHERE  time > :dashboardTime:",influxql
Exposure sequence,"SELECT ""targetName"" FROM ""efd"".""autogen"".""lsst.sal.ATPtg.logevent_currentTarget"" WHERE time > :dashboardTime:",influxql
Exposure sequence,"SELECT ""name"" FROM ""efd"".""autogen"".""lsst.sal.ATSpectrograph.logevent_reportedDisperserPosition"" WHERE time > :dashboardTime:",influxql
Exposure sequence,"SELECT ""name"" FROM ""efd"".""autogen"".""lsst.sal.ATSpectrograph.logevent_reportedFilterPosition"" WHERE  time > :dashboardTime:",influxql
TEA's Electrical cabinets Temps + Ambient,"SELECT mean(""ambientTemperature"") AS ""mean_ambientTemperature"", mean(""internalTemperatureElectricalCabinet0"") AS ""mean_internalTemperatureElectricalCabinet0"", mean(""internalTemperatureElectricalCabinet1"") AS ""mean_internalTemperatureElectricalCabinet1"", mean(""internalTemperatureElectricalCabinet2"") AS ""mean_internalTemperatureElectricalCabinet2"", mean(""internalTemperatureElectricalCabinet3"") AS ""mean_internalTemperatureElectricalCabinet3"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.topEndChiller"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Dynalene Telemetry for GHESA,"SELECT mean(""dynaleneTemperatureAzimuth0001"") AS ""mean_dynaleneTemperatureAzimuth0001"", mean(""dynaleneTemperatureAzimuth0002"") AS ""mean_dynaleneTemperatureAzimuth0002"", mean(""dynalenePressureAzimuth0001"") AS ""mean_dynalenePressureAzimuth0001"", mean(""dynalenePressureAzimuth0002"") AS ""mean_dynalenePressureAzimuth0002"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.dynaleneCooling"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
TEA's Volume Temps + Ambient,"SELECT mean(""ambientTemperature"") AS ""mean_ambientTemperature"", mean(""ambientTemperatureSensor0502"") AS ""mean_ambientTemperatureSensor0502"", mean(""ambientTemperatureSensor0504"") AS ""mean_ambientTemperatureSensor0504"", mean(""ductTemperatureSensor0506"") AS ""mean_ductTemperatureSensor0506"", mean(""ductTemperatureSensor0507"") AS ""mean_ductTemperatureSensor0507"", mean(""ambientTemperatureSensor0505"") AS ""mean_ambientTemperatureSensor0505"", mean(""temperatureSensor0501"") AS ""mean_temperatureSensor0501"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.topEndChiller"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Dynalene Supply Temp @ L6,"SELECT mean(""dynTMAsupTS01"") AS ""mean_dynTMAsupTS01"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Dynalene Supply Temp @ L6,"SELECT mean(""dynalenePressureElevation0001"") AS ""mean_dynalenePressureElevation0001"", mean(""dynaleneTemperatureAzimuth0001"") AS ""mean_dynaleneTemperatureAzimuth0001"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.dynaleneCooling"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
TMA EUI Ambient Temperature,"SELECT mean(""ambientTemperature"") AS ""mean_ambientTemperature"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.topEndChiller"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
TEA-THCS M2 and MTM2 Cell combined Temps Monitor,"SELECT mean(""ambientTemperatureSensor0504"") AS ""mean_ambientTemperatureSensor0504"", mean(""ambientTemperatureSensor0505"") AS ""mean_ambientTemperatureSensor0505"", mean(""ductTemperatureSensor0506"") AS ""mean_ductTemperatureSensor0506"", mean(""ductTemperatureSensor0507"") AS ""mean_ductTemperatureSensor0507"", mean(""ambientTemperature"") AS ""mean_ambientTemperature"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.topEndChiller"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
TEA-THCS M2 and MTM2 Cell combined Temps Monitor,"SELECT mean(""exhaust0"") AS ""mean_exhaust0"", mean(""exhaust1"") AS ""mean_exhaust1"", mean(""intake0"") AS ""mean_intake0"", mean(""intake1"") AS ""mean_intake1"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.temperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Volumes' Temperature Monitor,"SELECT mean(""ambientTemperature"") AS ""mean_ambientTemperature"", mean(""ambientTemperatureSensor0502"") AS ""mean_ambientTemperatureSensor0502"", mean(""ambientTemperatureSensor0504"") AS ""mean_ambientTemperatureSensor0504"", mean(""ambientTemperatureSensor0505"") AS ""mean_ambientTemperatureSensor0505"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.topEndChiller"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Camera Volume Temp&Hum Monitor,"SELECT mean(""ambientRelativeHumiditySensor0504"") AS ""mean_ambientRelativeHumiditySensor0504"", mean(""ambientRelativeHumiditySensor0505"") AS ""mean_ambientRelativeHumiditySensor0505"", mean(""ambientTemperatureSensor0504"") AS ""mean_ambientTemperatureSensor0504"", mean(""ambientTemperatureSensor0505"") AS ""mean_ambientTemperatureSensor0505"", mean(""ambientRelativeHumiditySensor0502"") AS ""mean_ambientRelativeHumiditySensor0502"", mean(""ambientTemperatureSensor0502"") AS ""mean_ambientTemperatureSensor0502"", mean(""ambientTemperature"") AS ""mean_ambientTemperature"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.topEndChiller"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
CCW Volume Temp&Hum Monitor,"SELECT mean(""ambientTemperature"") AS ""mean_ambientTemperature"", mean(""ambientRelativeHumiditySensor0501"") AS ""mean_ambientRelativeHumiditySensor0501"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.topEndChiller"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
TEA-THCS M2 Temps Monitor,"SELECT mean(""ambientTemperatureSensor0504"") AS ""mean_ambientTemperatureSensor0504"", mean(""ambientTemperatureSensor0505"") AS ""mean_ambientTemperatureSensor0505"", mean(""ductTemperatureSensor0506"") AS ""mean_ductTemperatureSensor0506"", mean(""ductTemperatureSensor0507"") AS ""mean_ductTemperatureSensor0507"", mean(""ambientTemperature"") AS ""mean_ambientTemperature"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.topEndChiller"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
HX 02 Summary,"SELECT mean(""ambientTemperatureSensor0502"") AS ""mean_ambientTemperatureSensor0502"", mean(""ambientRelativeHumiditySensor0502"") AS ""mean_ambientRelativeHumiditySensor0502"", mean(""ambientRelativeHumiditySensor0505"") AS ""mean_ambientRelativeHumiditySensor0505"", mean(""ambientTemperatureSensor0505"") AS ""mean_ambientTemperatureSensor0505"", mean(""ambientTemperature"") AS ""mean_ambientTemperature"", mean(""threeWayValvePosition202"") AS ""mean_threeWayValvePosition202"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.topEndChiller"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
HX 01 Summary,"SELECT mean(""ambientTemperatureSensor0504"") AS ""mean_ambientTemperatureSensor0504"", mean(""threeWayValvePosition201"") AS ""mean_threeWayValvePosition201"", mean(""ambientTemperatureSensor0502"") AS ""mean_ambientTemperatureSensor0502"", mean(""ambientRelativeHumiditySensor0502"") AS ""mean_ambientRelativeHumiditySensor0502"", mean(""ambientRelativeHumiditySensor0504"") AS ""mean_ambientRelativeHumiditySensor0504"", mean(""ambientTemperature"") AS ""mean_ambientTemperature"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.topEndChiller"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
MTM2 Cell Temps Monitor,"SELECT mean(""exhaust0"") AS ""mean_exhaust0"", mean(""exhaust1"") AS ""mean_exhaust1"", mean(""intake0"") AS ""mean_intake0"", mean(""intake1"") AS ""mean_intake1"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.temperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
MTM2 Cell Temps Monitor,"SELECT mean(""ambientTemperature"") AS ""mean_ambientTemperature"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.topEndChiller"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Electrical Cabinets Temp Monitoring,"SELECT mean(""internalTemperatureElectricalCabinet1"") AS ""mean_internalTemperatureElectricalCabinet1"", mean(""externalTemperatureElectricalCabinet1"") AS ""mean_externalTemperatureElectricalCabinet1"", mean(""internalTemperatureElectricalCabinet0"") AS ""mean_internalTemperatureElectricalCabinet0"", mean(""internalTemperatureElectricalCabinet2"") AS ""mean_internalTemperatureElectricalCabinet2"", mean(""externalTemperatureElectricalCabinet0"") AS ""mean_externalTemperatureElectricalCabinet0"", mean(""externalTemperatureElectricalCabinet2"") AS ""mean_externalTemperatureElectricalCabinet2"", mean(""internalTemperatureElectricalCabinet3"") AS ""mean_internalTemperatureElectricalCabinet3"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.topEndChiller"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Volumes' Humidity Monitor,"SELECT mean(""ambientRelativeHumiditySensor0504"") AS ""mean_ambientRelativeHumiditySensor0504"", mean(""ambientRelativeHumiditySensor0505"") AS ""mean_ambientRelativeHumiditySensor0505"", mean(""ambientRelativeHumiditySensor0502"") AS ""mean_ambientRelativeHumiditySensor0502"", mean(""ambientRelativeHumiditySensor0501"") AS ""mean_ambientRelativeHumiditySensor0501"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.topEndChiller"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
3-w Valves Status,"SELECT mean(""threeWayValvePosition202"") AS ""mean_threeWayValvePosition202"", mean(""threeWayValvePosition201"") AS ""mean_threeWayValvePosition201"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.topEndChiller"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
STANDBY,"// STABDBY = 5 

import ""strings"" 

from(bucket: ""efd/autogen"")
  |> range(start: -inf)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.AT.*.logevent_summaryState/ and (r._field == ""summaryState""))
  |> last()
  |> map(fn: (r) => ({
    r with
    state_count:
      if r._value == 5 then 1 else 0
    })
  )
  |> group()
  |> sum(column: ""state_count"")
  |> map(fn: (r) => ({
    r with
    _time: 0
    })
  )
 
 

  
 ",flux
AuxTel State Transitions,"

// CSC state
// STANDBY = 5
// OFFLINE = 4
// FAULT = 3
// ENABLED = 2
// DISABLED = 1

import ""strings""

from(bucket: ""efd/autogen"")
  |> range(start: dashboardTime)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.AT.*.logevent_summaryState/ and (r._field == ""summaryState""))
  |> map(fn: (r) => ({
    r with
    csc: strings.split(v: r._measurement, t: ""."")[2],
    state: r._value,
    state_name:
      if r._value == 5 then ""5 (STANDBY)""
      else if r._value == 4 then ""4 (OFFLINE)""
      else if r._value == 3 then ""3 (FAULT)""
      else if r._value == 2 then ""2 (ENABLED)""
      else if r._value == 1 then ""1 (DISABLED)""
      else ""UNKNOWN"",
  }))
  |> group(columns: [""csc""])
  |> keep(columns: [""_time"", ""csc"", ""state"", ""state_name""])
 
",flux
ENABLED,"// ENABLED = 2 

import ""strings"" 

from(bucket: ""efd/autogen"")
  |> range(start: -inf)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.AT.*.logevent_summaryState/ and (r._field == ""summaryState""))
  |> last()
  |> map(fn: (r) => ({
    r with
    state_count:
      if r._value == 2 then 1 else 0
    })
  )
  |> group()
  |> sum(column: ""state_count"")
  |> map(fn: (r) => ({
    r with
    _time: 0
    })
  )
 
 

  
 ",flux
FAULT,"// FAULT = 3 

import ""strings"" 

from(bucket: ""efd/autogen"")
  |> range(start: -inf)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.AT.*.logevent_summaryState/ and (r._field == ""summaryState""))
  |> last()
  |> map(fn: (r) => ({
    r with
    state_count:
      if r._value == 3 then 1 else 0
    })
  )
  |> group()
  |> sum(column: ""state_count"")
  |> map(fn: (r) => ({
    r with
    _time: 0
    })
  )
 
 

  
 ",flux
AuxTel Devices,"import ""strings"" 

from(bucket: ""efd/autogen"")
  |> range(start: -inf)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.AT.*.logevent_summaryState/ and (r._field == ""summaryState""))
  |> last()
  |> group()
  |> count()
  |> map(fn: (r) => ({
    r with
    _time: 0
    })
  )
 
  
 ",flux
AuxTel Current State,"// CSC states
// STANDBY = 5
// OFFLINE = 4
// FAULT = 3
// ENABLED = 2
// DISABLED = 1

import ""strings""

from(bucket: ""efd/autogen"")
  |> range(start: -inf)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.AT.*.logevent_summaryState/ and (r._field == ""summaryState""))
  |> last()
  |> map(fn: (r) => ({
    r with
    csc: strings.split(v: r._measurement, t: ""."")[2],
    state:
      if r._value == 5 then ""5 (STANDBY)""
      else if r._value == 4 then ""4 (OFFLINE)""
      else if r._value == 3 then ""3 (FAULT)""
      else if r._value == 2 then ""2 (ENABLED)""
      else if r._value == 1 then ""1 (DISABLED)""
      else ""UNKNOWN"",
    duration: strings.splitAfter(v: string(v: duration(v: uint(v: r._stop) - uint(v: r._time))), t: ""m"")[0]
   })
  )

  |> keep(columns: [""csc"", ""state"", ""_time"", ""duration""])
 
",flux
Balance forces (clone 1),"SELECT ""forceMagnitude"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.appliedBalanceForces"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Elevation forces,"SELECT ""forceMagnitude"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.appliedElevationForces"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Balance forces,"SELECT ""forceMagnitude"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.appliedBalanceForces"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Measured forces,"SELECT mean(""forceMagnitude"") AS ""mean_forceMagnitude"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.forceActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Applied forces,"SELECT ""forceMagnitude"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.appliedForces"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Speed,"SELECT ""speed"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Max Wind Speed,"SELECT ""maxSpeed"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Min Temperature,"SELECT min(""temperatureItem0"") as ""maxAirTemperature"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:  FILL(null)",influxql
Heartbeat ESS:301,"SELECT count(""heartbeat"") FROM ""efd"".""autogen"".""lsst.sal.ESS.logevent_heartbeat"" WHERE salIndex = 301 AND time > :dashboardTime: GROUP BY time(5s) ORDER BY DESC LIMIT 1",influxql
Wind Direction,"SELECT mean(""direction"") AS ""mean_direction"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Dewpoint & Temperature,"SELECT mean(""dewPointItem"") AS ""mean_dewPointItem"" FROM ""efd"".""autogen"".""lsst.sal.ESS.dewPoint"" WHERE salIndex = 301 and time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Dewpoint & Temperature,"SELECT mean(""temperatureItem0"") AS ""mean_temperatureItem0"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 and time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Relative Humidity,"SELECT ""relativeHumidityItem"" FROM ""efd"".""autogen"".""lsst.sal.ESS.relativeHumidity"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Wind Direction,"SELECT ""direction"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow""  WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:  FILL(null)",influxql
Wind Speed,"SELECT ""speed"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:  FILL(null)",influxql
Barometric Pressure,"SELECT ""pressureItem0"" / 100.0 FROM ""efd"".""autogen"".""lsst.sal.ESS.pressure"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Max Temperature,"SELECT max(""temperatureItem0"") as ""maxAirTemperature"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: FILL(null)",influxql
Air Temperature,"SELECT ""temperatureItem0"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Air Temperature,"SELECT mean(""dewPointItem"") AS ""mean_dewPointItem"" FROM ""efd"".""autogen"".""lsst.sal.ESS.dewPoint"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
CCW Target position,"SELECT ""position"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_cameraCableWrapTarget"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
CCW Target position,"SELECT max(""position"") AS ""max_position"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_cameraCableWrapTarget"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
CCW LogMessage,"SELECT ""level"", ""message"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_logMessage"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Rotator Actual and Demand Velocity (Mean),"SELECT mean(""actualVelocity"") AS ""mean_actualVelocity"", mean(""demandVelocity"") AS ""mean_demandVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.rotation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(1s) FILL(null)",influxql
Rotator Motor Position,"SELECT mean(""calibrated0"") AS ""mean_calibrated0"", mean(""calibrated1"") AS ""mean_calibrated1"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.motors"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(1s) FILL(null)",influxql
Following Error,"SELECT mean(""positionError"") AS ""mean_positionError"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.ccwFollowingError"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(1s) FILL(null)",influxql
CCW Error Code,"SELECT ""code"", ""text"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_error"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
CCW Following,"SELECT ""enabled"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_cameraCableWrapFollowing"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Rotator Status,"SELECT last(""summaryState"") AS ""last_summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_summaryState"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
CCW Status,"SELECT last(""summaryState"") AS ""last_summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_summaryState"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
CCW Position,"SELECT mean(""actualPosition"") AS ""meanPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.cameraCableWrap"" WHERE time >= :dashboardTime: AND time <= :upperDashboardTime: GROUP BY time(1s)",influxql
Rotator Position and Demand (Mean),"SELECT mean(""demandPosition"") AS ""meanDemand"", mean(""actualPosition"") AS ""meanPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.rotation"" WHERE time >= :dashboardTime: AND time <= :upperDashboardTime: GROUP BY time(1s)",influxql
accelerationZ0  (SST Top End Ring),"SELECT /accelerationZ/ FROM ""efd"".""autogen"".""lsst.sal.ESS.accelerometer"" WHERE salIndex = 104 AND sensorName =~ /^SST top end ring/ AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
accelerationY0  (SST Top End Ring),"SELECT /accelerationY/ FROM ""efd"".""autogen"".""lsst.sal.ESS.accelerometer"" WHERE salIndex = 104 AND sensorName =~ /^SST top end ring/ AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
accelerationX0 (SST Top End Ring),"SELECT /accelerationX/ FROM ""efd"".""autogen"".""lsst.sal.ESS.accelerometer"" WHERE salIndex = 104 AND sensorName =~ /^SST top end ring/ AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Sensor Name,"SELECT ""sensorName"" FROM ""efd"".""autogen"".""lsst.sal.ESS.accelerometer"" WHERE salIndex = 104 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
HP Breakaway Air (psi),"SELECT ""breakawayPressure0"", ""breakawayPressure1"", ""breakawayPressure2"", ""breakawayPressure3"", ""breakawayPressure4"", ""breakawayPressure5"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointMonitorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Motor Power Input,"SELECT ""motorInput"" AS ""Compressor 1"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE salIndex = 1 AND time > :dashboardTime: AND time < :upperDashboardTime: FILL(null)",influxql
Motor Power Input,"SELECT ""motorInput"" AS ""Compressor 2"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE salIndex = 2 AND time > :dashboardTime: AND time < :upperDashboardTime: FILL(null)",influxql
Stage 1 Output Temperature,"SELECT ""stage1OutputTemperature"" AS ""Compressor 1"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 1 FILL(null)",influxql
Stage 1 Output Temperature,"SELECT ""stage1OutputTemperature"" AS ""Compressor 2"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 2 FILL(null)",influxql
Compressor Volume in %,"SELECT ""compressorVolumePercentage"" AS ""Volume Compressor 1"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 1 FILL(null)",influxql
Compressor Volume in %,"SELECT ""compressorVolumePercentage"" AS ""Volume Compressor 2"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 2 FILL(null)",influxql
Motor Speed in %,"SELECT ""motorSpeedPercentage"" AS ""Motor Speed 1"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 1 FILL(null)",influxql
Motor Speed in %,"SELECT ""motorSpeedPercentage"" AS ""Motor Speed 2"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 2 FILL(null)",influxql
Motor Target Speed ,"SELECT ""targetSpeed"" AS ""Compressor 1"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 1 FILL(null)",influxql
Motor Target Speed ,"SELECT ""targetSpeed"" AS ""Compressor 2"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 2 FILL(null)",influxql
Water Level ,"SELECT ""waterLevel"" AS ""Water Level 1"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 1 FILL(null)",influxql
Water Level ,"SELECT ""waterLevel"" AS ""Water Level 2"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 2 FILL(null)",influxql
Compressor 1 service timer,"SELECT min(""lowestServiceCounter"") FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.logevent_timerInfo"" WHERE salIndex = 1 and time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Mirror Support Air (psi),"SELECT ""linePressure"" * 0.0145038 AS ""linePressure 1"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE salIndex = 1 AND time > :dashboardTime: AND time < :upperDashboardTime: FILL(null)",influxql
Mirror Support Air (psi),"SELECT ""linePressure"" * 0.0145038 AS ""linePressure 2"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE salIndex = 2 AND time > :dashboardTime: AND time < :upperDashboardTime: FILL(null)",influxql
Motor current,"SELECT ""motorCurrent"" AS ""motorCurrent 1"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE salIndex = 1 AND time > :dashboardTime: AND time < :upperDashboardTime: FILL(null)",influxql
Motor current,"SELECT ""motorCurrent"" AS ""motorCurrent 2"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE salIndex = 2 AND time > :dashboardTime: AND time < :upperDashboardTime: FILL(null)",influxql
Motor Speed in RPM,"SELECT ""motorSpeedRPM"" AS ""motorSpeedRPM 1"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 1 FILL(null)",influxql
Motor Speed in RPM,"SELECT ""motorSpeedRPM"" AS ""motorSpeedRPM 2"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 2 FILL(null)",influxql
Stage 1 Output Pressure,"SELECT ""stage1OutputPressure"" * 0.0145038 as ""stage1OutputPressure 1"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 1 FILL(null)",influxql
Stage 1 Output Pressure,"SELECT ""stage1OutputPressure"" * 0.0145038 as ""stahe1OutputPressure 2"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 2 FILL(null)",influxql
Compressor 2 service timer,"SELECT min(""lowestServiceCounter"") FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.logevent_timerInfo"" WHERE salIndex = 2 and time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTMount_logevent_elevationInPosition,"SELECT ""inPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_elevationInPosition"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTMount_logevent_azimuthInPosition,"SELECT ""inPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_azimuthInPosition"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTDome_logevent_azMotion,"SELECT ""inPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTDome.logevent_azMotion"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Untitled Graph,"SELECT mean(""waterOutTmp"") AS ""mean_waterOutTmp"", mean(""waterInTmp"") AS ""mean_waterInTmp"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.pathfinder_refrig_Cryo1"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
CC rejectTemperature cryotel1,"SELECT mean(""rejectTemperature"") AS ""mean_rejectTemperature"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.vacuum_Cold1"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Dynalene Temperatures,"SELECT mean(""dynCH02supTS07"") AS ""mean_dynCH02supTS07"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
GenericCamera:103,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.GCHeaderService.logevent_summaryState"" WHERE salIndex = 103 ORDER BY DESC LIMIT 1",influxql
GenericCamera:102,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.GenericCamera.logevent_summaryState"" WHERE salIndex = 102 ORDER BY DESC LIMIT 1",influxql
GenericCamera:101,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.GenericCamera.logevent_summaryState"" WHERE salIndex = 101 ORDER BY DESC LIMIT 1",influxql
GCHeaderService:102,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.GCHeaderService.logevent_summaryState"" WHERE salIndex = 102 ORDER BY DESC LIMIT 1",influxql
GCHeaderService:103,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.GCHeaderService.logevent_summaryState"" WHERE salIndex = 103 ORDER BY DESC LIMIT 1",influxql
GCHeaderService:101,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.GCHeaderService.logevent_summaryState"" WHERE salIndex = 101 ORDER BY DESC LIMIT 1",influxql
Camera Hexapod Temperatures,"SELECT ""temperatureC03"", ""temperatureC05"", ""temperatureC06"", ""temperatureC01"", ""temperatureC04"", ""temperatureC02"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature8Ch"" WHERE salIndex = 1 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
M2 Status,"SELECT ""mode"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_closedLoopControlMode"" ORDER BY DESC LIMIT 1",influxql
Speed,"SELECT ""speed"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Max Wind Speed,"SELECT ""maxSpeed"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Wind Direction,"SELECT mean(""direction"") AS ""mean_direction"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Dewpoint,"SELECT ""dewPointItem"" FROM ""efd"".""autogen"".""lsst.sal.ESS.dewPoint"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:  FILL(null)",influxql
Relative Humidity,"SELECT ""relativeHumidityItem"" FROM ""efd"".""autogen"".""lsst.sal.ESS.relativeHumidity"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Wind Direction,"SELECT ""direction"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow""  WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:  FILL(null)",influxql
Wind Speed,"SELECT ""speed"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:  FILL(null)",influxql
Barometric Pressure,"SELECT ""pressureItem0"" / 100.0 FROM ""efd"".""autogen"".""lsst.sal.ESS.pressure"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Relative Humidity,"SELECT ""relativeHumidityItem"" FROM ""efd"".""autogen"".""lsst.sal.ESS.relativeHumidity""  WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:  FILL(null)",influxql
Air Temperature,"SELECT ""temperatureItem0"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Air Temperature,"SELECT mean(""dewPointItem"") AS ""mean_dewPointItem"" FROM ""efd"".""autogen"".""lsst.sal.ESS.dewPoint"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Header sequence,"SELECT ""url"" FROM ""efd"".""autogen"".""lsst.sal.MTHeaderService.logevent_largeFileObjectAvailable"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Position 1 (mm),"SELECT ""position1"" FROM ""efd"".""autogen"".""lsst.sal.PMD.position"" WHERE PMDID = 2 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Position 2 (mm),"SELECT ""position2"" FROM ""efd"".""autogen"".""lsst.sal.PMD.position"" WHERE PMDID = 2 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Position 3 (mm),"SELECT ""position3"" FROM ""efd"".""autogen"".""lsst.sal.PMD.position"" WHERE PMDID = 2 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Position 0 (mm),"SELECT ""position0"" FROM ""efd"".""autogen"".""lsst.sal.PMD.position"" WHERE PMDID = 2 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Wind Speed,"SELECT ""avg2M"" FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.windSpeed"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTOODS,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.MTOODS.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
MTHeaderService,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.MTHeaderService.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
EPM,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.EPM.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Electrometer,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.Electrometer.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
CBP,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.CBP.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
MTCamera,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.MTCamera.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
LaserTracker,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.LaserTracker.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
FiberSpectrograph,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.FiberSpectrograph.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
MTM1M3TS,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
GIS,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
MTAirCompressor,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
MTDomeTrajectory,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.MTDomeTrajectory.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
MTDome,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.MTDome.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
ATDomeTrajectory,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.ATDomeTrajectory.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
OCPS,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.OCPS.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
ESS,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.ESS.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Watcher,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.Watcher.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Script,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.Script.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Scheduler,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.Scheduler.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
MTRotator,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
MTVMS,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.MTVMS.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
MTPtg,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.MTPtg.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
MTMount,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
MTM2,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
MTM1M3,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
MTHexapod,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
MTAOS,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
DSM,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.DSM.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
DIMM,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.DIMM.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
CCHeaderService,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.CCHeaderService.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
CCCamera,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
CCOODS,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.CCOODS.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
ATSpectrograph,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.ATSpectrograph.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
ATPtg,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.ATPtg.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
ATPneumatics,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.ATPneumatics.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
ATHexapod,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.ATHexapod.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
ATHeaderService,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.ATHeaderService.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
ATCamera,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
ATDome,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.ATDome.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
ATOODS,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.ATOODS.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
ATAOS,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
WeatherStation (ESS:301),"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.ESS.logevent_heartbeat"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
ATMCS,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
PMD,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.PMD.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
HVAC,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
ScriptQueue,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.ScriptQueue.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
GenericCamera,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.GenericCamera.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Test,"SELECT count(""heartbeat"") AS ""count_heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.Test.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
EL Drives temperature,"SELECT mean(""actualTemperature2"") AS ""mean_actualTemperature2"", mean(""actualTemperature4"") AS ""mean_actualTemperature4"", mean(""actualTemperature6"") AS ""mean_actualTemperature6"", mean(""actualTemperature8"") AS ""mean_actualTemperature8"", mean(""actualTemperature10"") AS ""mean_actualTemperature10"", mean(""actualTemperature12"") AS ""mean_actualTemperature12"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevationDrivesThermal"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
EL Drives currents,"SELECT mean(""current0"") AS ""mean_current0"", mean(""current1"") AS ""mean_current1"", mean(""current2"") AS ""mean_current2"", mean(""current3"") AS ""mean_current3"", mean(""current4"") AS ""mean_current4"", mean(""current5"") AS ""mean_current5"", mean(""current6"") AS ""mean_current6"", mean(""current7"") AS ""mean_current7"", mean(""current8"") AS ""mean_current8"", mean(""current9"") AS ""mean_current9"", mean(""current10"") AS ""mean_current10"", mean(""current11"") AS ""mean_current11"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevationDrives"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
EL axis position/torque/speed,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"", mean(""actualTorque"") AS ""mean_actualTorque"", mean(""actualVelocity"") AS ""mean_actualVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Reil CryoTel Temperatures,"SELECT ""temperature"", ""temp"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.vacuum_Cold1"", ""efd"".""autogen"".""lsst.sal.CCCamera.vacuum_Cold2"", ""efd"".""autogen"".""lsst.sal.CCCamera.vacuum_Cryo"" WHERE time > :dashboardTime: ",influxql
VQ Monitor Pressure,"SELECT ""vqmpressure"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.vacuum_VQMonitor"" WHERE time > :dashboardTime:",influxql
CryoTel Temperatures,"SELECT ""temperature"", ""temp"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.vacuum_Cold1"", ""efd"".""autogen"".""lsst.sal.CCCamera.vacuum_Cold2"", ""efd"".""autogen"".""lsst.sal.CCCamera.vacuum_Cryo"" WHERE time > :dashboardTime: ",influxql
CryoTel Powers,"SELECT ""power"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.vacuum_Cold1"", ""efd"".""autogen"".""lsst.sal.CCCamera.vacuum_Cold2"", ""efd"".""autogen"".""lsst.sal.CCCamera.vacuum_Cryo"" WHERE time > :dashboardTime: ",influxql
M2 Status (Last 300 hr),"// Verificacin previa de commVoltage
lastCommVoltage = from(bucket: ""efd/autogen"")
  |> range(start: -300h)
  |> filter(fn: (r) => r._measurement == ""lsst.sal.MTM2.powerStatus"" and r._field == ""commVoltage"")
  |> last()
  |> yield(name: ""last_commVoltage"")

// Obtener el valor de commVoltage
commVoltageValue = lastCommVoltage
  |> findColumn(
    fn: (key) => key._field == ""commVoltage"",
    column: ""_value""
  )

// Resto del script original con modificaciones
state = from(bucket: ""efd/autogen"")
  |> range(start: -300h)
  |> filter(fn: (r) => r._measurement == ""lsst.sal.MTM2.logevent_summaryState"" and (r._field == ""summaryState""))
  |> last()
  |> findColumn(
    fn: (key) => key._field == ""summaryState"", column: ""_value"",
  )
state_value = state[0]

from(bucket: ""efd/autogen"")
  |> range(start: -300h)
  |> filter(fn: (r) => r._measurement == ""lsst.sal.MTM2.logevent_closedLoopControlMode"" and (r._field == ""mode""))
  |> sort(columns: [""_time""], desc: true)
  |> limit(n: 5)
  |> map(fn: (r) => ({
    r with
    _value: if commVoltageValue[0] < 20.0 then 1
            else if state_value == 4 then 1
            else if state_value == 5 then 1
            else r._value,
    summaryState: if commVoltageValue[0] < 20.0 then ""IDLE""
                  else if r._value == 1 then ""IDLE""
                  else if r._value == 2 then ""TELEMETRY""
                  else if r._value == 3 then ""OPEN LOOP""
                  else if r._value == 4 then ""CLOSED LOOP""
                  else string(v: r._value)
  }))",flux
M2 Status (Last 24 hr),"// Verificacin previa de commVoltage
lastCommVoltage = from(bucket: ""efd/autogen"")
  |> range(start: -24h)
  |> filter(fn: (r) => r._measurement == ""lsst.sal.MTM2.powerStatus"" and r._field == ""commVoltage"")
  |> last()
  |> yield(name: ""last_commVoltage"")

// Obtener el valor de commVoltage
commVoltageValue = lastCommVoltage
  |> findColumn(
    fn: (key) => key._field == ""commVoltage"",
    column: ""_value""
  )

// Resto del script original con modificaciones
state = from(bucket: ""efd/autogen"")
  |> range(start: -24h)
  |> filter(fn: (r) => r._measurement == ""lsst.sal.MTM2.logevent_summaryState"" and (r._field == ""summaryState""))
  |> last()
  |> findColumn(
    fn: (key) => key._field == ""summaryState"", column: ""_value"",
  )
state_value = state[0]

from(bucket: ""efd/autogen"")
  |> range(start: -24h)
  |> filter(fn: (r) => r._measurement == ""lsst.sal.MTM2.logevent_closedLoopControlMode"" and (r._field == ""mode""))
  |> sort(columns: [""_time""], desc: true)
  |> limit(n: 1)
  |> map(fn: (r) => ({
    r with
    _value: if commVoltageValue[0] < 20.0 then 1
            else if state_value == 4 then 1
            else if state_value == 5 then 1
            else r._value,
    summaryState: if commVoltageValue[0] < 20.0 then ""IDLE""
                  else if r._value == 1 then ""IDLE""
                  else if r._value == 2 then ""TELEMETRY""
                  else if r._value == 3 then ""OPEN LOOP""
                  else if r._value == 4 then ""CLOSED LOOP""
                  else string(v: r._value)
  }))",flux
M2 Status (Dashboard Time) (last 10 entries),"// Verificacin previa de commVoltage
lastCommVoltage = from(bucket: ""efd/autogen"")
  |> range(start: dashboardTime, stop: upperDashboardTime)
  |> filter(fn: (r) => r._measurement == ""lsst.sal.MTM2.powerStatus"" and r._field == ""commVoltage"")
  |> last()
  |> yield(name: ""last_commVoltage"")

// Obtener el valor de commVoltage
commVoltageValue = lastCommVoltage
  |> findColumn(
    fn: (key) => key._field == ""commVoltage"",
    column: ""_value""
  )

// Resto del script original con modificaciones
state = from(bucket: ""efd/autogen"")
  |> range(start: dashboardTime, stop: upperDashboardTime)
  |> filter(fn: (r) => r._measurement == ""lsst.sal.MTM2.logevent_summaryState"" and (r._field == ""summaryState""))
  |> last()
  |> findColumn(
    fn: (key) => key._field == ""summaryState"", column: ""_value"",
  )
state_value = state[0]

from(bucket: ""efd/autogen"")
  |> range(start: dashboardTime, stop: upperDashboardTime)
  |> filter(fn: (r) => r._measurement == ""lsst.sal.MTM2.logevent_closedLoopControlMode"" and (r._field == ""mode""))
  |> sort(columns: [""_time""], desc: true)
  |> limit(n: 10)
  |> map(fn: (r) => ({
    r with
    _value: if commVoltageValue[0] < 20.0 then 1
            else if state_value == 4 then 1
            else if state_value == 5 then 1
            else r._value,
    summaryState: if commVoltageValue[0] < 20.0 then ""IDLE""
                  else if r._value == 1 then ""IDLE""
                  else if r._value == 2 then ""TELEMETRY""
                  else if r._value == 3 then ""OPEN LOOP""
                  else if r._value == 4 then ""CLOSED LOOP""
                  else string(v: r._value)
  }))",flux
HP Z rotation,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] == ""zRotation"")
  |> map(fn: (r) => ({ r with _value: r._value * 3600.0 }))


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
HP Y rotation,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] == ""yRotation"")
  |> map(fn: (r) => ({ r with _value: r._value * 3600.0 }))


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
IMS Y rotation,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.imsData"")
  |> filter(fn: (r) => r[""_field""] == ""yRotation"")
  |> map(fn: (r) => ({ r with _value: r._value * 3600.0 }))


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
HP Z position,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] == ""zPosition"")
  |> map(fn: (r) => ({ r with _value: r._value * 1000.0 }))


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
HP Y position,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] == ""yPosition"")
  |> map(fn: (r) => ({ r with _value: r._value * 1000.0 }))


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
HP X position,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] == ""xPosition"")
  |> map(fn: (r) => ({ r with _value: r._value * 1000.0 }))


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Commanded Z rotation,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.command_positionM1M3"")
  |> filter(fn: (r) => r[""_field""] == ""ZRotation"")
  |> map(fn: (r) => ({ r with _value: r._value * 3600.0 }))


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Commanded Y rotation,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.command_positionM1M3"")
  |> filter(fn: (r) => r[""_field""] == ""yRotation"")
  |> map(fn: (r) => ({ r with _value: r._value * 3600.0 }))


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Commanded X rotation,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.command_positionM1M3"")
  |> filter(fn: (r) => r[""_field""] == ""xRotation"")
  |> map(fn: (r) => ({ r with _value: r._value * 3600.0 }))


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Commanded Z position,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.command_positionM1M3"")
  |> filter(fn: (r) => r[""_field""] == ""zPosition"")
  |> map(fn: (r) => ({ r with _value: r._value * 1000.0 }))


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Commanded Y position,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.command_positionM1M3"")
  |> filter(fn: (r) => r[""_field""] == ""yPosition"")
  |> map(fn: (r) => ({ r with _value: r._value * 1000.0 }))


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Commanded X position,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.command_positionM1M3"")
  |> filter(fn: (r) => r[""_field""] == ""xPosition"")
  |> map(fn: (r) => ({ r with _value: r._value * 1000.0 }))


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
IMS Z rotation,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.imsData"")
  |> filter(fn: (r) => r[""_field""] == ""zRotation"")
  |> map(fn: (r) => ({ r with _value: r._value * 3600.0 }))


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
HP X rotation,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] == ""xRotation"")
  |> map(fn: (r) => ({ r with _value: r._value * 3600.0 }))


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
IMS X rotation,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.imsData"")
  |> filter(fn: (r) => r[""_field""] == ""xRotation"")
  |> map(fn: (r) => ({ r with _value: r._value * 3600.0 }))


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
IMS Z position,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.imsData"")
  |> filter(fn: (r) => r[""_field""] == ""zPosition"")
  |> map(fn: (r) => ({ r with _value: r._value * 1000.0 }))


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
IMS Y position,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.imsData"")
  |> filter(fn: (r) => r[""_field""] == ""yPosition"")
  |> map(fn: (r) => ({ r with _value: r._value * 1000.0 }))


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
IMS X position,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.imsData"")
  |> filter(fn: (r) => r[""_field""] == ""xPosition"")
  |> map(fn: (r) => ({ r with _value: r._value * 1000.0 }))


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
AOSM1,"SELECT ""pressure"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_m1CorrectionCompleted""  ORDER BY DESC LIMIT 1",influxql
M1,"SELECT ""pressure"" FROM ""efd"".""autogen"".""lsst.sal.ATPneumatics.command_m1SetPressure"" ORDER BY DESC LIMIT 1",influxql
AOS-X,"SELECT ""hexapod_x"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_hexapodCorrectionCompleted""  ORDER BY DESC LIMIT 1",influxql
AOS-Y,"SELECT ""hexapod_y"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_hexapodCorrectionCompleted""  ORDER BY DESC LIMIT 1",influxql
AOS-Z,"SELECT ""hexapod_z"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_hexapodCorrectionCompleted""  ORDER BY DESC LIMIT 1",influxql
ATpneumatics,"SELECT ""pressure"" FROM ""efd"".""autogen"".""lsst.sal.ATPneumatics.m1AirPressure"" ORDER BY DESC LIMIT 1000",influxql
ATpneumatics,"SELECT ""pressure"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_m1CorrectionStarted"" ORDER BY DESC LIMIT 1000",influxql
Test 42,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.Test.logevent_summaryState"" WHERE salIndex = 42 ORDER BY DESC LIMIT 1",influxql
TMA Torque,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevation"")
  |> filter(fn: (r) => r[""_field""] == ""actualTorque"")

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Slew Flag,"from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.logevent_boosterValveStatus"")
  |> filter(fn: (r) => r[""_field""] == ""slewFlag"")
  |> map(fn: (r) => ({r with _value: if r._value == true then 1 else 0}))",flux
Hardpoints Forces,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /measuredForce./)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
TMA Elevation,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevation"")
  |> filter(fn: (r) => r[""_field""] == ""actualPosition"")

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
IMS position,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.imsData"")
  |> filter(fn: (r) => r[""_field""] =~ /^.Position$/)

data",flux
IMS raw,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.imsData"")
  |> filter(fn: (r) => r[""_field""] =~ /rawSensorData.$/)

data",flux
HP forces,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /measuredForce.$/)

data",flux
Following error secondary index 90-99,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /secondaryCylinderFollowingError9.$/)

data",flux
Following error secondary index 100-112,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /secondaryCylinderFollowingError1[01].$/)

data",flux
Following error secondary index 40-49,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /secondaryCylinderFollowingError4.$/)

data",flux
Following error secondary index 70-79,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /secondaryCylinderFollowingError7.$/)

data",flux
Following error secondary index 30-39,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /secondaryCylinderFollowingError3.$/)

data",flux
Following error secondary index 50-59,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /secondaryCylinderFollowingError5.$/)

data",flux
Following error secondary index 80-89,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /secondaryCylinderFollowingError8.$/)

data",flux
Following error secondary index 10-19,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /secondaryCylinderFollowingError1.$/)

data",flux
Following error secondary index 0-9,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /secondaryCylinderFollowingError.$/)

data",flux
Following error secondary index 60-69,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /secondaryCylinderFollowingError6.$/)

data",flux
Following error index 100-109,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /primaryCylinderFollowingError10.$/)

data",flux
Following error index 110-119,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /primaryCylinderFollowingError11.$/)

data",flux
Following error index 150-156,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /primaryCylinderFollowingError15.$/)

data",flux
Following error secondary index 20-29,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /secondaryCylinderFollowingError2.$/)

data",flux
Following error index 140-149,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /primaryCylinderFollowingError14.$/)

data",flux
Following error index 120-129,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /primaryCylinderFollowingError12./)

data",flux
Following error index 130-139,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /primaryCylinderFollowingError13.$/)

data",flux
Following error index 70-79,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /primaryCylinderFollowingError7.$/)

data",flux
Following error index 80-89,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /primaryCylinderFollowingError8.$/)

data",flux
Following error index 90-99,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /primaryCylinderFollowingError9.$/)

data",flux
Following error index 60-69,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /primaryCylinderFollowingError6.$/)

data",flux
Following error index 50-59,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /primaryCylinderFollowingError5.$/)

data",flux
Following error index 40-49,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /primaryCylinderFollowingError4.$/)

data",flux
Following error index 30-39,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /primaryCylinderFollowingError3.$/)

data",flux
Following error index 20-29,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /primaryCylinderFollowingError2.$/)

data",flux
Following error index 0-9,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /primaryCylinderFollowingError.$/)

data",flux
Following error index 10-19,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /primaryCylinderFollowingError1.$/)

data",flux
HP encoders,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /encoder.$/)

data",flux
IMS rotation,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.imsData"")
  |> filter(fn: (r) => r[""_field""] =~ /^.Rotation$/)

data",flux
Accelerometers raw,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] =~ /^rawAccelerometer.$/)

data",flux
Ambient Air Temperature above M1M3 RoC (<1C/hr),"SELECT difference(last(""temperatureItem0"")) FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 113 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(1h)",influxql
M1M3 temps,"SELECT mean(""temperatureItem0"") AS ""Outside air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 temps,"SELECT mean(""temperatureItem0"") AS ""Camera air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 111 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 temps,"SELECT mean(""temperatureItem0"") AS ""M2 air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 112 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 temps,"SELECT mean(""temperatureItem0"") AS ""M1M3 air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 113 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 temps,"SELECT mean(""absoluteTemperature0"") AS ""mean_absoluteTemperature0"", mean(""absoluteTemperature10"") AS ""mean_absoluteTemperature10"", mean(""absoluteTemperature20"") AS ""mean_absoluteTemperature20"", mean(""absoluteTemperature30"") AS ""mean_absoluteTemperature30"", mean(""absoluteTemperature40"") AS ""mean_absoluteTemperature40"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.thermalData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Glycol delivered temp vs. ambient,"SELECT mean(""glycolTemperaturePier0001"") AS ""Glycol General Temp 0001"", mean(""glycolTemperaturePier0002"") AS ""Glycol General Temp 0002"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.generalPurposeGlycolWater"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Glycol delivered temp vs. ambient,"SELECT mean(""ambientTemperature"") AS ""Azimuth Floor Air Ambient Temp"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.topEndChiller"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Glycol delivered temp vs. ambient,"SELECT mean(""glycolTemperaturePier0101"") AS ""Cold Glycol Temp 0101"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.cooling"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Glycol delivered temp vs. ambient,"SELECT mean(""absoluteTemperature0"") AS ""mean_absoluteTemperature0"", mean(""absoluteTemperature1"") AS ""mean_absoluteTemperature1"", mean(""absoluteTemperature10"") AS ""mean_absoluteTemperature10"", mean(""absoluteTemperature11"") AS ""mean_absoluteTemperature11"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.thermalData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""temperatureItem0"") AS ""Outside air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""temperatureItem0"") AS ""Camera air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 111 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""temperatureItem0"") AS ""M2 air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 112 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""temperatureItem0"") AS ""M1M3 air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 113 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""mainCabinetExternalTemperature"") AS ""Tekniker Cabinet External air temp"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.mainCabinetThermal"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""ambientTemperature"") AS ""Azimuth Floor Air Ambient Temp"", mean(""ambientTemperatureSensor0502"") AS ""Top End Hex Return air temp"", mean(""temperatureSensor0501"") AS ""Top End Rear air temp"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.topEndChiller"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Chiller 1/2,"SELECT mean(""setpointActivo"") AS ""mean_setpointActivo"", mean(""temperaturaAguaImpulsionEvaporador"") AS ""mean_temperaturaAguaImpulsionEvaporador"", mean(""temperaturaAguaRetornoEvaporador"") AS ""mean_temperaturaAguaRetornoEvaporador"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.chiller01P01"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Chiller 1/2,"SELECT mean(""setpointActivo"") AS ""mean_setpointActivo"", mean(""temperaturaAguaImpulsionEvaporador"") AS ""mean_temperaturaAguaImpulsionEvaporador"", mean(""temperaturaAguaRetornoEvaporador"") AS ""mean_temperaturaAguaRetornoEvaporador"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.chiller02P01"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Chiller 3,"SELECT mean(""setpointActivo"") AS ""mean_setpointActivo"", mean(""temperaturaAguaImpulsionEvaporador"") AS ""mean_temperaturaAguaImpulsionEvaporador"", mean(""temperaturaAguaRetornoEvaporador"") AS ""mean_temperaturaAguaRetornoEvaporador"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.chiller03P01"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Outside Temperature RoC (<1.0C/hr),"SELECT difference(last(""temperatureItem0"")) FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(1h)",influxql
M1M3 Internal Air Cell Temperature RoC (<0.75C/hr),"SELECT difference(last(""absoluteTemperature0"")), difference(last(""absoluteTemperature1"")), difference(last(""absoluteTemperature2"")), difference(last(""absoluteTemperature3"")) , difference(last(""absoluteTemperature4"")) , difference(last(""absoluteTemperature5"")) , difference(last(""absoluteTemperature6"")) , difference(last(""absoluteTemperature7"")) , difference(last(""absoluteTemperature8"")) , difference(last(""absoluteTemperature9"")) , difference(last(""absoluteTemperature10"")) , difference(last(""absoluteTemperature11"")) , difference(last(""absoluteTemperature12"")) , difference(last(""absoluteTemperature13"")) , difference(last(""absoluteTemperature14"")) , difference(last(""absoluteTemperature15"")) , difference(last(""absoluteTemperature16"")) , difference(last(""absoluteTemperature17"")) , difference(last(""absoluteTemperature18"")) , difference(last(""absoluteTemperature19"")) , difference(last(""absoluteTemperature20"")) , difference(last(""absoluteTemperature21"")) , difference(last(""absoluteTemperature22"")) , difference(last(""absoluteTemperature23"")) , difference(last(""absoluteTemperature24"")) , difference(last(""absoluteTemperature25"")) , difference(last(""absoluteTemperature26"")) , difference(last(""absoluteTemperature27"")) , difference(last(""absoluteTemperature28"")) , difference(last(""absoluteTemperature29"")) , difference(last(""absoluteTemperature30"")) , difference(last(""absoluteTemperature31"")) , difference(last(""absoluteTemperature32"")) , difference(last(""absoluteTemperature33"")) , difference(last(""absoluteTemperature34"")) , difference(last(""absoluteTemperature35"")) , difference(last(""absoluteTemperature36"")) , difference(last(""absoluteTemperature37"")) , difference(last(""absoluteTemperature38"")) , difference(last(""absoluteTemperature39"")) , difference(last(""absoluteTemperature40"")) , difference(last(""absoluteTemperature41"")) , difference(last(""absoluteTemperature42"")) , difference(last(""absoluteTemperature43"")) , difference(last(""absoluteTemperature44"")) , difference(last(""absoluteTemperature45"")) , difference(last(""absoluteTemperature46"")) , difference(last(""absoluteTemperature47"")) , difference(last(""absoluteTemperature48"")) , difference(last(""absoluteTemperature49"")) , difference(last(""absoluteTemperature50"")) , difference(last(""absoluteTemperature51"")) , difference(last(""absoluteTemperature52"")) , difference(last(""absoluteTemperature53"")) , difference(last(""absoluteTemperature54"")) , difference(last(""absoluteTemperature55"")) , difference(last(""absoluteTemperature56"")) , difference(last(""absoluteTemperature57"")) , difference(last(""absoluteTemperature58"")) , difference(last(""absoluteTemperature59"")) , difference(last(""absoluteTemperature60"")) , difference(last(""absoluteTemperature61"")) , difference(last(""absoluteTemperature62"")) , difference(last(""absoluteTemperature63"")) , difference(last(""absoluteTemperature64"")) , difference(last(""absoluteTemperature65"")) , difference(last(""absoluteTemperature66"")) , difference(last(""absoluteTemperature67"")) , difference(last(""absoluteTemperature68"")) , difference(last(""absoluteTemperature69"")) , difference(last(""absoluteTemperature70"")) , difference(last(""absoluteTemperature71"")) , difference(last(""absoluteTemperature72"")) , difference(last(""absoluteTemperature73"")) , difference(last(""absoluteTemperature74"")) , difference(last(""absoluteTemperature75"")) , difference(last(""absoluteTemperature76"")) , difference(last(""absoluteTemperature77"")) , difference(last(""absoluteTemperature78"")) , difference(last(""absoluteTemperature79"")) , difference(last(""absoluteTemperature80"")) , difference(last(""absoluteTemperature81"")) , difference(last(""absoluteTemperature82"")) , difference(last(""absoluteTemperature83"")) , difference(last(""absoluteTemperature84"")) , difference(last(""absoluteTemperature85"")) , difference(last(""absoluteTemperature86"")) , difference(last(""absoluteTemperature87"")) , difference(last(""absoluteTemperature88"")) , difference(last(""absoluteTemperature89"")) , difference(last(""absoluteTemperature90"")) , difference(last(""absoluteTemperature91"")), difference(last(""absoluteTemperature92"")) , difference(last(""absoluteTemperature93"")) , difference(last(""absoluteTemperature94"")) , difference(last(""absoluteTemperature95""))    FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.thermalData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(1h)",influxql
Outside Temperature RoC (1 min sampling),"SELECT difference(last(""temperatureItem0"")) FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(1m)",influxql
Calibrated Actuator Position,"SELECT ""calibrated0"", ""calibrated1"", ""calibrated2"", ""calibrated3"", ""calibrated4"", ""calibrated5"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.actuators"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Commanded vs Reached Position,"SELECT ""demand0"", ""demand1"", ""demand2"", ""demand3"", ""demand4"", ""demand5"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Commanded vs Reached Position,"SELECT ""position0"", ""position1"", ""position2"", ""position3"", ""position4"", ""position5"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTHexapod.application error,"SELECT mean(""error0"") AS ""mean_error0"", mean(""error1"") AS ""mean_error1"", mean(""error2"") AS ""mean_error2"", mean(""error3"") AS ""mean_error3"", mean(""error4"") AS ""mean_error4"", mean(""error5"") AS ""mean_error5"", mean(""demand0"") AS ""mean_demand0"", mean(""demand1"") AS ""mean_demand1"", mean(""demand2"") AS ""mean_demand2"", mean(""demand3"") AS ""mean_demand3"", mean(""demand4"") AS ""mean_demand4"", mean(""demand5"") AS ""mean_demand5"", mean(""position0"") AS ""mean_position0"", mean(""position1"") AS ""mean_position1"", mean(""position2"") AS ""mean_position2"", mean(""position3"") AS ""mean_position3"", mean(""position4"") AS ""mean_position4"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Motor voltages,"SELECT mean(""motorVoltage1"") AS ""mean_motorVoltage1"", mean(""motorVoltage2"") AS ""mean_motorVoltage2"", mean(""motorVoltage3"") AS ""mean_motorVoltage3"", mean(""motorVoltage4"") AS ""mean_motorVoltage4"", mean(""motorVoltage5"") AS ""mean_motorVoltage5"", mean(""motorVoltage0"") AS ""mean_motorVoltage0"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.electrical"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:sampling:) FILL(null)",influxql
Motor currents,"SELECT mean(""motorCurrent1"") AS ""mean_motorCurrent1"", mean(""motorCurrent2"") AS ""mean_motorCurrent2"", mean(""motorCurrent3"") AS ""mean_motorCurrent3"", mean(""motorCurrent4"") AS ""mean_motorCurrent4"", mean(""motorCurrent5"") AS ""mean_motorCurrent5"", mean(""motorCurrent0"") AS ""mean_motorCurrent0"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.electrical"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:sampling:) FILL(null)",influxql
"MTHexapod.logevent_uncompensatedPosition: u,v,w ","SELECT mean(u) as mean_u, mean(v) as mean_v, mean(w) as mean_w FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_uncompensatedPosition"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime:  GROUP BY time(:sampling:) FILL(null)",influxql
"logevent_compensatedPosition: u,v,w","SELECT mean(u) as mean_u ,mean(v) as mean_v, mean(w) as mean_w FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_compensatedPosition"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime:  GROUP BY time(:sampling:) FILL(null)",influxql
Pivot position,"SELECT pivotX, pivotY, pivotZ FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_configuration"" WHERE salIndex = :SalIndex: ORDER BY DESC LIMIT 20;",influxql
"Compensation inputs: Mount AZ,EL; Rotator angle","SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:sampling:) FILL(null)",influxql
"Compensation inputs: Mount AZ,EL; Rotator angle","SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
"Compensation inputs: Mount AZ,EL; Rotator angle","SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.rotation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Calibrated Actuator Position (linear encoder),"SELECT mean(calibrated0) as mean_calibrated0, mean(calibrated1) as mean_calibrated1, mean(calibrated2) as mean_calibrated2, mean(calibrated3) as mean_calibrated3, mean(calibrated4) as mean_calibrated4, mean(calibrated5) as mean_calibrated5 FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.actuators"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:sampling:) FILL(null)",influxql
Camera Hexapod Temperatures,"SELECT ""temperature5"" as ""Strut 12 temp"", ""temperature4"" as ""Strut 11 temp"", ""temperature3"" as ""Strut 10 temp"", ""temperature2"" as ""Strut 9 temp"", ""temperature1"" as ""Strut 8 temp"", ""temperature0"" as ""Strut 7 temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 1 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Camera Hexapod Temperatures,"SELECT mean(avg1M) as mean_airTemperature FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.airTemperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
"MTHexapod.logevent_uncompensatedPosition: x,y,z","SELECT mean(x) as mean_x, mean(y) as mean_y, mean(z) as mean_z FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_uncompensatedPosition"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime:  GROUP BY time(:sampling:) FILL(null)",influxql
"MTHexapod.logevent_compensatedPosition, x,y,z","SELECT mean(x) as mean_x, mean(y) as mean_y, mean(z) as mean_z FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_compensatedPosition"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime:  GROUP BY time(:sampling:) FILL(null)",influxql
MTHexapod.command_setCompensationMode,"SELECT enable FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.command_setCompensationMode"" WHERE salIndex = :SalIndex: ORDER BY DESC LIMIT 20",influxql
Pivot command,"SELECT x, y, z FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.command_setPivot"" WHERE salIndex = :SalIndex: ORDER BY DESC LIMIT 20",influxql
command_stop,"SELECT private_seqNum, private_identity FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.command_stop"" WHERE salIndex = :SalIndex: ORDER BY DESC LIMIT 5",influxql
Connected,"SELECT connected FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_connected"" WHERE salIndex = :SalIndex: ORDER BY DESC LIMIT 3;",influxql
Position in w [deg],"SELECT mean(position5) as mean_w FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:sampling:) FILL(null)",influxql
Position in v [deg],"SELECT mean(position4) as mean_v FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:sampling:) FILL(null)",influxql
Position in u [deg],"SELECT mean(position3) as mean_u FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:sampling:) FILL(null)",influxql
Position in Y [um],"SELECT mean(position1) as mean_y FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
commandableByDDS,"SELECT state FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_commandableByDDS"" WHERE salIndex = :SalIndex: ORDER BY DESC LIMIT 3;",influxql
Position in Z [um],"SELECT mean(position2) as mean_z FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Position in X [um],"SELECT mean(position0) as mean_x FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:sampling:) FILL(null)",influxql
MTHexapod Summary State,"// CSC states
// STANDBY = 5
// OFFLINE = 4
// FAULT = 3
// ENABLED = 2
// DISABLED = 1

import ""strings""

from(bucket: ""efd/autogen"")
  |> range(start: -inf)
  |> filter(fn: (r) => r._measurement == ""lsst.sal.MTHexapod.logevent_summaryState"")
  |> filter(fn: (r) => r._field == ""summaryState"" or r._field == ""salIndex"")
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> filter(fn: (r) => r.salIndex==int(v: v.SalIndex))
  |> map(fn: (r) => ({
    r with
    state:
      if r.summaryState == 5 then ""5 (STANDBY)""
      else if r.summaryState == 4 then ""4 (OFFLINE)""
      else if r.summaryState == 3 then ""3 (FAULT)""
      else if r.summaryState == 2 then ""2 (ENABLED)""
      else if r.summaryState == 1 then ""1 (DISABLED)""
      else ""UNKNOWN"",
    })
) |> sort(desc: true)
",flux
Script logevents,"SELECT ""ScriptID"", ""level"", ""message"" FROM ""efd"".""autogen"".""lsst.sal.Script.logevent_logMessage"" ORDER BY DESC LIMIT 100",influxql
MTHexapod Heartbeat,"SELECT count(""heartbeat"") FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_heartbeat"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:sampling:) FILL(null)",influxql
controllerState,"SELECT ""controllerState"", ""enabledSubstate"", ""offlineSubstate"", ""applicationStatus0"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_controllerState"" WHERE salIndex =:SalIndex: ORDER BY DESC LIMIT 1000",influxql
"Logevent ""inPosition""","SELECT ""inPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_inPosition"" WHERE salIndex = :SalIndex: ORDER BY DESC LIMIT 1000",influxql
MTHexapod log messages,"SELECT ""level"", ""message"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_logMessage"" WHERE salIndex = :SalIndex: ORDER BY DESC LIMIT 100",influxql
MTHexapod.command_move,"SELECT mean(x) as mean_x, mean(y) as mean_y, mean(z) as mean_z, mean(u) as mean_u, mean(v) as mean_v, mean(w) as mean_w FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.command_move"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime:  GROUP BY time(:sampling:) FILL(null)",influxql
Actutators raw (mean),"SELECT mean(""raw0"") AS ""mean_raw0"", mean(""raw1"") AS ""mean_raw1"", mean(""raw2"") AS ""mean_raw2"", mean(""raw3"") AS ""mean_raw3"", mean(""raw4"") AS ""mean_raw4"", mean(""raw5"") AS ""mean_raw5"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.actuators"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:sampling:) FILL(null)",influxql
Raw Acutators,"SELECT mean(""raw0"") as mean_raw0, mean(""raw1"") as mean_raw1, mean(""raw2"") as mean_raw2, mean(""raw3"") as mean_raw3, mean(""raw4"") as mean_raw4, mean(""raw5"") as mean_raw5 FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.actuators"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime:  GROUP BY time(:sampling:) FILL(null)",influxql
Copley Drive Status,"SELECT ""copleyStatusWordDrive3"", ""copleyStatusWordDrive4"", ""copleyStatusWordDrive5"", ""copleyStatusWordDrive2"", ""copleyStatusWordDrive1"", ""copleyStatusWordDrive0"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.electrical"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Position Error,"SELECT ""positionError0"", ""positionError1"", ""positionError2"", ""positionError3"", ""positionError4"", ""positionError5"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.actuators"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Test: 6 - Ac4X (Calibrated) ,"import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] =~ /rawAccelerometer[6]/)
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> map(fn: (r) => ({r with _value: ((r.rawAccelerometer6+0.0108)/1.994)})) 


if v.Function == ""Raw"" then
  data |> drop(columns: [""rawAccelerometer5"", ""rawAccelerometer7""])
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
TMA Azimuth acceleration,"import ""math""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.azimuth"")
  |> filter(fn: (r) => r[""_field""] == ""actualVelocity"" or r[""_field""] == ""demandVelocity"" or r[""_field""] == ""timestamp"")
  |> difference()  
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> map(fn: (r) => ({_time: r._time, demandAcceleration: r.demandVelocity / r.timestamp, actualAcceleration: r.actualVelocity / r.timestamp}) )
  

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false, column: ""actualAcceleration"")      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false, column: ""actualAcceleration"")
    else 
      data",flux
Test: 2 - Ac2X (Calibrated) ,"import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] =~ /rawAccelerometer[2]/)
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> map(fn: (r) => ({r with _value: ((r.rawAccelerometer2-0.0125)/1.994)})) 


if v.Function == ""Raw"" then
  data |> drop(columns: [""rawAccelerometer5"", ""rawAccelerometer7""])
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Test: 3 - Ac2Y (Calibrated),"import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] =~ /rawAccelerometer[3]/)
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> map(fn: (r) => ({r with _value: ((r.rawAccelerometer3-0.0070)/1.995)})) 


if v.Function == ""Raw"" then
  data |> drop(columns: [""rawAccelerometer5"", ""rawAccelerometer7""])
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Test: 1 - Ac1Y (Calibrated) ,"import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] =~ /rawAccelerometer[1]/)
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> map(fn: (r) => ({r with _value: ((r.rawAccelerometer1-0.0039)/1.994)})) 


if v.Function == ""Raw"" then
  data |> drop(columns: [""rawAccelerometer5"", ""rawAccelerometer7""])
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Mount Azimuth,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Test: 4 - Ac3X (Calibrated) ,"import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] =~ /rawAccelerometer[4]/)
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> map(fn: (r) => ({r with _value: ((r.rawAccelerometer4-0.0146)/1.997)})) 


if v.Function == ""Raw"" then
  data |> drop(columns: [""rawAccelerometer5"", ""rawAccelerometer7""])
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Test: 0 - Ac1X (Calibrated) ,"import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] =~ /rawAccelerometer[0]/)
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> map(fn: (r) => ({r with _value: ((r.rawAccelerometer0-0.0090)/1.993)})) 


if v.Function == ""Raw"" then
  data |> drop(columns: [""rawAccelerometer5"", ""rawAccelerometer7""])
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Mount Elevation,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Test: 7 - Ac4Y (Calibrated),"import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] =~ /rawAccelerometer[7]/)
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> map(fn: (r) => ({r with _value: ((r.rawAccelerometer7-0.0179)/1.992)})) 


if v.Function == ""Raw"" then
  data |> drop(columns: [""rawAccelerometer5"", ""rawAccelerometer7""])
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Test: 5 - Ac3Y (Calibrated) ,"import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] =~ /rawAccelerometer[5]/)
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> map(fn: (r) => ({r with _value: ((r.rawAccelerometer5-0.0170)/1.996)})) 


if v.Function == ""Raw"" then
  data |> drop(columns: [""rawAccelerometer5"", ""rawAccelerometer7""])
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
TMA Elevation acceleration,"import ""math""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevation"")
  |> filter(fn: (r) => r[""_field""] == ""actualVelocity"" or r[""_field""] == ""demandVelocity"" or r[""_field""] == ""timestamp"")
  |> difference()  
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> map(fn: (r) => ({_time: r._time, demandAcceleration: r.demandVelocity / r.timestamp, actualAcceleration: r.actualVelocity / r.timestamp}) )
  

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false, column: ""actualAcceleration"")      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false, column: ""actualAcceleration"")
    else 
      data",flux
DC Angular Acceleration,"import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] =~ regexp.compile(v: ""angularAcceleration"" + v.Axis))

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Inclinometer angle,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.inclinometerData"")
  |> filter(fn: (r) => r[""_field""] == ""inclinometerAngle"")
  

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
MTMount Log Errors,"SELECT ""message"", ""level"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_logMessage"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
Untitled Graph,"SELECT actualPosition, timestamp FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
Mount logevent target,"SELECT elevation, azimuth, taiTime FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_target"" ORDER BY DESC LIMIT 20;",influxql
MTMount.elevation,"SELECT ""actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTMount.azimuth,"SELECT ""actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
actualPosition,"SELECT ""actualPosition"", ""timestamp"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
demand Position,"SELECT demandPosition FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime:",influxql
MTMount.logevent_mountState,"SELECT text, id FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_mountState"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
heartbeat,"SELECT heartbeat FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTMount.logevent_logMessage,"SELECT message FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_logMessage"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
MTMount.logevent_target: Elevation and TAI time,"SELECT elevation, taiTime FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_target"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
Azimuth actual - demand position,"SELECT ""actualPosition"" - ""demandPosition"" as difference FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
Camera cable wrap actual and demand position,"SELECT ""actualPosition"", ""demandPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.cameraCableWrap"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: FILL(null)",influxql
GIS,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
CCOCPS,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.OCPS.logevent_summaryState"" WHERE salIndex = 2 ORDER BY DESC LIMIT 1",influxql
MT ScriptQueue,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ScriptQueue.logevent_summaryState"" WHERE ""salIndex"" = 1 ORDER BY DESC LIMIT 1",influxql
ATScheduler,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.Scheduler.logevent_summaryState"" WHERE salIndex = 2 ORDER BY DESC LIMIT 1",influxql
AT ScriptQueue,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ScriptQueue.logevent_summaryState"" WHERE ""salIndex"" = 2 ORDER BY DESC LIMIT 1",influxql
Watcher,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.Watcher.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
MTScheduler,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.Scheduler.logevent_summaryState"" WHERE salIndex = 1 ORDER BY DESC LIMIT 1",influxql
ATOCPS,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.OCPS.logevent_summaryState"" WHERE salIndex = 1 ORDER BY DESC LIMIT 1",influxql
Supported,"SELECT ""supportPercentage"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.logevent_forceActuatorState"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
CCW,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.cameraCableWrap"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
mount elevation (target),"SELECT mean(""elevation"") AS ""mean_elevation"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_target"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
rotator status,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_summaryState"" order by desc limit 1",influxql
MTMount,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
Ptg status,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTPtg.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
Mirror position,"SELECT mean(""zPosition"") AS ""mean_zPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
balance forces,"SELECT mean(""zForces0"") AS ""mean_zForces0"", mean(""xForces4"") AS ""mean_xForces4"", mean(""xForces9"") AS ""mean_xForces9"", mean(""yForces18"") AS ""mean_yForces18"", mean(""yForces41"") AS ""mean_yForces41"", mean(""zForces118"") AS ""mean_zForces118"", mean(""zForces58"") AS ""mean_zForces58"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.logevent_appliedBalanceForces"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
inclinometer,"SELECT mean(""inclinometerAngle"") AS ""mean_inclinometerAngle"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.inclinometerData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
mount elevation,"SELECT mean(""ctual"") AS ""mean_angleActual"", mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
mount azimuth,"SELECT ""angleActual"", ""actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
rotator position,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.rotation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
MTM1M3,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
M1M3 detailed state,"SELECT ""detailedState"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.logevent_detailedState"" ORDER BY DESC LIMIT 1",influxql
Force0,"SELECT mean(""xForce0"") AS ""mean_xForce0"", mean(""yForce0"") AS ""mean_yForce0"", mean(""zForce0"") AS ""mean_zForce0"", mean(""xForce6"") AS ""mean_xForce6"", mean(""yForce48"") AS ""mean_yForce48"", mean(""zForce138"") AS ""mean_zForce138"", mean(""zForce49"") AS ""mean_zForce49"", mean(""yForce88"") AS ""mean_yForce88"", mean(""yForce29"") AS ""mean_yForce29"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.forceActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
IMS,"SELECT mean(""xPosition"") AS ""mean_xPosition"", mean(""xRotation"") AS ""mean_xRotation"", mean(""yPosition"") AS ""mean_yPosition"", mean(""yRotation"") AS ""mean_yRotation"", mean(""zPosition"") AS ""mean_zPosition"", mean(""zRotation"") AS ""mean_zRotation"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.imsData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
DC accelerometers,"SELECT mean(""angularAccelerationX"") AS ""mean_angularAccelerationX"", mean(""angularAccelerationY"") AS ""mean_angularAccelerationY"", mean(""angularAccelerationZ"") AS ""mean_angularAccelerationZ"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.accelerometerData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
errorReport,"SELECT ""errorReport"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.logevent_errorCode"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
M1M3 max and min pressures,"SELECT max(""breakawayPressure1"") AS ""max_breakawayPressure1"", min(""breakawayPressure1"") AS ""min_breakawayPressure1"", max(""breakawayPressure3"") AS ""max_breakawayPressure3"", min(""breakawayPressure3"") AS ""min_breakawayPressure3"", max(""breakawayPressure5"") AS ""max_breakawayPressure5"", min(""breakawayPressure5"") AS ""min_breakawayPressure5"", max(""breakawayPressure4"") AS ""max_breakawayPressure4"", min(""breakawayPressure4"") AS ""min_breakawayPressure4"", max(""breakawayPressure2"") AS ""max_breakawayPressure2"", min(""breakawayPressure2"") AS ""min_breakawayPressure2"", max(""breakawayPressure0"") AS ""max_breakawayPressure0"", min(""breakawayPressure0"") AS ""min_breakawayPressure0"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointMonitorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(1m) FILL(null)",influxql
PID data,"SELECT mean(""measuredPID0"") AS ""mean_measuredPID0"", mean(""measuredPID1"") AS ""mean_measuredPID1"", mean(""measuredPID2"") AS ""mean_measuredPID2"", mean(""measuredPID3"") AS ""mean_measuredPID3"", mean(""measuredPID4"") AS ""mean_measuredPID4"", mean(""measuredPID5"") AS ""mean_measuredPID5"", mean(""controlT10"") AS ""mean_controlT10"", mean(""controlT11"") AS ""mean_controlT11"", mean(""error0"") AS ""mean_error0"", mean(""errorT10"") AS ""mean_errorT10"", mean(""errorT11"") AS ""mean_errorT11"", mean(""control0"") AS ""mean_control0"", mean(""control1"") AS ""mean_control1"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.pidData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 powerSupplyData.timestamp,"SELECT mean(""timestamp"") AS ""mean_timestamp"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.logevent_powerSupplyStatus"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 backupLoadCellCoefficients,"SELECT ""backupLoadCellCoefficient0"", ""backupLoadCellCoefficient1"", ""backupLoadCellCoefficient2"", ""backupLoadCellCoefficient3"", ""backupLoadCellCoefficient4"", ""backupLoadCellCoefficient5"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.logevent_hardpointActuatorInfo"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
"M1M3  hardpointActuatorInfo positions in X,Y,Z","SELECT ""xPosition0"", ""xPosition1"", ""xPosition2"", ""xPosition3"", ""xPosition4"", ""xPosition5"", ""yPosition0"", ""yPosition1"", ""yPosition2"", ""yPosition3"", ""yPosition4"", ""yPosition5"", ""zPosition0"", ""zPosition1"", ""zPosition2"", ""zPosition3"", ""zPosition4"", ""zPosition5"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.logevent_hardpointActuatorInfo"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
M1M3 hardpointMonitorInfo ilcApplicationType,"SELECT ""ilcApplicationType0"", ""ilcApplicationType1"", ""ilcApplicationType2"", ""ilcApplicationType3"", ""ilcApplicationType4"", ""ilcApplicationType5"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.logevent_hardpointMonitorInfo"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Air Compressors,"SELECT mean(""linePressure"") AS ""linePressure 1"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE MTAirCompressorID = 1 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Temperature Inside the Dome (Level 8),"SELECT mean(""temperatureItem0"") AS ""mean_temperatureItem0"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 113 GROUP BY time(:interval:) FILL(null)",influxql
Weather Tower Temperature,"SELECT mean(""temperatureItem0"") AS ""Weather Tower Temperature"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 301 GROUP BY time(:interval:) FILL(null)",influxql
Weather Tower Temperature,"SELECT mean(""temperatureItem0"") AS ""Dome Temperature"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 103 GROUP BY time(:interval:) FILL(null)",influxql
Weather Tower Temperature - Dome Temperature,"SELECT 
  mean(""Exterior"") - mean(""Dome"") AS ""Temperature Difference""
FROM (
  SELECT mean(""temperatureItem0"") AS ""Exterior"" 
  FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" 
  WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 301 
  GROUP BY time(:interval:) FILL(previous)
), (
  SELECT mean(""temperatureItem0"") AS ""Dome"" 
  FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" 
  WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 113 
  GROUP BY time(:interval:) FILL(previous)
)
WHERE time > :dashboardTime: AND time < :upperDashboardTime: 
GROUP BY time(:interval:)
",influxql
Differential MTDome Temperature (<1C/hr),"SELECT difference(last(""temperatureItem0"")) FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 113 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(1h)",influxql
Differential M1M3 Air Cell Temperature (<0.75C/hr),"SELECT difference(last(""absoluteTemperature0"")), difference(last(""absoluteTemperature1"")), difference(last(""absoluteTemperature2"")), difference(last(""absoluteTemperature3"")) , difference(last(""absoluteTemperature4"")) , difference(last(""absoluteTemperature5"")) , difference(last(""absoluteTemperature6"")) , difference(last(""absoluteTemperature7"")) , difference(last(""absoluteTemperature8"")) , difference(last(""absoluteTemperature9"")) , difference(last(""absoluteTemperature10"")) , difference(last(""absoluteTemperature11"")) , difference(last(""absoluteTemperature12"")) , difference(last(""absoluteTemperature13"")) , difference(last(""absoluteTemperature14"")) , difference(last(""absoluteTemperature15"")) , difference(last(""absoluteTemperature16"")) , difference(last(""absoluteTemperature17"")) , difference(last(""absoluteTemperature18"")) , difference(last(""absoluteTemperature19"")) , difference(last(""absoluteTemperature20"")) , difference(last(""absoluteTemperature21"")) , difference(last(""absoluteTemperature22"")) , difference(last(""absoluteTemperature23"")) , difference(last(""absoluteTemperature24"")) , difference(last(""absoluteTemperature25"")) , difference(last(""absoluteTemperature26"")) , difference(last(""absoluteTemperature27"")) , difference(last(""absoluteTemperature28"")) , difference(last(""absoluteTemperature29"")) , difference(last(""absoluteTemperature30"")) , difference(last(""absoluteTemperature31"")) , difference(last(""absoluteTemperature32"")) , difference(last(""absoluteTemperature33"")) , difference(last(""absoluteTemperature34"")) , difference(last(""absoluteTemperature35"")) , difference(last(""absoluteTemperature36"")) , difference(last(""absoluteTemperature37"")) , difference(last(""absoluteTemperature38"")) , difference(last(""absoluteTemperature39"")) , difference(last(""absoluteTemperature40"")) , difference(last(""absoluteTemperature41"")) , difference(last(""absoluteTemperature42"")) , difference(last(""absoluteTemperature43"")) , difference(last(""absoluteTemperature44"")) , difference(last(""absoluteTemperature45"")) , difference(last(""absoluteTemperature46"")) , difference(last(""absoluteTemperature47"")) , difference(last(""absoluteTemperature48"")) , difference(last(""absoluteTemperature49"")) , difference(last(""absoluteTemperature50"")) , difference(last(""absoluteTemperature51"")) , difference(last(""absoluteTemperature52"")) , difference(last(""absoluteTemperature53"")) , difference(last(""absoluteTemperature54"")) , difference(last(""absoluteTemperature55"")) , difference(last(""absoluteTemperature56"")) , difference(last(""absoluteTemperature57"")) , difference(last(""absoluteTemperature58"")) , difference(last(""absoluteTemperature59"")) , difference(last(""absoluteTemperature60"")) , difference(last(""absoluteTemperature61"")) , difference(last(""absoluteTemperature62"")) , difference(last(""absoluteTemperature63"")) , difference(last(""absoluteTemperature64"")) , difference(last(""absoluteTemperature65"")) , difference(last(""absoluteTemperature66"")) , difference(last(""absoluteTemperature67"")) , difference(last(""absoluteTemperature68"")) , difference(last(""absoluteTemperature69"")) , difference(last(""absoluteTemperature70"")) , difference(last(""absoluteTemperature71"")) , difference(last(""absoluteTemperature72"")) , difference(last(""absoluteTemperature73"")) , difference(last(""absoluteTemperature74"")) , difference(last(""absoluteTemperature75"")) , difference(last(""absoluteTemperature76"")) , difference(last(""absoluteTemperature77"")) , difference(last(""absoluteTemperature78"")) , difference(last(""absoluteTemperature79"")) , difference(last(""absoluteTemperature80"")) , difference(last(""absoluteTemperature81"")) , difference(last(""absoluteTemperature82"")) , difference(last(""absoluteTemperature83"")) , difference(last(""absoluteTemperature84"")) , difference(last(""absoluteTemperature85"")) , difference(last(""absoluteTemperature86"")) , difference(last(""absoluteTemperature87"")) , difference(last(""absoluteTemperature88"")) , difference(last(""absoluteTemperature89"")) , difference(last(""absoluteTemperature90"")) , difference(last(""absoluteTemperature91"")), difference(last(""absoluteTemperature92"")) , difference(last(""absoluteTemperature93"")) , difference(last(""absoluteTemperature94"")) , difference(last(""absoluteTemperature95""))    FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.thermalData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(1h)",influxql
Untitled Graph,"SELECT max(/xForces/)  FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.appliedForces"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(20ms) ",influxql
Comatic modes,"SELECT ""aggregatedDoF35"" AS ""M2 B6"", ""aggregatedDoF36"" AS ""M2 B7"", ""aggregatedDoF48"" AS ""M2 B19"", ""aggregatedDoF49"" AS ""M2 B20"", ""aggregatedDoF15"" AS ""M1M3 B6"", ""aggregatedDoF16"" AS ""M1M3 B7"",""aggregatedDoF24"" AS ""M1M3 B15"", ""aggregatedDoF25"" AS ""M1M3 B16"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_degreeOfFreedom"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Spherical-like modes,"SELECT ""aggregatedDoF12"" AS ""M1M3 B3"", ""aggregatedDoF21"" AS ""M1M3 B12"", ""aggregatedDoF34"" AS ""M2 B5"", ""aggregatedDoF47"" AS ""M2 B18"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_degreeOfFreedom"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Trefoil-like modes,"SELECT ""aggregatedDoF13"" AS ""M1M3 B4"", ""aggregatedDoF14"" AS ""M1M3 B5"", ""aggregatedDoF32"" AS ""M2 B3"", ""aggregatedDoF33"" AS ""M2 B4"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_degreeOfFreedom"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Astigmatism-like modes,"SELECT ""aggregatedDoF10"" AS ""M1M3 B1"", ""aggregatedDoF11"" AS ""M1M3 B2"", ""aggregatedDoF30"" AS ""M2 B1"", ""aggregatedDoF31"" AS ""M2 B2"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_degreeOfFreedom"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Pistoning,"SELECT ""aggregatedDoF0"" AS ""M2 dZ"", ""aggregatedDoF5"" AS ""Camera dZ"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_degreeOfFreedom"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Decenterings,"SELECT ""aggregatedDoF1"" AS ""M2 dX"", ""aggregatedDoF2"" AS ""M2 dY"", ""aggregatedDoF6"" AS ""Camera dX"", ""aggregatedDoF7"" AS ""Camera dY"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_degreeOfFreedom"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Untitled Graph,"SELECT ""annularZernikeCoeff0"", ""annularZernikeCoeff1"", ""annularZernikeCoeff10"", ""annularZernikeCoeff12"", ""annularZernikeCoeff11"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_wavefrontError"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Tips and Tilts,"SELECT ""aggregatedDoF3"" AS ""M2 dRX"", ""aggregatedDoF4"" AS ""M2 dRY"", ""aggregatedDoF8"" AS ""Camera dRX"", ""aggregatedDoF9"" AS ""Camera dRY"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_degreeOfFreedom"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Quadrafoil modes,"SELECT ""aggregatedDoF17"" AS ""M1M3 B8"", ""aggregatedDoF18"" AS ""M1M3 B9"", ""aggregatedDoF37"" AS ""M2 B8"", ""aggregatedDoF38"" AS ""M2 B9"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_degreeOfFreedom"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Pentafoil modes,"SELECT ""aggregatedDoF24"" AS ""M1M3 B13"", ""aggregatedDoF25"" AS ""M1M3 B14"", ""aggregatedDoF41"" AS ""M2 B12"", ""aggregatedDoF42"" AS ""M2 B13"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_degreeOfFreedom"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Ubicacin,"SELECT ""latitude"", ""longitude"" FROM ""lsst.backpack"".""autogen"".""lsst.backpack.usgs_earthquake_data"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Profundidad,"SELECT ""depth"" FROM ""lsst.backpack"".""autogen"".""lsst.backpack.usgs_earthquake_data"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Intervalo,"SELECT ""timestamp"" FROM ""lsst.backpack"".""autogen"".""lsst.backpack.usgs_earthquake_data"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Magnitud,"SELECT ""magnitude"" FROM ""lsst.backpack"".""autogen"".""lsst.backpack.usgs_earthquake_data"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Azimuth,"SELECT ""azimuthCalculatedAngle0"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.mount_AzEl_Encoders"" WHERE time > :dashboardTime: ",influxql
Azimuth,"SELECT ""azimuth"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.command_trackTarget"" WHERE time > :dashboardTime:",influxql
Elevation,"SELECT ""elevationCalculatedAngle0"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.mount_AzEl_Encoders"" WHERE time > :dashboardTime: ",influxql
Elevation,"SELECT ""elevation"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.command_trackTarget"" WHERE time > :dashboardTime:",influxql
Nasmyth2 target,"SELECT ""nasmyth2CalculatedAngle0"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.mount_Nasmyth_Encoders"" WHERE time > :dashboardTime:",influxql
Nasmyth2 target,"SELECT ""nasmyth2RotatorAngle"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.command_trackTarget"" WHERE time > :dashboardTime: ",influxql
Nasmyth2 Rotator Angle,"SELECT ""nasmyth2CalculatedAngle99"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.mount_Nasmyth_Encoders"" ORDER BY time DESC LIMIT 1",influxql
Nasmyth1 Rotator Angle,"SELECT ""nasmyth1CalculatedAngle99"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.mount_Nasmyth_Encoders"" ORDER BY time DESC LIMIT 1",influxql
Mount Status,"SELECT ""inPosition"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.logevent_allAxesInPosition"" ORDER BY time DESC LIMIT 1",influxql
Nasmyth2 Rotator Angle Velocity,"SELECT ""nasmyth2RotatorAngleVelocity"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.logevent_target"" ORDER BY time DESC LIMIT 1",influxql
Nasmyth1 Rotator Angle Velocity,"SELECT ""nasmyth1RotatorAngleVelocity"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.logevent_target"" ORDER BY time DESC LIMIT 1",influxql
Glycol Chiller 03,"SELECT ""setpointActivo"", ""temperaturaAguaImpulsionEvaporador"", ""temperaturaAguaRetornoEvaporador"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.chiller03P01"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Glycol Chiller 01,"SELECT ""setpointActivo"", ""temperaturaAguaImpulsionEvaporador"", ""temperaturaAguaRetornoEvaporador"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.chiller01P01"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Glycol Chiller 02,"SELECT ""setpointActivo"", ""temperaturaAguaImpulsionEvaporador"", ""temperaturaAguaRetornoEvaporador"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.chiller02P01"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dynalene Chillers Glycol Supply flowrate [LPM],"SELECT ""dynCH2supGPGLYflow"", ""dynCH1supCGLYflow"", ""dynCH02retGPGLYpres"", ""dynCH02retGPGLYtemp"", ""dynCH02supFS02"", ""dynCH02supGPGLYpres"", ""dynCH02supGPGLYtemp"", ""dynCH2GPGLYtpd"", ""dynCH1CGLYtpd"", ""dynCH01supCGLYtemp"", ""dynCH01supCGLYpres"", ""dynCH01retCGLYtemp"", ""dynCH01retCGLYpres"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dynalene Chiller 01 Tank Levels [%],"SELECT ""dynCH01LS01"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dynalene Chiller 2 Supply Temperature [C],"SELECT ""dynCH02supTS07"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dynalene Chiller 02 Supply flowrate [LPM],"SELECT ""dynCH02supFS02"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dynalene Chiller 2 Supply Pressure [PA],"SELECT last(""dynCH02supPS13"") AS ""last_dynCH02supPS13"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Dynalene Chiller 1 Supply Pressure [PA],"SELECT ""dynCH01supPS11"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dynalene Chiller 02 Tank Level [%],"SELECT ""dynCH02LS02"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dynalene Chiller 01 Supply Temperature [C],"SELECT mean(""dynCH01supTS05"") AS ""mean_dynCH01supTS05"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Dynalene Chiller 01 Supply flowrate [LPM],"SELECT ""dynTMAretTS02"", ""dynCH01supFS01"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
TMA Ambient Temp,"SELECT temperature0 FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 103 and time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
TMA Elevation,"SELECT ""actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
TMA Elevation Drive Currents,"SELECT ""current0"", ""current1"", ""current10"", ""current11"", ""current2"", ""current3"", ""current8"", ""current7"", ""current6"", ""current5"", ""current4"", ""current9"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevationDrives"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
logevent_forceActuatorForceWarning,"SELECT ""anyWarning"", ""anyPrimaryAxisMeasuredForceWarning"", ""anySecondaryAxisMeasuredForceWarning"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.logevent_forceActuatorForceWarning"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Preclipped forces,"SELECT mean(""fx"") AS ""mean_fx"", mean(""fy"") AS ""mean_fy"", mean(""fz"") AS ""mean_fz"", mean(""xForces1"") AS ""mean_xForces1"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.logevent_preclippedForces"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Fault on Forces Outside the Actuator Force Budget,"SELECT ""anyForceWarning"", ""anyWarning"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.logevent_forceSetpointWarning"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Applied-Measured-Preclipped FA 101 (0),"SELECT ""zForces0"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.logevent_preclippedForces"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: FILL(0)",influxql
Applied-Measured-Preclipped FA 101 (0),"SELECT ""zForces0"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.appliedForces"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Applied-Measured-Preclipped FA 101 (0),"SELECT ""primaryCylinderForce0"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.forceActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Logevent_forceActuatorBumpTestStatus,"SELECT ""actuatorId"", ""primaryTest1"", ""primaryTestTimestamps1"", ""secondaryTest1"", ""secondaryTestTimestamps1"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.logevent_forceActuatorBumpTestStatus"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Some warnings,"SELECT ""accelerationForceWarning0"", ""forceWarning0"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.logevent_forceSetpointWarning"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
M1M3 inclinometer,"SELECT median(""inclinometerAngle"") AS ""median_inclinometerAngle"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.inclinometerData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
TMA Torque,"SELECT ""actualTorque"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
M1M3 summary state,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.logevent_summaryState"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
STANDBY,"// STANDBY = 5

import ""strings"" 

from(bucket: ""efd/autogen"")
  |> range(start: dashboardTime)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.MT.*.logevent_summaryState/ and (r._field == ""summaryState""))
  |> last()
  |> map(fn: (r) => ({
    r with
    state_count:
      if r._value == 5 then 1 else 0
    })
  )
  |> group()
  |> sum(column: ""state_count"")
  |> map(fn: (r) => ({
    r with
    _time: 0
    })
  )
 
 

  
 ",flux
MT CSC State transitions,"// CSC state
// STANDBY = 5
// OFFLINE = 4
// FAULT = 3
// ENABLED = 2
// DISABLED = 1

import ""strings""

from(bucket: ""efd/autogen"")
  |> range(start: dashboardTime)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.MT.*.logevent_summaryState/ and (r._field == ""summaryState""))
  |> map(fn: (r) => ({
    r with
    csc: strings.split(v: r._measurement, t: ""."")[2],
    state: r._value
  }))
  |> group(columns: [""csc""])
  |> keep(columns: [""_time"", ""csc"", ""state""])
 
",flux
ENABLED,"// ENABLED = 2 

import ""strings"" 

from(bucket: ""efd/autogen"")
  |> range(start: dashboardTime)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.MT.*.logevent_summaryState/ and (r._field == ""summaryState""))
  |> last()
  |> map(fn: (r) => ({
    r with
    state_count:
      if r._value == 2 then 1 else 0
    })
  )
  |> group()
  |> sum(column: ""state_count"")
  |> map(fn: (r) => ({
    r with
    _time: 0
    })
  )
 
 

  
 ",flux
FAULT,"// FAULT = 3 

import ""strings"" 

from(bucket: ""efd/autogen"")
  |> range(start: dashboardTime)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.MT.*.logevent_summaryState/ and (r._field == ""summaryState""))
  |> last()
  |> map(fn: (r) => ({
    r with
    state_count:
      if r._value == 3 then 1 else 0
    })
  )
  |> group()
  |> sum(column: ""state_count"")
  |> map(fn: (r) => ({
    r with
    _time: 0
    })
  )
 
 

  
 ",flux
MT CSCs,"import ""strings"" 

from(bucket: ""efd/autogen"")
  |> range(start: dashboardTime)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.MT.*.logevent_summaryState/ and (r._field == ""summaryState""))
  |> last()
  |> group()
  |> count()
  |> map(fn: (r) => ({
    r with
    _time: 0
    })
  )
 
  
 ",flux
MT CSCs Current State,"// CSC states
// STANDBY = 5
// OFFLINE = 4
// FAULT = 3
// ENABLED = 2
// DISABLED = 1

import ""strings""

from(bucket: ""efd/autogen"")
  |> range(start: dashboardTime)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.MT.*.logevent_summaryState/ and (r._field == ""summaryState""))
  |> last()
  |> map(fn: (r) => ({
    r with
    csc: strings.split(v: r._measurement, t: ""."")[2],
    state:
      if r._value == 5 then ""5 (STANDBY)""
      else if r._value == 4 then ""4 (OFFLINE)""
      else if r._value == 3 then ""3 (FAULT)""
      else if r._value == 2 then ""2 (ENABLED)""
      else if r._value == 1 then ""1 (DISABLED)""
      else ""UNKNOWN"",
    duration: strings.splitAfter(v: string(v: duration(v: uint(v: r._stop) - uint(v: r._time))), t: ""m"")[0]

    })
  )
  |> keep(columns: [""csc"", ""state"", ""_time"", ""duration""])
 
",flux
Hard Point 1,"SELECT mean(""measuredForce0"") AS ""mean_measuredForce0"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(100ms) FILL(null)",influxql
Hard Point 2,"SELECT mean(""measuredForce1"") AS ""mean_measuredForce1"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(100ms) FILL(null)",influxql
Hard Point 3,"SELECT mean(""measuredForce2"") AS ""mean_measuredForce2"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(100ms) FILL(null)",influxql
Hard Point 4,"SELECT mean(""measuredForce3"") AS ""mean_measuredForce3"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(100ms) FILL(null)",influxql
Hard Point 5,"SELECT mean(""measuredForce4"") AS ""mean_measuredForce4"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(100ms) FILL(null)",influxql
Hard Point 6,"SELECT mean(""measuredForce5"") AS ""mean_measuredForce5"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(100ms) FILL(null)",influxql
Config,"SELECT ""drivesEnabled"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_configuration"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Move Command,"SELECT ""private_sndStamp"", ""position"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.command_move"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Stop Command,"SELECT ""private_sndStamp"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.command_stop"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
enabledSubstate,"SELECT ""enabledSubstate"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_controllerState"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Command stop,"SELECT ""private_efdStamp"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.command_stop"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Bus Voltage,"SELECT ""busVoltage"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.motors"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Rotator Currents,"SELECT ""current0"", ""current1"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.motors"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Rotator Torque Values,"SELECT torque0, torque1 FROM ""efd"".""autogen"".""lsst.sal.MTRotator.motors"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
Rotator Logevent,"SELECT ""level"", ""message"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_logMessage"" ORDER BY DESC LIMIT 100",influxql
Fault_command,"SELECT ""private_sndStamp"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.command_fault"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Following Error Rotator-CCW,"SELECT ""positionError"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.ccwFollowingError"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
CCW followingErrorThreshold,"SELECT ""followingErrorThreshold"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_configuration"" ORDER BY DESC LIMIT 1",influxql
Rot Motors calibrated motor position [deg],"SELECT ""calibrated1"", ""calibrated0"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.motors"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Rotator Velocity,"SELECT ""actualVelocity"", ""demandVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.rotation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Error Code,"SELECT ""errorCode"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_errorCode"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Controller State,"SELECT ""controllerState"", ""faultSubstate"", ""enabledSubstate"", ""applicationStatus"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_controllerState"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: ORDER BY DESC LIMIT 10",influxql
Commandable by DDS,"SELECT ""state"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_commandableByDDS"" ORDER BY DESC LIMIT 3",influxql
In Position,"SELECT ""inPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_inPosition"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Summary State,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
Position,"SELECT ""actualPosition"", ""demandPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.rotation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Logevent_target: position,"SELECT ""position"", ""velocity"", ""private_sndStamp"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_target"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: ORDER BY DESC LIMIT 5",influxql
Last Error Code,"SELECT ""errorCode"", ""errorReport"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_errorCode"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Rotator Currents,"SELECT /current/ FROM ""efd"".""autogen"".""lsst.sal.MTRotator.motors"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Difference between actual and demanded velocity,"SELECT ""demandVelocity""-""actualVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.rotation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Difference between demanded and actual position (arcsec),"SELECT (""actualPosition""-""demandPosition"") * 3600 FROM ""efd"".""autogen"".""lsst.sal.MTRotator.rotation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Electrical,"SELECT ""copleyFaultStatus0"", ""copleyFaultStatus1"", ""copleyLatchingFaultStatus0"", ""copleyLatchingFaultStatus1"", ""copleyStatusWordDrive0"", ""copleyStatusWordDrive1"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.electrical"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Temperature,"SELECT ""temperatureItem6"" as ""Motor 1"", ""temperatureItem7"" as ""Motor 2"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 1 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Available Blocks,"SELECT ""ids""FROM ""efd"".""autogen"".""lsst.sal.Scheduler.logevent_blockInventory"" ORDER BY ""time"" DESC",influxql
Laser Tracker Status,"data = from(bucket: ""efd/autogen"")
  |> range(start: dashboardTime) // This sets the start time to the time set in the UI
  |> filter(fn: (r) => r._measurement == ""lsst.sal.LaserTracker.logevent_laserStatus"")
  |> filter(fn: (r) => r._field == ""status"")

mapStatus = (status) => 
  if status == 1 then ""NOT_CONNECTED"" 
  else if status == 2 then ""OFF""
  else if status == 3 then ""WARMING""
  else if status == 4 then ""ON""
  else ""UNKNOWN""

data
  |> map(fn: (r) => ({ r with status_string: mapStatus(status: r._value), status: r._value }))
  |> keep(columns: [""_time"", ""status"", ""status_string""])",flux
Explore,"SELECT ""salIndex"", ""message"", ""traceback"", ""filePath"" FROM ""efd"".""autogen"".""lsst.sal.Script.logevent_logMessage"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MT  power supply voltage,"SELECT mean(""powerSupplyVoltage"") AS ""mean_powerSupplyVoltage"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.mainPowerSupply"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Azimuth actual,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
az torque,"SELECT mean(""actualTorque"") AS ""mean_actualTorque"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
az velocity,"SELECT mean(""actualVelocity"") AS ""mean_actualVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Elevation pos,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
el torque,"SELECT mean(""actualTorque"") AS ""mean_actualTorque"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
el velocity,"SELECT mean(""actualVelocity"") AS ""mean_actualVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Speed (clone 1),"SELECT ""speed"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: and salIndex=301",influxql
Wind Direction (clone 1),"SELECT ""direction"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: and salIndex=301",influxql
Wind Direction,"SELECT ""direction"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: and salIndex=301",influxql
Speed,"SELECT ""speed"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: and salIndex=301",influxql
Pointing Offsets,"SELECT ""disperser0"", ""disperser1"", ""filter0"", ""filter1"", ""total0"", ""total1"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_pointingOffsetSummary"" ORDER BY DESC LIMIT 10",influxql
Focus Offset Summary,"SELECT ""filter"", ""disperser"", ""userApplied"", ""total"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_focusOffsetSummary""  ORDER BY DESC LIMIT 10",influxql
Enabled Corrections,"SELECT ""atspectrograph"", ""hexapod"", ""m1"", ""moveWhileExposing"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_correctionEnabled"" ORDER BY DESC LIMIT 10",influxql
Hexapod - Z,"SELECT ""hexapod_z"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_hexapodCorrectionCompleted"" WHERE time > :dashboardTime:",influxql
Hexapod - Z,"SELECT ""reportedPosition2"" FROM ""efd"".""autogen"".""lsst.sal.ATHexapod.positionStatus"" WHERE time > :dashboardTime:",influxql
Hexapod - Y,"SELECT ""hexapod_y"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_hexapodCorrectionCompleted"" WHERE time > :dashboardTime:",influxql
Hexapod - Y,"SELECT ""reportedPosition1"" FROM ""efd"".""autogen"".""lsst.sal.ATHexapod.positionStatus"" WHERE time > :dashboardTime:",influxql
Hexapod - X,"SELECT ""hexapod_x"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_hexapodCorrectionCompleted""  WHERE time > :dashboardTime:",influxql
Hexapod - X,"SELECT ""reportedPosition0"" FROM ""efd"".""autogen"".""lsst.sal.ATHexapod.positionStatus"" WHERE time > :dashboardTime:",influxql
HexX,"SELECT ""positionX"" FROM ""efd"".""autogen"".""lsst.sal.ATHexapod.logevent_positionUpdate"" ORDER BY DESC LIMIT 1",influxql
HexY,"SELECT ""positionY"" FROM ""efd"".""autogen"".""lsst.sal.ATHexapod.logevent_positionUpdate"" ORDER BY DESC LIMIT 1",influxql
HexZ,"SELECT ""positionZ"" FROM ""efd"".""autogen"".""lsst.sal.ATHexapod.logevent_positionUpdate"" ORDER BY DESC LIMIT 1",influxql
MTOODS,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTOODS.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
MTHeaderService,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTHeaderService.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
MTCamera,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTCamera.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
Rotator Status,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.Rotator.logevent_summaryState"" WHERE time >= :test_start: AND time <= :test_end:",influxql
CCW Status,"SELECT ""CCW_Status"" AS ""CCW_Status"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.Camera_Cable_Wrap"" WHERE time >= :test_start: AND time <= :test_end:",influxql
CCW Rotator Position(CCW),"SELECT mean(""CCW_Angle_1""), mean(""CCW_Angle_2"") FROM ""efd"".""autogen"".""lsst.sal.MTMount.Camera_Cable_Wrap"" WHERE time >= ':test_start:' AND time <= ':test_end:' GROUP BY time(1s)",influxql
Rotator Position and Demand,"SELECT mean(""Demand""), mean(""Position"") FROM ""efd"".""autogen"".""lsst.sal.Rotator.Application"" WHERE time >= ':test_start:' AND time <= ':test_end:' GROUP BY time(1s)",influxql
Pointing Model,"SELECT mean(""angle"") FROM ""efd"".""autogen"".""lsst.sal.Rotator.command_track"" WHERE time >= ':test_start:' AND time <= ':test_end:' GROUP BY time(1s)",influxql
TEST END,"SELECT ""message"" FROM ""efd"".""autogen"".""lsst.sal.Script.logevent_logMessage"" WHERE message =~ /END/ order by desc",influxql
TEST START,"SELECT ""message"" FROM ""efd"".""autogen"".""lsst.sal.Script.logevent_logMessage"" WHERE message =~ /START/ order by desc",influxql
STANDBY,"// STABDBY = 5 

import ""strings"" 

from(bucket: ""efd/autogen"")
  |> range(start: -inf)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.DIMM.*.logevent_summaryState/ and (r._field == ""summaryState""))
  |> last()
  |> map(fn: (r) => ({
    r with
    state_count:
      if r._value == 5 then 1 else 0
    })
  )
  |> group()
  |> sum(column: ""state_count"")
 

  
 ",flux
DIMM Transitions,"

// CSC state
// STANDBY = 5
// OFFLINE = 4
// FAULT = 3
// ENABLED = 2
// DISABLED = 1

import ""strings""

from(bucket: ""efd/autogen"")
  |> range(start: dashboardTime)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.DIMM.*.logevent_summaryState/ and (r._field == ""summaryState""))
  |> map(fn: (r) => ({
    r with
    csc: strings.split(v: r._measurement, t: ""."")[2],
    state: r._value,
    state_name:
      if r._value == 5 then ""5 (STANDBY)""
      else if r._value == 4 then ""4 (OFFLINE)""
      else if r._value == 3 then ""3 (FAULT)""
      else if r._value == 2 then ""2 (ENABLED)""
      else if r._value == 1 then ""1 (DISABLED)""
      else ""UNKNOWN"",
  }))
  |> group(columns: [""csc""])
  |> keep(columns: [""_time"", ""csc"", ""state"", ""state_name""])
 
",flux
ENABLED,"// ENABLED = 2 

import ""strings"" 

from(bucket: ""efd/autogen"")
  |> range(start: -inf)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.DIMM.*.logevent_summaryState/ and (r._field == ""summaryState""))
  |> last()
  |> map(fn: (r) => ({
    r with
    state_count:
      if r._value == 2 then 1 else 0
    })
  )
  |> group()
  |> sum(column: ""state_count"")
 

  
 ",flux
FAULT,"// FAULT = 3 

import ""strings"" 

from(bucket: ""efd/autogen"")
  |> range(start: -inf)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.DIMM.*.logevent_summaryState/ and (r._field == ""summaryState""))
  |> last()
  |> map(fn: (r) => ({
    r with
    state_count:
      if r._value == 3 then 1 else 0
    })
  )
  |> group()
  |> sum(column: ""state_count"")
 

  
 ",flux
Devices,"import ""strings"" 

from(bucket: ""efd/autogen"")
  |> range(start: -inf)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.DIMM.*.logevent_summaryState/ and (r._field == ""summaryState""))
  |> last()
  |> group()
  |> count()
  
 ",flux
DIMM Current State,"// CSC states
// STANDBY = 5
// OFFLINE = 4
// FAULT = 3
// ENABLED = 2
// DISABLED = 1

import ""strings""

from(bucket: ""efd/autogen"")
  |> range(start: -inf)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.DIMM.*.logevent_summaryState/ and (r._field == ""summaryState""))
  |> last()
  |> map(fn: (r) => ({
    r with
    csc: strings.split(v: r._measurement, t: ""."")[2],
    state:
      if r._value == 5 then ""5 (STANDBY)""
      else if r._value == 4 then ""4 (OFFLINE)""
      else if r._value == 3 then ""3 (FAULT)""
      else if r._value == 2 then ""2 (ENABLED)""
      else if r._value == 1 then ""1 (DISABLED)""
      else ""UNKNOWN"",
    duration: strings.splitAfter(v: string(v: duration(v: uint(v: r._stop) - uint(v: r._time))), t: ""m"")[0]
   })
  )

  |> keep(columns: [""csc"", ""state"", ""_time"", ""duration""])
 
",flux
Hardpoint magnitude,"SELECT ""forceMagnitude"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Y,"SELECT 178900*cos(0.017453292519943295*""actualPosition"") as ""Mount Estimate"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Y,"SELECT ""fy"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.forceActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Y,"SELECT 178900*cos(0.017453292519943295*""inclinometerAngle"") as ""M1M3 Estimate"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.inclinometerData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Z,"SELECT 178900*sin(0.017453292519943295*""actualPosition"") as ""Mount Estimate"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Z,"SELECT ""fz"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.forceActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Z,"SELECT 178900*sin(0.017453292519943295*""inclinometerAngle"") as ""M1M3 Estimate"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.inclinometerData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
FA X- measured forces,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /secondaryCylinderForce(8|22|28|91|103|109)$/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
FA X+ measured forces,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /secondaryCylinderForce(35|47|53|64|78|84)$/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
FA X- following error,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /secondaryCylinderFollowingError(8|22|28|91|103|109)$/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
FA X+ following error,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /secondaryCylinderFollowingError(35|47|53|64|78|84)$/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
FA Z moment,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /mz/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
FA Y moment,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /my/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
FA Y force,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /fy/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
FA Z force,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /fz/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
FA X moment,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /mx/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
HP Y moment,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /my/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
HP Z moment,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /mz/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
FA X force,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /fx/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
HP Y force,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /fy/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
HP Z force,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /fz/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
HP X moment,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /mx/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
HP X force,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /fx/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Elevation Velocity,"SELECT mean(""actualVelocity"") AS ""mean_actualVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Azimuth Velocity,"SELECT mean(""actualVelocity"") AS ""mean_actualVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Azimuth Position,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Current,"SELECT mean(""powerSupplyCurrent"") AS ""mean_powerSupplyCurrent"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.mainPowerSupply"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Voltage,"SELECT mean(""powerSupplyVoltage"") AS ""mean_powerSupplyVoltage"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.mainPowerSupply"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Elevation Position,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Weather Tower Temperature,"SELECT mean(""temperatureItem0"") AS ""mean_temperatureItem0"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 301 GROUP BY time(:interval:) FILL(null)",influxql
Dome vs tower temperature,"SELECT mean(""temperatureItem0"") AS ""tdome"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 103 GROUP BY time(:interval:) FILL(null)",influxql
Dome vs tower temperature,"SELECT mean(""temperatureItem0"") as ""ttower""  FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 301 GROUP BY time(:interval:) FILL(null)",influxql
CCW Position and velocity,"SELECT ""actualPosition"", ""actualVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.cameraCableWrap"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Rotator Position and velocity,"SELECT ""actualPosition"", ""actualVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.rotation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
CCW Following Erorr,"SELECT ""positionError"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.ccwFollowingError"" WHERE time > :dashboardTime:",influxql
Motor Current,"SELECT mean(""motorCurrent"") AS ""mean_motorCurrent"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.powerStatus"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Temperature,"SELECT ""temperatureItem1"" as ""A1"", ""temperatureItem2"" as ""A2"", ""temperatureItem3"" as ""A3"", ""temperatureItem4"" as ""A4"", ""temperatureItem5"" as ""A5"", ""temperatureItem6"" as ""A6"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 106",influxql
Temperature,"SELECT ""temperatureItem0"" as ""ambient"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 103",influxql
Untitled Graph,"SELECT ""measured0"",""measured1"",""measured2"",""measured3"",""measured4"",""measured5"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.tangentForce"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
Untitled Graph,"SELECT mean(""inclinometerProcessed"") AS ""mean_inclinometerProcessed"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.zenithAngle"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(100s)",influxql
REB Total Power,"SELECT ""rebTotalPower"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.focal_plane_RebTotalPower"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
HV Bias Switch,"SELECT ""hVBiasSwitch0"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.focal_plane_Reb"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Standard Currents,"SELECT mean(""anaI0"") AS ""mean_anaI"", mean(""clkHI0"") AS ""mean_clkHI"", mean(""digI0"") AS ""mean_digI"", mean(""odI0"") AS ""mean_odI"", mean(""oDI0"") AS ""mean_oDI"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.focal_plane_Reb"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Special Voltages,"SELECT mean(""pClkL0"") AS ""mean_pClkL"", mean(""pClkU0"") AS ""mean_pClkU"", mean(""rGL0"") AS ""mean_rGL"", mean(""rGU0"") AS ""mean_rGU"", mean(""sClkL0"") AS ""mean_sClkL"", mean(""sClkU0"") AS ""mean_sClkU"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.focal_plane_Reb"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Standard Voltages,"SELECT mean(""anaV0"") AS ""mean_anaV"", mean(""clkHV0"") AS ""mean_clkHV"", mean(""clkLV0"") AS ""mean_clkLV"", mean(""digV0"") AS ""mean_digV"", mean(""htrPS_V0"") AS ""mean_htrPS_V"", mean(""odPS_V0"") AS ""mean_odPS_V"", mean(""rgL_V0"") AS ""mean_rgL_V"", mean(""rgV0"") AS ""mean_rgV"", mean(""sckL_V0"") AS ""mean_sckL_V"", mean(""sckU_V0"") AS ""mean_sckU_V"", mean(""htrV0"") AS ""mean_htrV"", mean(""oDV0"") AS ""mean_oDV"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.focal_plane_Reb"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Powers,"SELECT mean(""power0"") AS ""mean_power"", mean(""htrW0"") AS ""mean_htrW"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.focal_plane_Reb"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
MTHexapod Stress Test,"SELECT ""position0"", ""position1"", ""position2"", ""position3"", ""position4"", ""position5"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Untitled Graph,"SELECT (""total0"") AS ""mean_total0"", (""total1"") AS ""mean_total1"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_pointingOffsetSummary"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
Untitled Graph,"SELECT mean(""total"") AS ""mean_total"", mean(""userApplied"") AS ""mean_userApplied"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_focusOffsetSummary"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 Z Position (rolling average),"SELECT mean(""zPosition"") AS ""mean_zPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.imsData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 HardPoints (rolling average),"SELECT ""measuredForce0"", ""measuredForce1"", ""measuredForce2"", ""measuredForce3"", ""measuredForce4"", ""measuredForce5"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
TMA Elevation Angle (rolling average),"SELECT mean(""actualPosition"") AS ""mean_actualPosition"", mean(""demandPosition"") AS ""mean_demandPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
TMA Elevation Drives (rolling average),"SELECT ""actualTorque"", ""actualVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Mount azimuth velocity,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.azimuth"")
  |> filter(fn: (r) => r[""_field""] =~ /(actual|demand)Velocity/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Mount elevation,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevation"")
  |> filter(fn: (r) => r[""_field""] =~ /(actual|demand)Position/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Z DC acceleration,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] == ""angularAccelerationZ"")


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Y DC acceleration,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] == ""angularAccelerationY"")


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
X DC acceleration,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] == ""angularAccelerationX"")


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Mount elevation velocity,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevation"")
  |> filter(fn: (r) => r[""_field""] =~ /(actual|demand)Velocity/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Z angular velocity,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.gyroData"")
  |> filter(fn: (r) => r[""_field""] == ""angularVelocityZ"")


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Y angular velocity,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.gyroData"")
  |> filter(fn: (r) => r[""_field""] == ""angularVelocityY"")


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
X angular velocity,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.gyroData"")
  |> filter(fn: (r) => r[""_field""] == ""angularVelocityX"")


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Glycol temperatures,"SELECT ""telescopeCoolantReturnTemperature"", ""telescopeCoolantSupplyTemperature"", ""mirrorCoolantSupplyTemperature"", ""mirrorCoolantReturnTemperature"", ""insideCellTemperature3"", ""insideCellTemperature2"", ""insideCellTemperature1"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.glycolLoopTemperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Glycol pump,"SELECT ""outputCurrent"", ""outputFrequency"", ""outputVoltage"", ""busVoltage"", ""commandedFrequency"", ""targetFrequency"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.glycolPump"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Mixing Valve,"SELECT ""valvePosition"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.mixingValve"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Flow meter,"SELECT ""flowRate"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.flowMeter"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
VMS cRIO chassis temperature,"SELECT ""chassisTemperature"" FROM ""efd"".""autogen"".""lsst.sal.MTVMS.miscellaneous"" WHERE salIndex = 1 and time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Rotator Status,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.Rotator.logevent_summaryState"" WHERE time >= :test_start: AND time <= :test_end:",influxql
CCW Status,"SELECT ""CCW_Status"" AS ""CCW_Status"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.Camera_Cable_Wrap"" WHERE time >= :test_start: AND time <= :test_end:",influxql
CCW Rotator Position(CCW),"SELECT mean(""CCW_Angle_1""), mean(""CCW_Angle_2"") FROM ""efd"".""autogen"".""lsst.sal.MTMount.Camera_Cable_Wrap"" WHERE time >= ':test_start:' AND time <= ':test_end:' GROUP BY time(1s)",influxql
Rotator Position and Demand,"SELECT mean(""Demand""), mean(""Position"") FROM ""efd"".""autogen"".""lsst.sal.Rotator.Application"" WHERE time >= ':test_start:' AND time <= ':test_end:' GROUP BY time(1s)",influxql
Pointing Model,"SELECT mean(""angle"") FROM ""efd"".""autogen"".""lsst.sal.Rotator.command_track"" WHERE time >= ':test_start:' AND time <= ':test_end:' GROUP BY time(1s)",influxql
BalancedForces,"SELECT mean(""xForces0"") AS ""mean_xForces0"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.appliedBalanceForces"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Rotator Status,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.Rotator.logevent_summaryState"" WHERE time >= :test_start: AND time <= :test_end:",influxql
CCW Status,"SELECT ""CCW_Status"" AS ""CCW_Status"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.Camera_Cable_Wrap"" WHERE time >= :test_start: AND time <= :test_end:",influxql
CCW Rotator Position(CCW),"SELECT mean(""CCW_Angle_1""), mean(""CCW_Angle_2"") FROM ""efd"".""autogen"".""lsst.sal.MTMount.Camera_Cable_Wrap"" WHERE time >= :test_start: AND time <= :test_end: GROUP BY time(1s)",influxql
Rotator Position and Demand,"SELECT mean(""Demand""), mean(""Position"") FROM ""efd"".""autogen"".""lsst.sal.Rotator.Application"" WHERE time >= :test_start: AND time <= :test_end: GROUP BY time(1s)",influxql
Pointing Model,"SELECT mean(""angle"") FROM ""efd"".""autogen"".""lsst.sal.Rotator.command_track"" WHERE time >= :test_start: AND time <= :test_end: GROUP BY time(1s)",influxql
TEST END,"SELECT ""message"" FROM ""efd"".""autogen"".""lsst.sal.Script.logevent_logMessage"" WHERE message =~ /END/ order by desc",influxql
TEST START,"SELECT ""message"" FROM ""efd"".""autogen"".""lsst.sal.Script.logevent_logMessage"" WHERE message =~ /START/ order by desc",influxql
Offline State,"SELECT ""substate"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.logevent_offlineDetailedState"" ORDER BY DESC LIMIT 1",influxql
Image Readiness,"SELECT ""substate"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.logevent_imageReadinessDetailedState"" ORDER BY DESC LIMIT 1",influxql
Rafts,"SELECT ""substate"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.logevent_raftsDetailedState"" ORDER BY DESC LIMIT 1",influxql
Calibration,"SELECT ""substate"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.logevent_calibrationDetailedState"" ORDER BY DESC LIMIT 1",influxql
Shutter,"SELECT ""substate"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.logevent_shutterDetailedState"" ORDER BY DESC LIMIT 1",influxql
Ready To Take Images,"SELECT ""substate"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.logevent_ccsCommandState"" ORDER BY DESC LIMIT 1",influxql
AuxTel Devices,"import ""strings"" 

from(bucket: ""efd/autogen"")
  |> range(start: dashboardTime)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.AT.*.logevent_heartbeat/ and (r._field == ""heartbeat""))
  |> last()
  |> group()
  |> count()
  
 ",flux
Heartbeat counts,"import ""strings""

from(bucket: ""efd/autogen"")
  |> range(start: dashboardTime)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.AT.*.logevent_heartbeat/ and r._field == ""heartbeat"")
  |> aggregateWindow(every: autoInterval, fn: count)
  |> map(fn: (r) => ({
    r with
    csc: strings.split(v: r._measurement, t: ""."")[2],
    })
  )
  |> group(columns: [""csc""])
  |> keep(columns: [""_time"", ""csc"", ""_value""])
 
",flux
AuxTel status and downtime,"import ""strings"" 

from(bucket: ""efd/autogen"")
  |> range(start: dashboardTime)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.AT.*.logevent_heartbeat/ and (r._field == ""heartbeat""))
  |> aggregateWindow(every: 1m, fn: count)
  |> stateCount(fn: (r) => r._value == 0, 
  	column: ""downtime""
   )
  |> last()
  |> map(fn: (r) => ({
    r with
    csc: strings.split(v: r._measurement, t: ""."")[2],
    status: if r._value > 1 then ""Up"" else ""Down"",
    downtime: r.downtime + 1
  }))
  |> keep(columns:[""csc"", ""status"", ""downtime""])

 
 ",flux
IMS xyz Rotation,"SELECT ""xRotation"", ""yRotation"", ""zRotation"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.imsData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
IMS xyz Position,"SELECT ""xPosition"", ""yPosition"", ""zPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.imsData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
xyz Rotation,"SELECT ""xRotation"", ""yRotation"", ""zRotation"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
xyz Position,"SELECT ""xPosition"", ""yPosition"", ""zPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Wind Speed - Average 2min,"SELECT ""value"" FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.windSpeed"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Wind Speed - Average 2min,"SELECT ""min2M"" FROM ""efd"".""autogen"".""lsst.sal.Environment.windSpeed"" WHERE time > :dashboardTime:",influxql
Min Temperature,"SELECT ""min24H"" FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.airTemperature"" WHERE ""salIndex"" = 1 ORDER BY time DESC LIMIT 1",influxql
Seeing,"SELECT mean(""fwhm"") AS ""mean_fwhm"" FROM ""efd"".""autogen"".""lsst.sal.DIMM.logevent_dimmMeasurement"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(previous)",influxql
DIMM Seeing,"SELECT ""fwhm"" FROM ""efd"".""autogen"".""lsst.sal.DIMM.logevent_dimmMeasurement"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Wind Direction Average 10min,"SELECT mean(""avg10M"") AS ""mean_avg10M"" FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.windDirection"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Wind Direction Average 10min,"SELECT mean(""avg10M"") AS ""mean_avg10M"" FROM ""efd"".""autogen"".""lsst.sal.Environment.windDirection"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Dewpoint,"SELECT ""avg1M""+1.4 FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.dewPoint"" WHERE ""salIndex"" = 1 ORDER BY time DESC LIMIT 1",influxql
Relative Humidity,"SELECT ""avg1M""/0.90 FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.relativeHumidity"" WHERE time > :dashboardTime:",influxql
Wind Direction (avg2M),"SELECT ""avg2M"" FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.windDirection"" WHERE ""salIndex"" =1 ORDER BY time DESC LIMIT 1",influxql
Wind Speed (avg2M),"SELECT ""avg2M"" FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.windSpeed"" WHERE ""salIndex"" = 1 ORDER BY time DESC LIMIT 1",influxql
Pressure,"SELECT mean(""paAvg1M"") AS ""mean_paAvg1M"" FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.airPressure"" WHERE time > :dashboardTime:  GROUP BY time(:interval:) FILL(null)",influxql
Pressure,"SELECT mean(""paAvg1M"") AS ""mean_paAvg1M"" FROM ""efd"".""autogen"".""lsst.sal.Environment.airPressure"" WHERE time > :dashboardTime:  GROUP BY time(:interval:) FILL(null)",influxql
Humidity,"SELECT ""humidity""/0.90 FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.weather"" WHERE ""salIndex"" = 1 ORDER BY time DESC LIMIT 1",influxql
Max Temperature,"SELECT ""max24H"" FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.airTemperature"" WHERE ""salIndex"" = 1 ORDER BY time DESC LIMIT 1",influxql
Average Temperatures,"SELECT ""avg1M"" FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.airTemperature"" WHERE time > :dashboardTime:",influxql
Average Temperatures,"SELECT ""avg1M""+1.4 FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.dewPoint"" WHERE time > :dashboardTime: ",influxql
Calibrated,"SELECT mean(""calibrated0"") AS ""mean_calibrated0"", mean(""calibrated1"") AS ""mean_calibrated1"", mean(""calibrated3"") AS ""mean_calibrated3"", mean(""calibrated4"") AS ""mean_calibrated4"", mean(""calibrated2"") AS ""mean_calibrated2"", mean(""calibrated5"") AS ""mean_calibrated5"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.actuators"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Raw,"SELECT mean(""raw0"") AS ""mean_raw0"", mean(""raw1"") AS ""mean_raw1"", mean(""raw2"") AS ""mean_raw2"", mean(""raw3"") AS ""mean_raw3"", mean(""raw4"") AS ""mean_raw4"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.actuators"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
TMA elevation actual,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
TMA azimuth actual,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
FA total forces and moments,"SELECT mean(""fx"") AS ""mean_fx"", mean(""fy"") AS ""mean_fy"", mean(""fz"") AS ""mean_fz"", mean(""mx"") AS ""mean_mx"", mean(""my"") AS ""mean_my"", mean(""mz"") AS ""mean_mz"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.forceActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
HP encoders,"SELECT mean(""encoder0"") AS ""mean_encoder0"", mean(""encoder1"") AS ""mean_encoder1"", mean(""encoder2"") AS ""mean_encoder2"", mean(""encoder3"") AS ""mean_encoder3"", mean(""encoder4"") AS ""mean_encoder4"", mean(""encoder5"") AS ""mean_encoder5"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
HP forces,"SELECT mean(""measuredForce0"") AS ""mean_measuredForce0"", mean(""measuredForce1"") AS ""mean_measuredForce1"", mean(""measuredForce2"") AS ""mean_measuredForce2"", mean(""measuredForce3"") AS ""mean_measuredForce3"", mean(""measuredForce4"") AS ""mean_measuredForce4"", mean(""measuredForce5"") AS ""mean_measuredForce5"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
HP position (pos rot),"SELECT mean(""xPosition"") AS ""mean_xPosition"", mean(""xRotation"") AS ""mean_xRotation"", mean(""yPosition"") AS ""mean_yPosition"", mean(""yRotation"") AS ""mean_yRotation"", mean(""zPosition"") AS ""mean_zPosition"", mean(""zRotation"") AS ""mean_zRotation"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
IMS (pos rot),"SELECT mean(""xPosition"") AS ""mean_xPosition"", mean(""xRotation"") AS ""mean_xRotation"", mean(""yPosition"") AS ""mean_yPosition"", mean(""yRotation"") AS ""mean_yRotation"", mean(""zPosition"") AS ""mean_zPosition"", mean(""zRotation"") AS ""mean_zRotation"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.imsData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Header sequence,"SELECT ""url"" FROM ""efd"".""autogen"".""lsst.sal.GCHeaderService.logevent_largeFileObjectAvailable"" WHERE salIndex = :salindex: AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Settings,"SELECT ""cscVersion"", ""xmlVersion"", ""salVersion"", ""openSpliceVersion"", ""subsystemVersions"" FROM ""efd"".""autogen"".""lsst.sal.:CSCList:.logevent_softwareVersions"" ORDER BY time DESC LIMIT 10",influxql
Azimuth current,"SELECT ""current0"", ""current1"", ""current10"", ""current11"", ""current12"", ""current13"", ""current9"", ""current8"", ""current7"", ""current6"", ""current5"", ""current4"", ""current3"", ""current2"", ""current15"", ""current14"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuthDrives"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
elevation velocity,"SELECT mean(""actualVelocity"") AS ""Velocity"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 HP Position,"SELECT mean(""xPosition"") AS ""mean_xPosition"", mean(""yPosition"") AS ""mean_yPosition"", mean(""zPosition"") AS ""mean_zPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
azimuth velocity,"SELECT mean(""actualVelocity"") AS ""Velocity"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Azimuth torque,"SELECT mean(""actualTorque"") AS ""AzimuthTorque"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
azimuth position,"SELECT mean(""actualPosition"") AS ""Azimuth"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 IMS zposition,"SELECT mean(""zPosition"") * 1000000 AS ""zPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.imsData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:)",influxql
Elevation Drives Currents,"SELECT mean(""current0"") AS ""mean_current0"", mean(""current1"") AS ""mean_current1"", mean(""current10"") AS ""mean_current10"", mean(""current11"") AS ""mean_current11"", mean(""current2"") AS ""mean_current2"", mean(""current3"") AS ""mean_current3"", mean(""current4"") AS ""mean_current4"", mean(""current5"") AS ""mean_current5"", mean(""current6"") AS ""mean_current6"", mean(""current7"") AS ""mean_current7"", mean(""current8"") AS ""mean_current8"", mean(""current9"") AS ""mean_current9"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevationDrives"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Elevation Torque,"SELECT mean(""actualTorque"") AS ""mean_actualTorque"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Elevation,"SELECT mean(""actualPosition"") AS ""Elevation"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
ComCam Cryostat Pressure,"SELECT mean(""vqmpressure"") AS ""mean_vqmpressure"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.vacuum_VQMonitor"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
ComCam RTD Temperatures,"SELECT mean(""temperatureCold1"") AS ""mean_temperatureCold1"", mean(""temperatureCold2"") AS ""mean_temperatureCold2"", mean(""temperatureCryo"") AS ""mean_temperatureCryo"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.vacuum_Rtds"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
ComCam CryoTel Reject Temperatures,"SELECT mean(""rejectTemperature"") AS ""mean_rejectTemperature"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.vacuum_Cold1"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
ComCam CryoTel Reject Temperatures,"SELECT mean(""rejectTemperature"") AS ""mean_rejectTemperature"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.vacuum_Cold2"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
ComCam CryoTel Reject Temperatures,"SELECT mean(""rejectTemperature"") AS ""mean_rejectTemperature"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.vacuum_Cryo"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Total REB Power,"SELECT mean(""rebTotalPower"") AS ""mean_rebTotalPower"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.rebpower_RebTotalPower"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Ion Pump Voltage and Current,"SELECT mean(""voltage"") AS ""mean_voltage"", mean(""current"") AS ""mean_current"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.vacuum_IonPumps"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Turbo Speed,"SELECT mean(""rpm"") AS ""mean_rpm"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.vacuum_Turbo"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Mean Sensor Temperatures,"SELECT mean(""rTDTemp2"") AS ""mean_rTDTemp2"", mean(""rTDTemp0"") AS ""mean_rTDTemp0"", mean(""rTDTemp1"") AS ""mean_rTDTemp1"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.focal_plane_Reb"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 glycol mixing valve,"SELECT mean(""valvePosition"") AS ""mean_valvePosition"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.mixingValve"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
2nd row bottom 9 FCU (clone 1),"SELECT ""fanRPM95"", ""fanRPM94"", ""fanRPM93"", ""fanRPM92"", ""fanRPM91"", ""fanRPM90"", ""fanRPM89"", ""fanRPM88"", ""fanRPM87"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.thermalData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Top 8 FCU fan speed,"SELECT ""fanRPM0"", ""fanRPM1"", ""fanRPM2"", ""fanRPM3"", ""fanRPM4"", ""fanRPM5"", ""fanRPM6"", ""fanRPM7"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.thermalData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
M1M3 cell temperatures,"SELECT ""insideCellTemperature1"", ""insideCellTemperature2"", ""insideCellTemperature3"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.glycolLoopTemperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
2nd row bottom 9 FCU,"SELECT ""absoluteTemperature86"", ""absoluteTemperature85"", ""absoluteTemperature84"", ""absoluteTemperature83"", ""absoluteTemperature82"", ""absoluteTemperature81"", ""absoluteTemperature80"", ""absoluteTemperature78"", ""absoluteTemperature77"", ""absoluteTemperature76"", ""absoluteTemperature75"", ""absoluteTemperature74"", ""absoluteTemperature73"", ""absoluteTemperature72"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.thermalData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
2nd row 9 top FCU,"SELECT ""absoluteTemperature8"", ""absoluteTemperature9"", ""absoluteTemperature10"", ""absoluteTemperature11"", ""absoluteTemperature12"", ""absoluteTemperature13"", ""absoluteTemperature14"", ""absoluteTemperature15"", ""absoluteTemperature16"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.thermalData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
ESS M1M3 air temperature,"SELECT ""temperatureItem0"" AS ""M1M3 air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 113 AND time > :dashboardTime: AND time < :upperDashboardTime: FILL(null)",influxql
ESS M1M3 air temperature,"SELECT ""aboveMirrorTemperature"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.glycolLoopTemperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Top 8 FCU,"SELECT ""absoluteTemperature0"", ""absoluteTemperature1"", ""absoluteTemperature2"", ""absoluteTemperature3"", ""absoluteTemperature4"", ""absoluteTemperature5"", ""absoluteTemperature6"", ""absoluteTemperature7"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.thermalData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Bottom 9 FCU,"SELECT ""absoluteTemperature95"", ""absoluteTemperature94"", ""absoluteTemperature93"", ""absoluteTemperature92"", ""absoluteTemperature91"", ""absoluteTemperature90"", ""absoluteTemperature89"", ""absoluteTemperature88"", ""absoluteTemperature87"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.thermalData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
ESS outside,"SELECT ""temperatureItem0"" AS ""Outside air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: FILL(null)",influxql
M1M3 glycol temperatures,"SELECT ""mirrorCoolantReturnTemperature"", ""mirrorCoolantSupplyTemperature"", ""telescopeCoolantReturnTemperature"", ""telescopeCoolantSupplyTemperature"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.glycolLoopTemperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
M1M3 glycol temperatures  (clone 2),"SELECT mean(""valvePosition"") AS ""mean_valvePosition"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.mixingValve"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
,"SELECT ""targetName"", ""raString"", ""decString"" FROM ""efd"".""autogen"".""lsst.sal.ATPtg.logevent_currentTarget"" ORDER BY time DESC LIMIT 1",influxql
Applied,"SELECT ""configurations"", ""version"", ""url"", ""otherInfo"" FROM ""efd"".""autogen"".""lsst.sal.:CSCList:.logevent_configurationApplied"" ORDER BY time DESC LIMIT 10",influxql
Overrides,"SELECT ""overrides"", ""version"", ""url"" FROM ""efd"".""autogen"".""lsst.sal.:CSCList:.logevent_configurationsAvailable"" ORDER BY time DESC LIMIT 10",influxql
Voltages,"SELECT mean(""analog_V"") AS ""mean_analog_V"", mean(""clkHigh_V"") AS ""mean_clkHigh_V"", mean(""clkLow_V"") AS ""mean_clkLow_V"", mean(""digital_V"") AS ""mean_digital_V"", mean(""dphi_V"") AS ""mean_dphi_V"", mean(""heater_V"") AS ""mean_heater_V"", mean(""hvbias_V"") AS ""mean_hvbias_V"", mean(""od_V"") AS ""mean_od_V"", mean(""otm_V"") AS ""mean_otm_V"", mean(""aux_V"") AS ""mean_aux_V"", mean(""fan_V"") AS ""mean_fan_V"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.power"" WHERE time > :dashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Currents,"SELECT mean(""analog_I"") AS ""mean_analog_I"", mean(""clkHigh_I"") AS ""mean_clkHigh_I"", mean(""clkLow_I"") AS ""mean_clkLow_I"", mean(""digital_I"") AS ""mean_digital_I"", mean(""dphi_I"") AS ""mean_dphi_I"", mean(""heater_I"") AS ""mean_heater_I"", mean(""hvbias_I"") AS ""mean_hvbias_I"", mean(""od_I"") AS ""mean_od_I"", mean(""aux_I"") AS ""mean_aux_I"", mean(""fan_I"") AS ""mean_fan_I"", mean(""otm_I"") AS ""mean_otm_I"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.power"" WHERE time > :dashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
ForceActuator primary applied force,"import ""strings""

from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.appliedCylinderForces"")
  |> filter(fn: (r) => r[""_field""] == strings.joinStr(arr:[""primaryCylinderForces"", v.ActuatorID], v:"""") )
  |> map(fn: (r) => ({r with _value: float(v: r._value) / 1000.0}))",flux
ForceActuator primary cylinder following error,"SELECT ""primaryCylinderFollowingError:ActuatorID:"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.forceActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
zForces,"SELECT ""zForce:ActuatorID:"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.forceActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
zForces,"SELECT ""zForces:ActuatorID:"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.appliedForces"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
ForceActuator primary cylinder force,"SELECT ""primaryCylinderForce:ActuatorID:"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.forceActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
slewFlag,"from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.logevent_boosterValveStatus"")
  |> filter(fn: (r) => r[""_field""] == ""slewFlag"")
  |> map(fn: (r) => ({r with _value: if r._value == true then 1 else 0}))",flux
Sal Index 108 - Photodiode PrimaryMirror MaskChanger ElectronicsCabinet,"SELECT mean(""temperatureItem0"") AS ""mean_temperatureItem0"", mean(""temperatureItem1"") AS ""mean_temperatureItem1"", mean(""temperatureItem2"") AS ""mean_temperatureItem2"", mean(""temperatureItem3"") AS ""mean_temperatureItem3"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 108 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Sal Index 201 - AT Azimuth Axis,"SELECT mean(""temperatureItem0"") AS ""mean_temperatureItem0"", mean(""temperatureItem1"") AS ""mean_temperatureItem1"", mean(""temperatureItem2"") AS ""mean_temperatureItem2"", mean(""temperatureItem3"") AS ""mean_temperatureItem3"", mean(""temperatureItem4"") AS ""mean_temperatureItem4"", mean(""temperatureItem5"") AS ""mean_temperatureItem5"", mean(""temperatureItem6"") AS ""mean_temperatureItem6"", mean(""temperatureItem7"") AS ""mean_temperatureItem7"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 201 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Sal Index 107 - Laser Enclosure,"SELECT mean(""temperatureItem0"") AS ""mean_temperatureItem0"", mean(""temperatureItem1"") AS ""mean_temperatureItem1"", mean(""temperatureItem2"") AS ""mean_temperatureItem2"", mean(""temperatureItem3"") AS ""mean_temperatureItem3"", mean(""temperatureItem4"") AS ""mean_temperatureItem4"", mean(""temperatureItem5"") AS ""mean_temperatureItem5"", mean(""temperatureItem6"") AS ""mean_temperatureItem6"", mean(""temperatureItem7"") AS ""mean_temperatureItem7"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 107 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Sal Index 111 - Camera inlet plane; RPi with sticker 3,"SELECT mean(""temperatureItem0"") AS ""Camera Inlet Plane"", mean(""temperatureItem1"") AS ""RPi with sticker 3"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 111 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Sal Index 106 - M2 Tangent Links,"SELECT mean(""temperatureItem1"") AS ""Tangent link A1"", mean(""temperatureItem2"") AS ""Tangent link A2"", mean(""temperatureItem3"") AS ""Tangent link A3"", mean(""temperatureItem4"") AS ""Tangent link A4"", mean(""temperatureItem5"") AS ""Tangent link A5"", mean(""temperatureItem6"") AS ""Tangent link A6"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 106 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Sal Index 201 - M1 Sensors,"SELECT mean(""temperatureItem0"") AS ""mean_temperatureItem0"", mean(""temperatureItem1"") AS ""mean_temperatureItem1"", mean(""temperatureItem2"") AS ""mean_temperatureItem2"", mean(""temperatureItem3"") AS ""mean_temperatureItem3"", mean(""temperatureItem4"") AS ""mean_temperatureItem4"", mean(""temperatureItem5"") AS ""mean_temperatureItem5"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 201 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Sal Index 113 - M1M3; RPi with sticker 4,"SELECT mean(""temperatureItem0"") AS ""M1M3"", mean(""temperatureItem1"") AS ""RPi with sticker 4"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 113 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Sal Index 1 - Rotator,"SELECT mean(""temperatureItem6"") AS ""Rotator Motor 1"", mean(""temperatureItem7"") AS ""Rotator Motor 2"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 1 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Sal Index 1 - Camera Hexapod,"SELECT mean(""temperatureItem0"") AS ""CamHex Strut 7"", mean(""temperatureItem1"") AS ""CamHex Strut 8"", mean(""temperatureItem2"") AS ""CamHex Strut 9"", mean(""temperatureItem3"") AS ""CamHex Strut 10"", mean(""temperatureItem4"") AS ""CamHex Strut 11"", mean(""temperatureItem5"") AS ""CamHex Strut 12"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 1 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null) ",influxql
Actual positions,"SELECT ""actualPosition"", ""demandPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Actual positions,"SELECT ""actualPositionDrive0"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuthCableWrap"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Difference in positions,"t1 = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.MTMount.azimuth/ and r._field == ""actualPosition"")
  |> aggregateWindow(every: 1s, fn: mean)
  |> keep(columns: [""_time"", ""_value""])
  
t2 = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.MTMount.azimuthCableWrap/ and r._field == ""actualPositionDrive0"")
  |> aggregateWindow(every: 1s, fn: mean)
  |> keep(columns: [""_time"", ""_value""])

join(tables: {t1: t1, t2: t2}, on: [""_time""])
  |> map(fn: (r) => ({ r with _value: r._value_t2 - r._value_t1}))
  |> keep(columns: [""_time"", ""_value""])
  |> yield(name: ""delta"")
  ",flux
Heartbeat DIMM,"SELECT count(""heartbeat"") FROM ""efd"".""autogen"".""lsst.sal.DIMM.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(5s) ORDER BY DESC LIMIT 1",influxql
Seeing,"SELECT mean(""fwhm"") AS ""mean_fwhm"" FROM ""efd"".""autogen"".""lsst.sal.DIMM.logevent_dimmMeasurement"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(previous)",influxql
DIMM Seeing,"SELECT ""fwhm"" FROM ""efd"".""autogen"".""lsst.sal.DIMM.logevent_dimmMeasurement"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Heartbeat WeatherStation,"SELECT count(""heartbeat"") FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.logevent_heartbeat"" WHERE time > :dashboardTime: and time < :upperDashboardTime: GROUP BY time(5s) ORDER BY DESC LIMIT 1",influxql
Twilight Begin Time,"SELECT mean(""twilightBeginTime"") AS ""mean_twilightBeginTime"" FROM ""efd"".""autogen"".""lsst.sal.ATPtg.skyEnvironment"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(previous)",influxql
Sun Altitude,"SELECT mean(""sunAltitude"") AS ""mean_sunAltitude"" FROM ""efd"".""autogen"".""lsst.sal.ATPtg.skyEnvironment"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(previous)",influxql
Moon Phase,"SELECT mean(""moonPhase"") AS ""mean_moonPhase"" FROM ""efd"".""autogen"".""lsst.sal.ATPtg.skyEnvironment"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(previous)",influxql
Moon Altitude,"SELECT mean(""moonAltitude"") AS ""mean_moonAltitude"" FROM ""efd"".""autogen"".""lsst.sal.ATPtg.skyEnvironment"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(previous)",influxql
test1,"SELECT mean(""dischrgPrs"") AS ""mean_dischrgPrs"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.pathfinder_refrig_Cryo2"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Compressors 4->6 Temperatures,"SELECT mean(""afterCoolTmp"") AS ""mean_afterCoolTmp"", mean(""dischrgtmp_M"") AS ""mean_dischrgtmp_M"", mean(""dischrgtmp_P"") AS ""mean_dischrgtmp_P"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.pathfinder_refrig_Cryo4"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Compressors 4->6 Temperatures,"SELECT mean(""afterCoolTmp"") AS ""mean_afterCoolTmp"", mean(""dischrgtmp_M"") AS ""mean_dischrgtmp_M"", mean(""dischrgtmp_P"") AS ""mean_dischrgtmp_P"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.pathfinder_refrig_Cryo5"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Compressors 4->6 Temperatures,"SELECT mean(""afterCoolTmp"") AS ""mean_afterCoolTmp"", mean(""dischrgtmp_M"") AS ""mean_dischrgtmp_M"", mean(""dischrgtmp_P"") AS ""mean_dischrgtmp_P"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.pathfinder_refrig_Cryo6"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Compressors 1 and 3 Temperatures,"SELECT mean(""afterCoolTmp"") AS ""mean_afterCoolTmp"", mean(""dischrgtmp_M"") AS ""mean_dischrgtmp_M"", mean(""dischrgtmp_P"") AS ""mean_dischrgtmp_P"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.pathfinder_refrig_Cryo1"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Compressors 1 and 3 Temperatures,"SELECT mean(""afterCoolTmp"") AS ""mean_afterCoolTmp"", mean(""dischrgtmp_M"") AS ""mean_dischrgtmp_M"", mean(""dischrgtmp_P"") AS ""mean_dischrgtmp_P"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.pathfinder_refrig_Cryo3"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Compessors 4->6 Power,"SELECT mean(""compPower"") AS ""mean_compPower"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.pathfinder_refrig_Cryo4"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Compessors 4->6 Power,"SELECT mean(""compPower"") AS ""mean_compPower"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.pathfinder_refrig_Cryo5"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Compessors 4->6 Power,"SELECT mean(""compPower"") AS ""mean_compPower"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.pathfinder_refrig_Cryo6"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Compressors 1->3 Power,"SELECT mean(""compPower"") AS ""mean_compPower"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.pathfinder_refrig_Cryo1"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Compressors 1->3 Power,"SELECT mean(""compPower"") AS ""mean_compPower"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.pathfinder_refrig_Cryo2"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Compressors 1->3 Power,"SELECT mean(""compPower"") AS ""mean_compPower"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.pathfinder_refrig_Cryo3"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Map Example,"SELECT mean(""usage_user"") AS ""mean_usage_user"" FROM ""telegraf"".""autogen"".""cpu"" WHERE ""cpu"" = ':cpu_map:' and time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null) ",influxql
CSV Example,"SELECT mean(""usage_user"") AS ""mean_usage_user"" FROM ""telegraf"".""autogen"".""cpu"" WHERE ""cpu"" = ':cpu_csv:' and time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null) ",influxql
Predefined Meta Query Example,"SELECT mean(""usage_user"") AS ""mean_usage_user"" FROM ""telegraf"".""autogen"".""cpu"" WHERE ""cpu"" = :cpu_tag_values: and time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null) ",influxql
Custom Query Example,"SELECT mean(""usage_user"") AS ""mean_usage_user"" FROM ""telegraf"".""autogen"".""cpu"" WHERE ""cpu"" = ':cpu_custom_query:' and time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null) ",influxql
Text Example,"SELECT mean(""usage_user"") AS ""mean_usage_user"" FROM ""telegraf"".""autogen"".""cpu"" WHERE ""cpu"" = ':cpu_text:' and time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null) ",influxql
breakawayLVDT5- displacementLVDT5,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] == ""breakawayLVDT5"" or r[""_field""] == ""displacementLVDT5"")
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> map(fn: (r) => ({r with _value: r.breakawayLVDT5 - r.displacementLVDT5}))
  |> drop(columns: [""breakawayLVDT5"", ""displacementLVDT5""])

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
breakawayLVDT4 - displacementLVDT4,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] == ""breakawayLVDT4"" or r[""_field""] == ""displacementLVDT4"")
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> map(fn: (r) => ({r with _value: r.breakawayLVDT4 - r.displacementLVDT4}))
  |> drop(columns: [""breakawayLVDT4"", ""displacementLVDT4""])

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
displacementLVDT4,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] == ""displacementLVDT4"")
 
if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
displacementLVDT5,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] == ""displacementLVDT5"")
 
if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
breakawayLVDT5,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] == ""breakawayLVDT5"")
 
if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
breakawayLVDT4,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] == ""breakawayLVDT4"")
 
if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
displacementLVDT3,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] == ""displacementLVDT3"")
 
if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
breakawayLVDT3,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] == ""breakawayLVDT3"")
 
if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
breakawayLVDT3 - displacementLVDT3,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] == ""breakawayLVDT3"" or r[""_field""] == ""displacementLVDT3"")
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> map(fn: (r) => ({r with _value: r.breakawayLVDT3 - r.displacementLVDT3}))
  |> drop(columns: [""breakawayLVDT3"", ""displacementLVDT3""])

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
displacementLVDT2,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] == ""displacementLVDT2"")
 
if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
breakawayLVDT2,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] == ""breakawayLVDT2"")
 
if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
breakawayLVDT2 - displacementLVDT2,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] == ""breakawayLVDT2"" or r[""_field""] == ""displacementLVDT2"")
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> map(fn: (r) => ({r with _value: r.breakawayLVDT2 - r.displacementLVDT2}))
  |> drop(columns: [""breakawayLVDT2"", ""displacementLVDT2""])

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
displacementLVDT1,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] == ""displacementLVDT1"")
 
if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
breakawayLVDT1,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] == ""breakawayLVDT1"")
 
if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
breakawayLVDT1 - displacementLVDT1,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] == ""breakawayLVDT1"" or r[""_field""] == ""displacementLVDT1"")
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> map(fn: (r) => ({r with _value: r.breakawayLVDT1 - r.displacementLVDT1}))
  |> drop(columns: [""breakawayLVDT1"", ""displacementLVDT1""])

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
breakawayLVDT0,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] == ""breakawayLVDT0"")
 
if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
displacementLVDT0,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] == ""displacementLVDT0"")
 
if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
breakawayLVDT0 - displacementLVDT0,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] == ""breakawayLVDT0"" or r[""_field""] == ""displacementLVDT0"")
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> map(fn: (r) => ({r with _value: r.breakawayLVDT0 - r.displacementLVDT0}))
  |> drop(columns: [""breakawayLVDT0"", ""displacementLVDT0""])

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Demanded Accelaration (clone 1),"SELECT ""demandAcceleration"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.rotation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Motor_0 and Motor_1 Temps,"SELECT ""temperatureItem6"", ""temperatureItem7"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Rotator_CCW followingposition  error,"SELECT ""positionError"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.ccwFollowingError"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Position Actual and Demanded (clone 1),"SELECT ""errorCode"", ""errorReport"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_errorCode"" ORDER BY DESC LIMIT 50",influxql
Motors Bus Voltage,"SELECT mean(""busVoltage"") AS ""mean_busVoltage"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.motors"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M2 Tanget Actuator Error,"SELECT mean(""force0"") AS ""mean_force0"", mean(""force1"") AS ""mean_force1"", mean(""force2"") AS ""mean_force2"", mean(""force3"") AS ""mean_force3"", mean(""force4"") AS ""mean_force4"", mean(""force5"") AS ""mean_force5"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.forceErrorTangent"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
TMA Elevation,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Emergency Stop Active,"SELECT ""active"" FROM ""efd"".""autogen"".""lsst.sal.ATDome.logevent_emergencyStop"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Velocity Actual and Demanded,"SELECT ""actualVelocity"", ""demandVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.rotation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Currents Motor_0 and Motor_1,"SELECT ""current0"", ""current1"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.motors"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Position Actual and Demanded,"SELECT ""actualPosition"", ""demandPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.rotation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Fault commanded,"SELECT ""private_efdStamp"", ""private_identity"", ""private_seqNum"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.command_fault"" ORDER BY DESC LIMIT 50",influxql
Rotator Acceleration + Deceleration,"SELECT ""accel"" AS ""accel"", ""decel"" AS ""decel"" FROM ""efd"".""autogen"".""lsst.sal.Scheduler.logevent_rotatorConfig"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Applied Balance Forces Magnitude,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.appliedBalanceForces"")
  |> filter(fn: (r) => r[""_field""] =~ /forceMagnitude/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoints Force Magnitude,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /forceMagnitude/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Applied Balance Forces,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.appliedBalanceForces"")
  |> filter(fn: (r) => r[""_field""] =~ /^f.$/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoints Forces,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /^f.$/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
TMA Elevation,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevation"")
  |> filter(fn: (r) => r[""_field""] == ""actualPosition"")

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Elevation Position ,"SELECT ""actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Azimuth Position ,"SELECT ""actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
appliedBalanceForces - ForceMagnitude,"SELECT ""forceMagnitude"", ""fx"", ""fy"", ""fz"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.appliedBalanceForces"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
HardPoint Actuator-  Measured Forces STDev,"SELECT stddev(""measuredForce0"") AS ""stddev_measuredForce0"", stddev(""measuredForce1"") AS ""stddev_measuredForce1"", stddev(""measuredForce2"") AS ""stddev_measuredForce2"", stddev(""measuredForce3"") AS ""stddev_measuredForce3"", stddev(""measuredForce4"") AS ""stddev_measuredForce4"", stddev(""measuredForce5"") AS ""stddev_measuredForce5"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Elevation Torque,"SELECT ""actualTorque"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Azimuth torque,"SELECT ""actualTorque"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
HardPoint Actuator-  Measure Forces,"SELECT ""measuredForce0"", ""measuredForce1"", ""measuredForce2"", ""measuredForce3"", ""measuredForce4"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Balance Forces - forceMagnitude STDev,"SELECT stddev(""forceMagnitude"") AS ""stddev_forceMagnitude"", stddev(""fx"") AS ""stddev_fx"", stddev(""fy"") AS ""stddev_fy"", stddev(""fz"") AS ""stddev_fz"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.appliedBalanceForces"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
MT CSCs,"import ""strings"" 

from(bucket: ""efd/autogen"")
  |> range(start: dashboardTime)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.MT.*.logevent_heartbeat/ and (r._field == ""heartbeat""))
  |> last()
  |> group()
  |> count()
  
 ",flux
AT heartbeat counts,"import ""strings""

from(bucket: ""efd/autogen"")
  |> range(start: dashboardTime)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.MT.*.logevent_heartbeat/ and r._field == ""heartbeat"")
  |> aggregateWindow(every: 1m, fn: count)
  |> map(fn: (r) => ({
    r with
    status: if r._value > 1 then 1 else 0,
    csc: strings.split(v: r._measurement, t: ""."")[2],
    })
  )
  |> group(columns: [""csc""])
  |> keep(columns: [""_time"", ""csc"", ""status""])
 
",flux
MT CSC status and downtime,"import ""strings"" 

from(bucket: ""efd/autogen"")
  |> range(start: dashboardTime)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.MT.*.logevent_heartbeat/ and (r._field == ""heartbeat""))
  |> aggregateWindow(every: 1m, fn: count)
  |> stateCount(
  	fn: (r) => r._value == 0,
  	column: ""down_counts""
  )
  |> last()
  |> map(fn: (r) => ({
    r with
    csc: strings.split(v: r._measurement, t: ""."")[2],
    status: if r._value > 1 then ""Up"" else ""Down"",
    downtime:  r.down_counts + 1
  }))
  |> keep(columns:[""csc"", ""status"", ""downtime""])

 
 ",flux
ATMCS-Tracking,"SELECT ""state"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.logevent_atMountState"" ORDER BY DESC LIMIT 1",influxql
Elevation,"SELECT ""elevationCalculatedAngle99"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.mount_AzEl_Encoders"" ORDER BY DESC LIMIT 1",influxql
Azimuth,"SELECT ""azimuthCalculatedAngle99"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.mount_AzEl_Encoders"" ORDER BY DESC LIMIT 1",influxql
GenericCamera:1,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.GenericCamera.logevent_summaryState"" WHERE ""salIndex"" = 1 ORDER BY DESC LIMIT 1",influxql
ATAOS,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATHexapod,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATHexapod.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATDome,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATDome.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATPtg,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATPtg.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATDomeTrajectory,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATDomeTrajectory.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATMCS,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATMonochromator,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATMonochromator.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATHeaderService,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATHeaderService.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATArchiver,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATArchiver.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATCamera,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
Electrometer,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.Electrometer.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATSpectrograph,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATSpectrograph.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATPneumatics,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATPneumatics.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
FiberSpectrograph,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.FiberSpectrograph.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
Scheduler,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.Scheduler.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
OCPS,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.OCPS.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
"MTM2.forceBalance fx, fy & fz","SELECT ""fx"", ""fy"", ""fz"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.forceBalance"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
"MTM2.tangentForce applied0, hardpointCorrection0, lutGravity0, lutTemperature0 & measured0","SELECT ""applied0"", ""hardpointCorrection0"", ""lutGravity0"", ""lutTemperature0"", ""measured0"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.tangentForce"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
"MTM2.axialForce applied0, measured0, hardpointCorrection0, lutGravity0, lutTemperature0","SELECT ""applied0"", ""measured0"", ""hardpointCorrection0"", ""lutGravity0"", ""lutTemperature0"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.axialForce"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
"MTM2.position xRot, yRot & zRot","SELECT ""xRot"", ""yRot"", ""zRot"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.position"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
"MTM2.position x, y & z  ","SELECT ""x"", ""y"", ""z"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.position"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
"MTM2.netForcesTotal fx, fy & fz","SELECT ""fx"", ""fy"", ""fz"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.netForcesTotal"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
"MTM2.netMomentsTotal mx,my & mz","SELECT ""mx"", ""my"", ""mz"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.netMomentsTotal"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
"MTM2.temperature ring0, ring11, intake0 & exhaust0","SELECT ""ring0"", ""ring11"", ""intake0"", ""exhaust0"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.temperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTM2.zenithAngle measured & inclinometerProcessed,"SELECT ""measured"", ""inclinometerProcessed"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.zenithAngle"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTM2.axialActuatorSteps steps1 & steps70,"SELECT ""steps0"", ""steps70"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.axialActuatorSteps"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTM2.tangentActuatorSteps steps0 & steps5,"SELECT ""steps0"", ""steps5"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.tangentActuatorSteps"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTM2.axialEncoderPositions position0 & position70,"SELECT ""position0"", ""position70"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.axialEncoderPositions"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTM2.tangentEnconderPosition position0 & position5,"SELECT ""position0"", ""position5"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.tangentEncoderPositions"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTM2.ilcData.status1,"SELECT ""status1"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.ilcData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTM2.powerStatus commVoltage & commCurrent,"SELECT ""commVoltage"", ""commCurrent"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.powerStatus"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTM2.displacementSensors deltaZ0 & thetaZ0,"SELECT ""deltaZ0"", ""thetaZ0"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.displacementSensors"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
"MTM2.positionIMS x, y& z","SELECT ""x"", ""y"", ""z"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.positionIMS"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTM2.logevent_detailedState.detailedState,"SELECT ""detailedState"", ""private_sndStamp"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_detailedState"" ORDER BY time DESC LIMIT 3",influxql
MTM2.logevent_m2AssemblyInPosition.inPosition,"SELECT ""inPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_m2AssemblyInPosition"" ORDER by DESC LIMIT 3",influxql
MTM2.logevent_cellTemperatureHiWarning.hiWarning,"SELECT ""hiWarning"", ""private_sndStamp"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_cellTemperatureHiWarning"" ORDER BY time DESC LIMIT 3",influxql
MTM2.logevent_temperatureOffset ring0 & exhaust0,"SELECT ""ring0"", ""exhaust0"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_temperatureOffset"" ORDER BY time DESC LIMIT 3",influxql
MTM2.logevent_interlock state & private_sndStamp ,"SELECT ""state"", ""private_sndStamp"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_interlock"" ORDER BY time DESC LIMIT 3",influxql
MTM2.logevent_tcpIpConnected,"SELECT ""isConnected"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_tcpIpConnected"" ORDER BY time DESC LIMIT 3",influxql
"MTM2.logevent_hardpointList actuators0, 1, 2, 3 & 4","SELECT ""actuators0"", ""actuators1"", ""actuators2"", ""actuators3"", ""actuators4"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_hardpointList"" ORDER BY time DESC LIMIT 3",influxql
MTM2.logevent_inclinationTelemetrySource source,"SELECT ""source"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_inclinationTelemetrySource"" ORDER BY time DESC LIMIT 3",influxql
MTM2.logevent_forceBalanceSystemStatus status,"SELECT ""status"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_forceBalanceSystemStatus"" ORDER BY time DESC LIMIT 3",influxql
Tracebacks,"SELECT ""traceback"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_logMessage"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
TMA Azimuth Torque,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.azimuth"")
  |> filter(fn: (r) => r[""_field""] == ""actualTorque"")


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
TMA Azimuth,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.azimuth"")
  |> filter(fn: (r) => r[""_field""] == ""actualPosition"")


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoints Forces,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /measuredForce./)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
TMA Elevation,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevation"")
  |> filter(fn: (r) => r[""_field""] == ""actualPosition"")

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
TMA Elevation Torque,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevation"")
  |> filter(fn: (r) => r[""_field""] == ""actualTorque"")

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
ESS113: M1M3 Plane,"SELECT ""temperatureItem0"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 113 and time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
ESS113: M1M3 Plane,"SELECT relativeHumidityItem FROM ""efd"".""autogen"".""lsst.sal.ESS.relativeHumidity"" WHERE salIndex = 113 and time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
ESS113: M1M3 Plane,"SELECT dewPointItem FROM ""efd"".""autogen"".""lsst.sal.ESS.dewPoint"" WHERE salIndex = 113 and time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
ESS112: M2 Plane,"SELECT ""temperatureItem0"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 112 and time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
ESS112: M2 Plane,"SELECT relativeHumidityItem FROM ""efd"".""autogen"".""lsst.sal.ESS.relativeHumidity"" WHERE salIndex = 112 and time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
ESS112: M2 Plane,"SELECT dewPointItem FROM ""efd"".""autogen"".""lsst.sal.ESS.dewPoint"" WHERE salIndex = 112 and time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
ESS111: Camera Plane,"SELECT ""temperatureItem0"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 111 and time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
ESS111: Camera Plane,"SELECT relativeHumidityItem FROM ""efd"".""autogen"".""lsst.sal.ESS.relativeHumidity"" WHERE salIndex = 111 and time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
ESS111: Camera Plane,"SELECT dewPointItem FROM ""efd"".""autogen"".""lsst.sal.ESS.dewPoint"" WHERE salIndex = 111 and time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
LFA URL,"SELECT ""url"" FROM ""efd"".""autogen"".""lsst.sal.GenericCamera.logevent_largeFileObjectAvailable"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Pointing Offsets,"SELECT ""disperser0"", ""disperser1"", ""filter0"", ""filter1"", ""total0"", ""total1"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_pointingOffsetSummary"" ORDER BY DESC LIMIT 1",influxql
Focus Offset Summary,"SELECT ""filter"", ""disperser"", ""userApplied"", ""total"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_focusOffsetSummary""  ORDER BY DESC LIMIT 1",influxql
Enabled Corrections,"SELECT ""atspectrograph"", ""hexapod"", ""m1"", ""moveWhileExposing"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_correctionEnabled"" ORDER BY DESC LIMIT 1",influxql
Hexapod - Z,"SELECT ""hexapod_z"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_hexapodCorrectionCompleted"" WHERE time > :dashboardTime:",influxql
Hexapod - Z,"SELECT ""reportedPosition2"" FROM ""efd"".""autogen"".""lsst.sal.ATHexapod.positionStatus"" WHERE time > :dashboardTime:",influxql
Hexapod - Y,"SELECT ""hexapod_y"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_hexapodCorrectionCompleted"" WHERE time > :dashboardTime:",influxql
Hexapod - Y,"SELECT ""reportedPosition1"" FROM ""efd"".""autogen"".""lsst.sal.ATHexapod.positionStatus"" WHERE time > :dashboardTime:",influxql
Hexapod - X,"SELECT ""hexapod_x"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_hexapodCorrectionCompleted""  WHERE time > :dashboardTime:",influxql
Hexapod - X,"SELECT ""reportedPosition0"" FROM ""efd"".""autogen"".""lsst.sal.ATHexapod.positionStatus"" WHERE time > :dashboardTime:",influxql
AOSM1,"SELECT ""pressure"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_m1CorrectionCompleted""  ORDER BY DESC LIMIT 1",influxql
M1,"SELECT ""pressure"" FROM ""efd"".""autogen"".""lsst.sal.ATPneumatics.command_m1SetPressure"" ORDER BY DESC LIMIT 1",influxql
AOS-X,"SELECT ""hexapod_x"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_hexapodCorrectionCompleted""  ORDER BY DESC LIMIT 1",influxql
HexX,"SELECT ""positionX"" FROM ""efd"".""autogen"".""lsst.sal.ATHexapod.logevent_positionUpdate"" ORDER BY DESC LIMIT 1",influxql
AOS-Y,"SELECT ""hexapod_y"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_hexapodCorrectionCompleted""  ORDER BY DESC LIMIT 1",influxql
HexY,"SELECT ""positionY"" FROM ""efd"".""autogen"".""lsst.sal.ATHexapod.logevent_positionUpdate"" ORDER BY DESC LIMIT 1",influxql
AOS-Z,"SELECT ""hexapod_z"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_hexapodCorrectionCompleted""  ORDER BY DESC LIMIT 1",influxql
HexZ,"SELECT ""positionZ"" FROM ""efd"".""autogen"".""lsst.sal.ATHexapod.logevent_positionUpdate"" ORDER BY DESC LIMIT 1",influxql
ATpneumatics,"SELECT ""pressure"" FROM ""efd"".""autogen"".""lsst.sal.ATPneumatics.m1AirPressure""  WHERE time > :dashboardTime:",influxql
ATpneumatics,"SELECT ""pressure"" FROM ""efd"".""autogen"".""lsst.sal.ATPneumatics.command_m1SetPressure"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
accelerationX (SST M2 Surrogate),"SELECT /accelerationX/ FROM ""efd"".""autogen"".""lsst.sal.ESS.accelerometer"" WHERE salIndex = 104 AND sensorName =~ /^SST M2 surrogate/ AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
accelerationY (SST M2 Surrogate),"SELECT /accelerationY/ FROM ""efd"".""autogen"".""lsst.sal.ESS.accelerometer"" WHERE salIndex = 104 AND sensorName =~ /^SST M2 surrogate/ AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
accelerationZ (SST M2 Surrogate),"SELECT /accelerationZ/ FROM ""efd"".""autogen"".""lsst.sal.ESS.accelerometer"" WHERE salIndex = 104 AND sensorName =~ /^SST M2 surrogate/ AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
M1 and M2 minus Air Temp,"SELECT ""temperatureItem3""-""temperatureItem1"" as ""M2 minus Air temp""  FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 201 AND ""sensorName"" = 'AuxTel-ESS01' AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Slit Headwind and Crosswind,"SELECT sqrt(mean(""speed0"")*mean(""speed0"") + mean(""speed2"")*mean(""speed2"")) AS ""Headwind_camp"", mean(""speed1"") AS ""Crosswind_camp""  FROM ""efd"".""autogen"".""lsst.sal.ESS.airTurbulence"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 201 GROUP BY time(:interval:) FILL(null)",influxql
Slit Headwind and Crosswind,"SELECT sqrt(mean(""speed0"")*mean(""speed0"") + mean(""speed2"")*mean(""speed2"")) AS ""Headwind_gill"", mean(""speed1"") AS ""Crosswind_gill""  FROM ""efd"".""autogen"".""lsst.sal.ESS.airTurbulence"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 205 GROUP BY time(:interval:) FILL(null)",influxql
Aux tel temperature sensors,"SELECT ""temperatureItem1"" as ""Air"", ""temperatureItem2"" as ""Truss"", ""temperatureItem3"" as ""M2"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 201 AND ""sensorName"" = 'AuxTel-ESS01' AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Sonic Temperature Std Dev,"SELECT mean(""sonicTemperatureStdDev"") AS ""mean_sonicTemperatureStdDev_camp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airTurbulence"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 201 GROUP BY time(:interval:) FILL(null)",influxql
Sonic Temperature Std Dev,"SELECT mean(""sonicTemperatureStdDev"") AS ""mean_sonicTemperatureStdDev_gill"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airTurbulence"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 205 GROUP BY time(:interval:) FILL(null)",influxql
DIMM FWHM,"SELECT mean(""fwhm"") AS ""mean_fwhm"" FROM ""efd"".""autogen"".""lsst.sal.DIMM.logevent_dimmMeasurement"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
AT elevation,"SELECT mean(""elevation0"") AS ""mean_elevation0"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.trajectory"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
AT azimuth,"SELECT mean(""azimuth0"") AS ""mean_azimuth0"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.trajectory"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
External wind direction 2min avg,"SELECT mean(""avg2M"") AS ""mean_avg2M"" FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.windDirection"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Anemometer 3 axis ,"SELECT mean(""speed0"") AS ""mean_speed0_camp"", mean(""speed1"") AS ""mean_speed1_camp"", mean(""speed2"") AS ""mean_speed2_camp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airTurbulence"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 201 GROUP BY time(:interval:) FILL(null)",influxql
Anemometer 3 axis ,"SELECT mean(""speed0"") AS ""mean_speed0_gill"", mean(""speed1"") AS ""mean_speed1_gill"", mean(""speed2"") AS ""mean_speed2_gill"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airTurbulence"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 205 GROUP BY time(:interval:) FILL(null)",influxql
Sonic temperature,"SELECT mean(""sonicTemperature"") AS ""mean_sonicTemperature_gill"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airTurbulence"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 205 GROUP BY time(:interval:) FILL(null)",influxql
Sonic temperature,"SELECT mean(""sonicTemperature"") AS ""mean_sonicTemperature_camp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airTurbulence"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 201 GROUP BY time(:interval:) FILL(null)",influxql
Vent airspeed,"SELECT mean(""speed"") AS ""mean_speed"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow"" WHERE salIndex=204 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
External anemometer,"SELECT mean(""speed"") AS ""mean_speed"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow"" WHERE salIndex=301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Dome status,"SELECT mean(""mainDoorOpeningPercentage"") AS ""mean_mainDoorOpeningPercentage"", mean(""azimuthPosition"") AS ""mean_azimuthPosition"" FROM ""efd"".""autogen"".""lsst.sal.ATDome.position"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Primary Mirror Temperatures,"SELECT ""temperatureItem0"" as ""M1T1"", ""temperatureItem1"" as ""M1T2"", ""temperatureItem2"" as ""M1T3"", ""temperatureItem3"" as ""M1T4"",""temperatureItem4"" as ""M1T5"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 201 AND ""sensorName"" = 'AuxTel-ESS03' AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
RBM,"SELECT ""x"", ""y"", ""z"",""xRot"", ""yRot"",""zRot"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.position"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Closed Loop Control Mode,"from(bucket: ""efd/autogen"")
  |> range(start: -360h)
  |> filter(fn: (r) => r._measurement == ""lsst.sal.MTM2.logevent_closedLoopControlMode"" and (r._field == ""mode""))
  |> sort(columns: [""_time""], desc: true)  // Ordena por tiempo en orden descendente
  |> limit(n: 5)  // Limita a los ltimos 5 eventos
  |> map(fn: (r) => ({
        r with 
        summaryState: if r._value == 1 then ""IDLE""
                      else if r._value == 2 then ""TELEMETRY""
                      else if r._value == 3 then ""OPEN LOOP""
                      else if r._value == 4 then ""CLOSED LOOP""
                      else string(v: r._value)
    }))
",flux
Closed Loop Control Mode,"SELECT ""mode"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_closedLoopControlMode"" ORDER BY DESC LIMIT 1",influxql
Power Voltage,"SELECT ""motorVoltage"", ""commVoltage"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.powerStatus"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Hardpoints (1-based),"SELECT /actuators/ FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_hardpointList"" ORDER BY DESC LIMIT 3",influxql
Tangential Actuators Temp,"SELECT /temperatureItem/ FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 106",influxql
Summary Faults Status,"SELECT ""status"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_summaryFaultsStatus"" ORDER BY DESC LIMIT 3",influxql
Enabled Faults Mask,"SELECT ""mask"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_enabledFaultsMask"" ORDER BY DESC LIMIT 3",influxql
Summary State,"from(bucket: ""efd/autogen"")
  |> range(start: -360h)
  |> filter(fn: (r) => r._measurement == ""lsst.sal.MTM2.logevent_summaryState"" and (r._field == ""summaryState""))
  |> last()
  |> map(fn: (r) => ({
        r with 
        summaryState: if r._value == 1 then ""DISABLED""
                      else if r._value == 2 then ""ENABLED""
                      else if r._value == 3 then ""FAULT""
                      else if r._value == 4 then ""OFFLINE""
                      else if r._value == 5 then ""STANDBY""
                      else string(v: r._value)
    }))",flux
ErrorCodes,"SELECT ""errorCode"", ""errorReport"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_errorCode"" ORDER BY DESC LIMIT 10",influxql
TMA Azimuth Position,"SELECT ""actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
 Tangent Actuator measured forces,"SELECT ""measured0"", ""measured1"", ""measured2"", ""measured3"", ""measured4"", ""measured5"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.tangentForce"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
 Tangent Actuator steps all,"SELECT ""steps0"",""steps1"",""steps2"",""steps3"",""steps4"",""steps5"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.tangentActuatorSteps"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Log Message,"SELECT ""message"", ""level"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_logMessage"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Inclination Telemetry Source,"SELECT ""source"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_inclinationTelemetrySource"" ORDER BY DESC LIMIT 6",influxql
Net Moments Total,"SELECT ""mx"", ""my"", ""mz"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.netMomentsTotal"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Mirror Position IMS,"SELECT ""x"", ""xRot"", ""y"", ""yRot"", ""z"", ""zRot"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.positionIMS"" ORDER BY DESC LIMIT 3",influxql
Assembly in Position,"SELECT ""inPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_m2AssemblyInPosition"" ORDER BY DESC LIMIT 3",influxql
Mirror Position,"SELECT ""x"", ""y"", ""z"", ""xRot"", ""yRot"", ""zRot"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.position"" ORDER BY DESC LIMIT 3",influxql
Summary State,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_summaryState"" ORDER BY DESC LIMIT 10",influxql
Intake/Exhaust Temperatures,"SELECT /exhaust/, /intake/ FROM ""efd"".""autogen"".""lsst.sal.MTM2.temperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Elevation Angle measured by M2,"SELECT ""inclinometerProcessed"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.zenithAngle"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Heartbeat,"SELECT ""heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Commandable by DDS,"SELECT ""state""  FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_commandableByDDS"" ORDER BY DESC LIMIT 3",influxql
Interlock,"SELECT ""state"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_interlock"" ORDER BY DESC LIMIT 10",influxql
Tangent Fault,"SELECT ""sum"", ""weight"", ""force0"",""force1"", ""force2"",""force3"", ""force4"", ""force5"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.forceErrorTangent"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
TMA Elevation Position,"SELECT ""actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Power Current,"SELECT ""motorCurrent"", ""commCurrent"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.powerStatus"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Temperature high warning,"SELECT ""hiWarning"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_cellTemperatureHiWarning"" ORDER BY DESC LIMIT 5",influxql
Ring Temperatures,"SELECT /ring/ FROM ""efd"".""autogen"".""lsst.sal.MTM2.temperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Header sequence,"SELECT ""url"" FROM ""efd"".""autogen"".""lsst.sal.CCHeaderService.logevent_largeFileObjectAvailable"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTRotator Position,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.rotation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
MTRotator Current,"SELECT mean(""current0"") AS ""Motor 0 current"", mean(""current1"") AS ""Motor 1 current"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.motors"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
MTRotator Temperature,"SELECT ""temperatureItem6"" as ""Motor 1 temp"", ""temperatureItem7"" as ""Motor 2 temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 1 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Camera Hexapod Strut Position (um),"SELECT mean(""calibrated0"") AS ""strut0"", mean(""calibrated1"") AS ""strut1"", mean(""calibrated2"") AS ""strut2"", mean(""calibrated3"") AS ""strut3"", mean(""calibrated4"") AS ""strut4"", mean(""calibrated5"") AS ""strut5"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.actuators"" WHERE salIndex = 1 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
"Camera Hexapod Rotations U, V, W (deg)","SELECT mean(""position3"") AS ""U"", mean(""position4"") AS ""V"", mean(""position5"") AS ""W"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE salIndex = 1 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
"Camera Hexapod Positions X, Y, Z (um)","SELECT mean(""position0"") AS ""X"", mean(""position1"") AS ""Y"", mean(""position2"") AS ""Z"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE salIndex = 1 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Camera Hexapod Temperatures (C),"SELECT ""temperatureItem5"" as ""Strut 12 temp"", ""temperatureItem4"" as ""Strut 11 temp"", ""temperatureItem3"" as ""Strut 10 temp"", ""temperatureItem2"" as ""Strut 9 temp"", ""temperatureItem1"" as ""Strut 8 temp"", ""temperatureItem0"" as ""Strut 7 temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 1 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Camera Hexapod Motor Currents (A),"SELECT mean(""motorCurrent0""), mean(""motorCurrent1""), mean(""motorCurrent2""), mean(""motorCurrent3""), mean(""motorCurrent4""), mean(""motorCurrent5"") FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.electrical"" WHERE salIndex=1 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:)",influxql
M2 Hexapod Motor Currents (A),"SELECT mean(""motorCurrent0""), mean(""motorCurrent1""), mean(""motorCurrent2""), mean(""motorCurrent3""), mean(""motorCurrent4""), mean(""motorCurrent5"") FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.electrical"" WHERE salIndex=2 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:)",influxql
M2 Hexapod Strut Position (um),"SELECT mean(""calibrated0"") AS ""strut0"", mean(""calibrated1"") AS ""strut1"", mean(""calibrated2"") AS ""strut2"", mean(""calibrated3"") AS ""strut3"", mean(""calibrated4"") AS ""strut4"", mean(""calibrated5"") AS ""strut5"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.actuators"" WHERE salIndex = 2 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
"M2 Hexapod Positions X, Y, Z (um)","SELECT mean(""position0"") AS ""X"", mean(""position1"") AS ""Y"", mean(""position2"") AS ""Z"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE salIndex = 2 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
"M2 Hexapod Rotations U, V, W (deg)","SELECT mean(""position3"") AS ""U"", mean(""position4"") AS ""V"", mean(""position5"") AS ""W"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE salIndex = 2 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
19:00 hr Forecast,"SELECT mean(""temperature22"") AS ""mean_temperature22"" FROM ""efd"".""autogen"".""lsst.sal.WeatherForecast.hourlyTrend"" WHERE time > now() - 24h GROUP BY time(:interval:) FILL(previous)",influxql
Wind Speed,"SELECT ""speed"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Wind Direction,"SELECT mean(""direction"") AS ""mean_direction"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(previous)",influxql
M2 Air Temperature,"SELECT mean(""temperatureItem0"") AS ""M2 air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 112 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(previous)",influxql
M1M3 air Temperature,"SELECT mean(""temperatureItem0"") AS ""M1M3 air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 113 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(previous)",influxql
Outside,"SELECT mean(""temperatureItem0"") AS ""Outside air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(previous)",influxql
Ambient Air Temperature above M1M3 RoC (<1C/hr),"SELECT difference(last(""temperatureItem0"")) FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 113 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(1h)",influxql
M1M3 temps,"SELECT mean(""temperatureItem0"") AS ""Outside air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 temps,"SELECT mean(""temperatureItem0"") AS ""Camera air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 111 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 temps,"SELECT mean(""temperatureItem0"") AS ""M2 air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 112 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 temps,"SELECT mean(""temperatureItem0"") AS ""M1M3 air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 113 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 temps,"SELECT ""insideCellTemperature1"", ""insideCellTemperature2"", ""insideCellTemperature3"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.glycolLoopTemperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Glycol delivered temp vs. ambient,"SELECT mean(""glycolTemperaturePier0001"") AS ""Glycol General Temp 0001"", mean(""glycolTemperaturePier0002"") AS ""Glycol General Temp 0002"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.generalPurposeGlycolWater"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Glycol delivered temp vs. ambient,"SELECT mean(""ambientTemperature"") AS ""Azimuth Floor Air Ambient Temp"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.topEndChiller"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Glycol delivered temp vs. ambient,"SELECT mean(""glycolTemperaturePier0101"") AS ""Cold Glycol Temp 0101"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.cooling"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Glycol delivered temp vs. ambient,"SELECT mean(""absoluteTemperature0"") AS ""mean_absoluteTemperature0"", mean(""absoluteTemperature1"") AS ""mean_absoluteTemperature1"", mean(""absoluteTemperature10"") AS ""mean_absoluteTemperature10"", mean(""absoluteTemperature11"") AS ""mean_absoluteTemperature11"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.thermalData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""temperatureItem0"") AS ""Outside air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""temperatureItem0"") AS ""Camera air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 111 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""temperatureItem0"") AS ""M2 air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 112 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""temperatureItem0"") AS ""M1M3 air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 113 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""mainCabinetExternalTemperature"") AS ""Tekniker Cabinet External air temp"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.mainCabinetThermal"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""ambientTemperature"") AS ""Azimuth Floor Air Ambient Temp"", mean(""ambientTemperatureSensor0502"") AS ""Top End Hex Return air temp"", mean(""temperatureSensor0501"") AS ""Top End Rear air temp"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.topEndChiller"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Chiller 1/2,"SELECT mean(""setpointActivo"") AS ""mean_setpointActivo"", mean(""temperaturaAguaImpulsionEvaporador"") AS ""mean_temperaturaAguaImpulsionEvaporador"", mean(""temperaturaAguaRetornoEvaporador"") AS ""mean_temperaturaAguaRetornoEvaporador"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.chiller01P01"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Chiller 1/2,"SELECT mean(""setpointActivo"") AS ""mean_setpointActivo"", mean(""temperaturaAguaImpulsionEvaporador"") AS ""mean_temperaturaAguaImpulsionEvaporador"", mean(""temperaturaAguaRetornoEvaporador"") AS ""mean_temperaturaAguaRetornoEvaporador"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.chiller02P01"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Chiller 3,"SELECT mean(""setpointActivo"") AS ""mean_setpointActivo"", mean(""temperaturaAguaImpulsionEvaporador"") AS ""mean_temperaturaAguaImpulsionEvaporador"", mean(""temperaturaAguaRetornoEvaporador"") AS ""mean_temperaturaAguaRetornoEvaporador"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.chiller03P01"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Outside Temperature RoC (<1.0C/hr),"SELECT difference(last(""temperatureItem0"")) FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(1h)",influxql
Outside Temperature RoC (1 min sampling),"SELECT difference(last(""temperatureItem0"")) FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(1m)",influxql
18:00 hr Forecast,"SELECT mean(""temperature21"") AS ""mean_temperature21"" FROM ""efd"".""autogen"".""lsst.sal.WeatherForecast.hourlyTrend"" WHERE time > now() - 24h GROUP BY time(:interval:) FILL(previous)",influxql
,"SELECT ""targetName"", ""raString"", ""decString"" FROM ""efd"".""autogen"".""lsst.sal.MTPtg.logevent_currentTarget"" ORDER BY time DESC LIMIT 1",influxql
Elevation,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Elevation,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Elevation,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
TMA_CENTRAL dY,"import ""strings""

first_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""dY"")

second_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] ==  ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""target"" )
  |> filter(fn: (r) => strings.containsStr(v: r[""_value""], substr: ""TMA_CENTRAL""))


join(tables: {mean: first_table, align: second_table}, on: [""_time""])
	|> yield(name: ""first_table_data"")
",flux
TMA_CENTRAL dX,"import ""strings""

first_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""dX"")

second_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] ==  ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""target"" )
  |> filter(fn: (r) => strings.containsStr(v: r[""_value""], substr: ""TMA_CENTRAL""))


join(tables: {mean: first_table, align: second_table}, on: [""_time""])
	|> yield(name: ""first_table_data"")
",flux
TMA_CENTRAL dRY,"import ""strings""

first_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""dRY"")

second_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] ==  ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""target"" )
  |> filter(fn: (r) => strings.containsStr(v: r[""_value""], substr: ""TMA_CENTRAL""))


join(tables: {mean: first_table, align: second_table}, on: [""_time""])
	|> yield(name: ""first_table_data"")
",flux
TMA_CENTRAL dRX,"import ""strings""

first_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""dRX"")

second_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] ==  ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""target"" )
  |> filter(fn: (r) => strings.containsStr(v: r[""_value""], substr: ""TMA_CENTRAL""))


join(tables: {mean: first_table, align: second_table}, on: [""_time""])
	|> yield(name: ""first_table_data"")
",flux
TMA_CENTRAL dZ,"import ""strings""

first_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""dZ"")

second_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] ==  ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""target"" )
  |> filter(fn: (r) => strings.containsStr(v: r[""_value""], substr: ""TMA_CENTRAL""))


join(tables: {mean: first_table, align: second_table}, on: [""_time""])
	|> yield(name: ""first_table_data"")
",flux
Camera dY,"import ""strings""

first_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""dY"")

second_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] ==  ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""target"" )
  |> filter(fn: (r) => strings.containsStr(v: r[""_value""], substr: ""CAM""))


join(tables: {mean: first_table, align: second_table}, on: [""_time""])
	|> yield(name: ""first_table_data"")
",flux
Camera dX,"import ""strings""

first_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""dX"")

second_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] ==  ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""target"" )
  |> filter(fn: (r) => strings.containsStr(v: r[""_value""], substr: ""CAM""))


join(tables: {mean: first_table, align: second_table}, on: [""_time""])
	|> yield(name: ""first_table_data"")
",flux
Camera dRX,"import ""strings""

first_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""dRX"")

second_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] ==  ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""target"" )
  |> filter(fn: (r) => strings.containsStr(v: r[""_value""], substr: ""CAM""))


join(tables: {mean: first_table, align: second_table}, on: [""_time""])
	|> yield(name: ""first_table_data"")
",flux
Camera dRY,"import ""strings""

first_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""dRY"")

second_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] ==  ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""target"" )
  |> filter(fn: (r) => strings.containsStr(v: r[""_value""], substr: ""CAM""))


join(tables: {mean: first_table, align: second_table}, on: [""_time""])
	|> yield(name: ""first_table_data"")
",flux
Camera dZ,"import ""strings""

first_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""dZ"")

second_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] ==  ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""target"" )
  |> filter(fn: (r) => strings.containsStr(v: r[""_value""], substr: ""CAM""))


join(tables: {mean: first_table, align: second_table}, on: [""_time""])
	|> yield(name: ""first_table_data"")
",flux
M2 dRY,"import ""strings""

first_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""dRY"")

second_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] ==  ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""target"" )
  |> filter(fn: (r) => strings.containsStr(v: r[""_value""], substr: ""M2""))


join(tables: {mean: first_table, align: second_table}, on: [""_time""])
	|> yield(name: ""first_table_data"")
",flux
M2 dRX,"import ""strings""

first_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""dRX"")

second_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] ==  ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""target"" )
  |> filter(fn: (r) => strings.containsStr(v: r[""_value""], substr: ""M2""))


join(tables: {mean: first_table, align: second_table}, on: [""_time""])
	|> yield(name: ""first_table_data"")
",flux
M2 dZ,"import ""strings""

first_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""dZ"")

second_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] ==  ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""target"" )
  |> filter(fn: (r) => strings.containsStr(v: r[""_value""], substr: ""M2""))


join(tables: {mean: first_table, align: second_table}, on: [""_time""])
	|> yield(name: ""first_table_data"")
",flux
M2 dX,"import ""strings""

first_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""dX"")

second_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] ==  ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""target"" )
  |> filter(fn: (r) => strings.containsStr(v: r[""_value""], substr: ""M2""))


join(tables: {mean: first_table, align: second_table}, on: [""_time""])
	|> yield(name: ""first_table_data"")
",flux
M2 dY,"import ""strings""

first_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""dY"")

second_table = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] ==  ""lsst.sal.LaserTracker.logevent_offsetsPublish"")
  |> filter(fn: (r) => r[""_field""] == ""target"" )
  |> filter(fn: (r) => strings.containsStr(v: r[""_value""], substr: ""M2""))


join(tables: {mean: first_table, align: second_table}, on: [""_time""])
	|> yield(name: ""first_table_data"")
",flux
5V PDU Currents,"SELECT ""otm_3_A_I"", ""otm_3_B_I"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.quadbox_PDU_5V"" WHERE time > :dashboardTime:",influxql
5V PDU Voltages,"SELECT ""otm_3_A_V"", ""otm_3_B_V"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.quadbox_PDU_5V"" WHERE time > :dashboardTime:",influxql
48V PDU Currents,"SELECT ""main_I"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.quadbox_PDU_48V"" WHERE time > :dashboardTime:",influxql
48V PDU Voltages,"SELECT ""main_V"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.quadbox_PDU_48V"" WHERE time > :dashboardTime:",influxql
24V Dirty PDU Currents,"SELECT ""main_I"", ""cryo_Turbo_I"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.quadbox_PDU_24VD"" WHERE time > :dashboardTime:",influxql
24V Dirty PDU Voltages,"SELECT ""main_V"", ""cryo_Turbo_V"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.quadbox_PDU_24VD"" WHERE time > :dashboardTime:",influxql
24V Clean PDU Currents,"SELECT ""body_Purge_I"", ""bpu_Maq20_I"", ""fes_Shu_HCU_I"", ""gauges_I"", ""ion_Pumps_I"", ""main_I"", ""pwr_Cry_HCU_I"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.quadbox_PDU_24VC"" WHERE time > :dashboardTime:",influxql
24V Clean PDU Voltages,"SELECT ""body_Purge_V"", ""bpu_Maq20_V"", ""fes_Shu_HCU_V"", ""gauges_V"", ""ion_Pumps_V"", ""main_V"", ""pwr_Cry_HCU_V"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.quadbox_PDU_24VC"" WHERE time > :dashboardTime:",influxql
48V PDU Temperatures,"SELECT ""board_T"", ""fpga_T"", ""main_T"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.quadbox_PDU_48V"" WHERE time > :dashboardTime: ",influxql
24V Dirty PDU Temperatures,"SELECT ""board_T"", ""fpga_T"", ""main_T"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.quadbox_PDU_24VD"" WHERE time > :dashboardTime: ",influxql
24V Clean PDU Temperatures,"SELECT ""board_T"", ""fpga_T"", ""main_T"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.quadbox_PDU_24VC"" WHERE time > :dashboardTime: ",influxql
BFR Currents,"SELECT ""clean_5_24V_I"", ""dirty_24V_I"", ""dirty_28V_I"", ""dirty_48V_I"", ""heater_I"", ""protection_I"", ""rebps_0"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.quadbox_BFR"" WHERE time > :dashboardTime:",influxql
Electric Field Strength,"SELECT ""strength"", ""strengthMax"" FROM ""efd"".""autogen"".""lsst.sal.ESS.electricFieldStrength"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Strike Status,"SELECT ""closeStrikeRate"", ""totalStrikeRate"" FROM ""efd"".""autogen"".""lsst.sal.ESS.lightningStrikeStatus"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND closeStrikeRate >= 0 AND totalStrikeRate >= 0",influxql
Strike Bearing and Distance,"SELECT ""bearing"", ""correctedDistance"", ""uncorrectedDistance"" FROM ""efd"".""autogen"".""lsst.sal.ESS.logevent_lightningStrike"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND ""correctedDistance"" >= 0",influxql
TMA Ambient Temp,"SELECT mean(""temperature0"") AS ""mean_temperature0"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex=103 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
TMA Actual Elevation using (:aggregateFunction:),"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevation"")
  |> filter(fn: (r) => r[""_field""] == ""actualPosition"")
  
 
if v.aggregateFunction == ""min"" then 
  data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
else if v.aggregateFunction == ""max"" then 
  data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
else if v.aggregateFunction == ""mean"" then 
  data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
else if v.aggregateFunction == ""spread"" then 
  data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
else 
  data",flux
TMA Elevation Drive Currents (:aggregateFunction:),"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevationDrives"")
  |> filter(fn: (r) => r[""_field""] =~ /current*/)  

if v.aggregateFunction == ""min"" then 
  data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
else if v.aggregateFunction == ""max"" then 
  data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
else if v.aggregateFunction == ""mean"" then 
  data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
else if v.aggregateFunction == ""spread"" then 
  data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
else 
  data
",flux
M1M3 inclinometer angle (:aggregateFunction:),"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.inclinometerData"")
  |> filter(fn: (r) => r[""_field""] == ""inclinometerAngle"")
  
if v.aggregateFunction == ""min"" then 
  data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
else if v.aggregateFunction == ""max"" then 
  data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
else if v.aggregateFunction == ""mean"" then 
  data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
else if v.aggregateFunction == ""spread"" then 
  data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
else 
  data",flux
TMA Elevation Actual Torque using (:aggregateFunction:),"
data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevation"")
  |> filter(fn: (r) => r[""_field""] == ""actualTorque"")
  
 
if v.aggregateFunction == ""min"" then 
  data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
else if v.aggregateFunction == ""max"" then 
  data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
else if v.aggregateFunction == ""mean"" then 
  data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
else if v.aggregateFunction == ""spread"" then 
  data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
else 
  data",flux
TMA Actual Azimuth using (:aggregateFunction:),"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.azimuth"")
  |> filter(fn: (r) => r[""_field""] == ""actualPosition"")
  
 
if v.aggregateFunction == ""min"" then 
  data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
else if v.aggregateFunction == ""max"" then 
  data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
else if v.aggregateFunction == ""mean"" then 
  data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
else if v.aggregateFunction == ""spread"" then 
  data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
else 
  data",flux
Acceleration TEA sensor,"SELECT ""accelerationX0"", ""accelerationY0"", ""accelerationZ0"" FROM ""efd"".""autogen"".""lsst.sal.ESS.accelerometer"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:  AND ""sensorName"" = 'SST spider spindle'",influxql
Acceleration Leg +X sensor,"SELECT ""accelerationX0"", ""accelerationY0"", ""accelerationZ0"" FROM ""efd"".""autogen"".""lsst.sal.ESS.accelerometer"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND ""sensorName"" = 'SST top end ring -x -y'",influxql
Acceleration Leg -X sensor,"SELECT ""accelerationX0"", ""accelerationY0"", ""accelerationZ0"" FROM ""efd"".""autogen"".""lsst.sal.ESS.accelerometer"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:  AND ""sensorName"" = 'SST top end ring +x -y'",influxql
Acceleration M2 Surrogate sensor,"SELECT ""accelerationX0"", ""accelerationY0"", ""accelerationZ0"" FROM ""efd"".""autogen"".""lsst.sal.ESS.accelerometer"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND ""sensorName"" = 'SST spider spindle'",influxql
DC Angular Accerations,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] =~ /^angularAcceleration[XYZ]$/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
Applied Balance Forces,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.appliedBalanceForces"")
  |> filter(fn: (r) => r[""_field""] =~ /^[fm][xyz]$/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Force Actuator Measured forces,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /^[fm][xyz]$/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Applied Velocity Forces,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.appliedVelocityForces"")
  |> filter(fn: (r) => r[""_field""] =~ /^[fm][xyz]$/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Applied Acceleration Forces,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.appliedAccelerationForces"")
  |> filter(fn: (r) => r[""_field""] =~ /^[fm][xyz]$/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoints Forces and Moments,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /^[fm][xyz]$/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoints Load Cell Forces,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /measuredForce./)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
Hardpoints Load Cell Forces - max,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /measuredForce./)
  |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)

data",flux
TMA Azimuth velocity,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.azimuth"")
  |> filter(fn: (r) => r[""_field""] == ""actualVelocity"" or r[""_field""] == ""demandVelocity"")
  

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
TMA Elevation acceleration,"import ""math""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevation"")
  |> filter(fn: (r) => r[""_field""] == ""actualVelocity"" or r[""_field""] == ""demandVelocity"" or r[""_field""] == ""timestamp"")
  |> difference()  
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> map(fn: (r) => ({_time: r._time, demandAcceleration: r.demandVelocity / r.timestamp, actualAcceleration: r.actualVelocity / r.timestamp}) )
  

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false, column: ""actualAcceleration"")      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false, column: ""actualAcceleration"")
    else 
      data",flux
TMA Azimuth acceleration,"import ""math""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.azimuth"")
  |> filter(fn: (r) => r[""_field""] == ""actualVelocity"" or r[""_field""] == ""demandVelocity"" or r[""_field""] == ""timestamp"")
  |> difference()  
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> map(fn: (r) => ({_time: r._time, demandAcceleration: r.demandVelocity / r.timestamp, actualAcceleration: r.actualVelocity / r.timestamp}) )
  

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false, column: ""actualAcceleration"")      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false, column: ""actualAcceleration"")
    else 
      data",flux
TMA Elevation velocity,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevation"")
  |> filter(fn: (r) => r[""_field""] == ""actualVelocity"" or r[""_field""] == ""demandVelocity"" )

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoints Load Cell Forces - min,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /measuredForce./)
  |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)

data",flux
TMA Elevation,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevation"")
  |> filter(fn: (r) => r[""_field""] == ""actualPosition"" or r[""_field""] == ""demandPosition"")

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
TMA Azimuth,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.azimuth"")
  |> filter(fn: (r) => r[""_field""] == ""actualPosition"")

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Inclinometer angle,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.inclinometerData"")
  |> filter(fn: (r) => r[""_field""] == ""inclinometerAngle"")
  

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
"Actuator steps B1, B3, B15 (ID 0, 2, 14) ","SELECT mean(""axialAbsolutePositionSteps0"") AS ""mean_axialAbsolutePositionSteps0"", mean(""axialAbsolutePositionSteps2"") AS ""mean_axialAbsolutePositionSteps2"", mean(""axialAbsolutePositionSteps14"") AS ""mean_axialAbsolutePositionSteps14"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.axialActuatorAbsolutePositionSteps"" WHERE :m2_test: GROUP BY time(1s)",influxql
"Axial actuator D1, D10, D17 (55, 64, 71) ","SELECT mean(""axialForceMeasured55"") AS ""mean_axialForceMeasured55"",mean(""axialForceMeasured64"") AS ""mean_axialForceMeasured64"",mean(""axialForceMeasured71"") AS ""mean_axialForceMeasured71"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.axialForcesMeasured"" WHERE :m2_test: GROUP BY time(1s)",influxql
"Axial actuator C6, C8, C18 (ID 36, 38, 48) ","SELECT mean(""axialForceMeasured36"") AS ""mean_axialForceMeasured36"", mean(""axialForceMeasured38"") AS ""mean_axialForceMeasured38"", mean(""axialForceMeasured48"") AS ""mean_axialForceMeasured48"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.axialForcesMeasured"" WHERE :m2_test: GROUP BY time(1s)",influxql
Tangent Actuators,"SELECT mean(""tangentLink0DegForceMeasured"") AS ""mean_tangentLink0DegForceMeasured"", mean(""tangentLink120DegForceMeasured"") AS ""mean_tangentLink120DegForceMeasured"", mean(""tangentLink180DegForceMeasured"") AS ""mean_tangentLink180DegForceMeasured"", mean(""tangentLink240DegForceMeasured"") AS ""mean_tangentLink240DegForceMeasured"", mean(""tangentLink300DegForceMeasured"") AS ""mean_tangentLink300DegForceMeasured"", mean(""tangentLink60DegForceMeasured"") AS ""mean_tangentLink60DegForceMeasured"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.tangentForcesMeasured"" WHERE :m2_test: GROUP BY time(1s)",influxql
"Actuator B1, B3, B15 (ID 0, 2, 14)","SELECT mean(""axialForceMeasured1"") AS ""mean_axialForceMeasured1"", mean(""axialForceMeasured2"") AS ""mean_axialForceMeasured2"", mean(""axialForceMeasured14"") AS ""mean_axialForceMeasured14"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.axialForcesMeasured"" WHERE :m2_test: GROUP BY time(1s)",influxql
Tangent force steps,"SELECT mean(""tangentLink0DegAbsolutePositionSteps"") AS ""mean_tangentLink0DegAbsolutePositionSteps"", mean(""tangentLink120DegAbsolutePositionSteps"") AS ""mean_tangentLink120DegAbsolutePositionSteps"", mean(""tangentLink180DegAbsolutePositionSteps"") AS ""mean_tangentLink180DegAbsolutePositionSteps"", mean(""tangentLink240DegAbsolutePositionSteps"") AS ""mean_tangentLink240DegAbsolutePositionSteps"", mean(""tangentLink300DegAbsolutePositionSteps"") AS ""mean_tangentLink300DegAbsolutePositionSteps"", mean(""tangentLink60DegAbsolutePositionSteps"") AS ""mean_tangentLink60DegAbsolutePositionSteps"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.tangentActuatorAbsolutePositionSteps"" WHERE :m2_test: GROUP BY time(1s)",influxql
M2 Zenith Angle,"SELECT mean(""zenithAngleMeasured"") AS ""mean_zenithAngleMeasured"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.zenithAngleMeasured"" WHERE :m2_test: GROUP BY time(1s)",influxql
"De energization (B6, C4, D4)","SELECT mean(""axialForceMeasured5"") AS ""mean_axialForceMeasured5"", mean(""axialForceMeasured57"") AS ""mean_axialForceMeasured57"", mean(""axialForceMeasured33"") AS ""mean_axialForceMeasured33"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.axialForcesMeasured"" WHERE :m2_test: GROUP BY time(1s)",influxql
"Axial actuator 20 lutGravity20"" + ""lutTemperature20"" + ""applied20"" + ""hardpointCorrection20"" - ""measured20""","SELECT (""lutGravity20"" + ""lutTemperature20"" + ""applied20"" + ""hardpointCorrection20"" - ""measured20"") FROM ""efd"".""autogen"".""lsst.sal.MTM2.axialForce"" WHERE time >= ':test_start:' AND time <= ':test_end:'",influxql
STANDBY,"// STANDBY = 5

import ""strings"" 

from(bucket: ""efd/autogen"")
  |> range(start: -inf)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.CC.*.logevent_summaryState/ and (r._field == ""summaryState""))
  |> last()
  |> map(fn: (r) => ({
    r with
    state_count:
      if r._value == 5 then 1 else 0
    })
  )
  |> group()
  |> sum(column: ""state_count"")
 

  
 ",flux
ComCam CSC State transitions,"// CSC state
// STANDBY = 5
// OFFLINE = 4
// FAULT = 3
// ENABLED = 2
// DISABLED = 1

import ""strings""

from(bucket: ""efd/autogen"")
  |> range(start: dashboardTime)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.CC.*.logevent_summaryState/ and (r._field == ""summaryState""))
  |> map(fn: (r) => ({
    r with
    csc: strings.split(v: r._measurement, t: ""."")[2],
    state: r._value
  }))
  |> group(columns: [""csc""])
  |> keep(columns: [""_time"", ""csc"", ""state""])
 
",flux
ENABLED,"// ENABLED = 2 

import ""strings"" 

from(bucket: ""efd/autogen"")
  |> range(start: -inf)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.CC.*.logevent_summaryState/ and (r._field == ""summaryState""))
  |> last()
  |> map(fn: (r) => ({
    r with
    state_count:
      if r._value == 2 then 1 else 0
    })
  )
  |> group()
  |> sum(column: ""state_count"")
 

  
 ",flux
FAULT,"// FAULT = 3 

import ""strings"" 

from(bucket: ""efd/autogen"")
  |> range(start: -inf)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.CC.*.logevent_summaryState/ and (r._field == ""summaryState""))
  |> last()
  |> map(fn: (r) => ({
    r with
    state_count:
      if r._value == 3 then 1 else 0
    })
  )
  |> group()
  |> sum(column: ""state_count"")
 

  
 ",flux
ComCam CSCs,"import ""strings"" 

from(bucket: ""efd/autogen"")
  |> range(start: -inf)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.CC.*.logevent_summaryState/ and (r._field == ""summaryState""))
  |> last()
  |> group()
  |> count()
  
 ",flux
ComCam CSCs Current State,"// CSC states
// STANDBY = 5
// OFFLINE = 4
// FAULT = 3
// ENABLED = 2
// DISABLED = 1

import ""strings""

from(bucket: ""efd/autogen"")
  |> range(start: -inf)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.CC.*.logevent_summaryState/ and (r._field == ""summaryState""))
  |> last()
  |> map(fn: (r) => ({
    r with
    csc: strings.split(v: r._measurement, t: ""."")[2],
    state:
      if r._value == 5 then ""5 (STANDBY)""
      else if r._value == 4 then ""4 (OFFLINE)""
      else if r._value == 3 then ""3 (FAULT)""
      else if r._value == 2 then ""2 (ENABLED)""
      else if r._value == 1 then ""1 (DISABLED)""
      else ""UNKNOWN"",
    duration: strings.splitAfter(v: string(v: duration(v: uint(v: r._stop) - uint(v: r._time))), t: ""m"")[0]

    })
  )
  |> keep(columns: [""csc"", ""state"", ""_time"", ""duration""])
 
",flux
Glycol delivered temp vs. ambient,"SELECT mean(""glycolTemperaturePier0001"") AS ""generalglycolTemperaturePier0001"", mean(""glycolTemperaturePier0002"") AS ""generalglycolTemperaturePier0002"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.generalPurposeGlycolWater"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Glycol delivered temp vs. ambient,"SELECT mean(""ambientTemperature"") AS ""Azimuth Floor air temp"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.topEndChiller"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Glycol delivered temp vs. ambient,"SELECT mean(""glycolTemperaturePier0101"") AS ""coldglycolTemperaturePier0101"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.cooling"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""temperatureItem0"") AS ""Outside air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""temperatureItem0"") AS ""Camera air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 111 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""temperatureItem0"") AS ""M2 air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 112 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""temperatureItem0"") AS ""M1M3 air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 113 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""mainCabinetExternalTemperature"") AS ""Tekniker Cabinet External air temp"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.mainCabinetThermal"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""ambientTemperature"") AS ""Azimuth Floor air temp"", mean(""ambientTemperatureSensor0502"") AS ""Top End Hex Return air temp"", mean(""temperatureSensor0501"") AS ""Top End Rear air temp"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.topEndChiller"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Outside Temp/Dew Point,"SELECT ""temperatureItem0"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Outside Temp/Dew Point,"SELECT ""dewPointItem"" FROM ""efd"".""autogen"".""lsst.sal.ESS.dewPoint"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTDome-ESS01 - ESSID 111 - M1M3 air temp/humidity - RPi Sticker 3,"SELECT ""temperatureItem0"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 111 and time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
MTDome-ESS01 - ESSID 111 - M1M3 air temp/humidity - RPi Sticker 3,"SELECT ""relativeHumidityItem"" FROM ""efd"".""autogen"".""lsst.sal.ESS.relativeHumidity"" WHERE salIndex = 111 and time > :dashboardTime: AND time < :upperDashboardTime:
",influxql
MTDome-ESS01 - ESSID 111 - M1M3 air temp/humidity - RPi Sticker 3,"SELECT ""dewPointItem"" FROM ""efd"".""autogen"".""lsst.sal.ESS.dewPoint"" WHERE salIndex = 111 and time > :dashboardTime: AND time < :upperDashboardTime:
",influxql
MTDome-ESS02 - ESSID 112 - M2 air temp/humidity - RPi Sticker 1,"SELECT ""temperatureItem0"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 112 and time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
MTDome-ESS02 - ESSID 112 - M2 air temp/humidity - RPi Sticker 1,"SELECT relativeHumidityItem FROM ""efd"".""autogen"".""lsst.sal.ESS.relativeHumidity"" WHERE salIndex = 112 and time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
MTDome-ESS02 - ESSID 112 - M2 air temp/humidity - RPi Sticker 1,"SELECT dewPointItem FROM ""efd"".""autogen"".""lsst.sal.ESS.dewPoint"" WHERE salIndex = 112 and time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
MTDome Humidity - ESSID 113 - camera air temp/humidity/baro - RPi w/ Sticker 4,"SELECT ""temperatureItem0"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 113 and time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
MTDome Humidity - ESSID 113 - camera air temp/humidity/baro - RPi w/ Sticker 4,"SELECT relativeHumidityItem FROM ""efd"".""autogen"".""lsst.sal.ESS.relativeHumidity"" WHERE salIndex = 113 and time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
MTDome Humidity - ESSID 113 - camera air temp/humidity/baro - RPi w/ Sticker 4,"SELECT dewPointItem FROM ""efd"".""autogen"".""lsst.sal.ESS.dewPoint"" WHERE salIndex = 113 and time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
MTDome-ESS03 - ESSID 113 Air Pressure,"SELECT ""pressureItem0"" / 100 as ""barometricPressure [mbar]"" FROM ""efd"".""autogen"".""lsst.sal.ESS.pressure"" WHERE salIndex = 113 and time > :dashboardTime: AND time < :upperDashboardTime: and ""pressureItem0"" / 100 > 710
",influxql
ForceActuator primary cylinder following error,"SELECT ""primaryCylinderFollowingError:z_index:"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.forceActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
ForceActuator primary cylinder force,"SELECT ""primaryCylinderForce:z_index:"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.forceActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
ForceActuator secondary cylinder force,"SELECT ""secondaryCylinderForce:s_index:"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.forceActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
yForces,"SELECT ""yForce:y_index:"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.forceActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
yForces,"SELECT ""yForces:y_index:"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.appliedForces"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
zForces,"SELECT ""zForce:z_index:"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.forceActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
zForces,"SELECT ""zForces:z_index:"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.appliedForces"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
ForceActuator secondary cylinder following error,"SELECT ""secondaryCylinderFollowingError:s_index:"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.forceActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
xForces,"SELECT ""xForce:x_index:"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.forceActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
xForces,"SELECT ""xForces:x_index:"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.appliedForces"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
ID20 (LUT + hardpointCorrection - measured),"SELECT (""lutGravity20"" + ""lutTemperature20"" + ""hardpointCorrection20"" - ""measured20"") FROM ""efd"".""autogen"".""lsst.sal.MTM2.axialForce"" WHERE time >= ':test_start:' AND time <= ':test_end:'",influxql
ID20 (LUT + hardpointCorrection - measured),"SELECT (""lutGravity21"" + ""lutTemperature21"" + ""hardpointCorrection21"" - ""measured21"") FROM ""efd"".""autogen"".""lsst.sal.MTM2.axialForce"" WHERE time >= ':test_start:' AND time <= ':test_end:'",influxql
ID20 (LUT + hardpointCorrection - measured),"SELECT (""lutGravity2"" + ""lutTemperature2"" + ""hardpointCorrection2"" - ""measured2"") FROM ""efd"".""autogen"".""lsst.sal.MTM2.axialForce"" WHERE time >= ':test_start:' AND time <= ':test_end:'",influxql
Tangent Actuator 6 (ID 300deg) ,"SELECT mean(""tangentLink240DegForceMeasured"") AS ""mean_tangentLink240DegForceMeasured"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.tangentForcesMeasured"" WHERE time >= ':test_start:' AND time <= ':test_end:' GROUP BY time(1s)",influxql
Axial actuator D10 (64),"SELECT mean(""axialForceMeasured64"") AS ""mean_axialForceMeasured64"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.axialForcesMeasured"" WHERE time >= ':test_start:' AND time <= ':test_end:' GROUP BY time(1s)",influxql
Axial actuator D1 (55),"SELECT mean(""axialForceMeasured55"") AS ""mean_axialForceMeasured55"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.axialForcesMeasured"" WHERE time >= ':test_start:' AND time <= ':test_end:' GROUP BY time(1s)",influxql
Tangent Actuators,"SELECT mean(""tangentLink0DegForceMeasured"") AS ""mean_tangentLink0DegForceMeasured"", mean(""tangentLink120DegForceMeasured"") AS ""mean_tangentLink120DegForceMeasured"", mean(""tangentLink180DegForceMeasured"") AS ""mean_tangentLink180DegForceMeasured"", mean(""tangentLink240DegForceMeasured"") AS ""mean_tangentLink240DegForceMeasured"", mean(""tangentLink300DegForceMeasured"") AS ""mean_tangentLink300DegForceMeasured"", mean(""tangentLink60DegForceMeasured"") AS ""mean_tangentLink60DegForceMeasured"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.tangentForcesMeasured"" WHERE time >= ':test_start:' AND time <= ':test_end:' GROUP BY time(1s)",influxql
Tangent Actuator 3 (ID 120deg) ,"SELECT mean(""tangentLink120DegForceMeasured"") AS ""mean_tangentLink120DegForceMeasured"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.tangentForcesMeasured"" WHERE time >= ':test_start:' AND time <= ':test_end:' GROUP BY time(1s)",influxql
Tangent Actuator 4 (ID 180deg) ,"SELECT mean(""tangentLink180DegForceMeasured"") AS ""mean_tangentLink180DegForceMeasured"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.tangentForcesMeasured"" WHERE time >= ':test_start:' AND time <= ':test_end:' GROUP BY time(1s)",influxql
Tangent Actuator 5 (ID 240deg) ,"SELECT mean(""tangentLink240DegForceMeasured"") AS ""mean_tangentLink240DegForceMeasured"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.tangentForcesMeasured"" WHERE time >= ':test_start:' AND time <= ':test_end:' GROUP BY time(1s)",influxql
Tangent Actuator 2 (ID 60deg),"SELECT mean(""tangentLink60DegForceMeasured"") AS ""mean_tangentLink60DegForceMeasured"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.tangentForcesMeasured"" WHERE time >= ':test_start:' AND time <= ':test_end:' GROUP BY time(1s)",influxql
Axial actuator C6 (ID 36),"SELECT mean(""axialForceMeasured36"") AS ""mean_axialForceMeasured36"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.axialForcesMeasured"" WHERE time >= ':test_start:' AND time <= ':test_end:' GROUP BY time(1s)",influxql
Actuator B15 (ID 14) ,"SELECT mean(""axialForceMeasured14"") AS ""mean_axialForceMeasured14"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.axialForcesMeasured"" WHERE time >= ':test_start:' AND time <= ':test_end:' GROUP BY time(1s)",influxql
Axial actuator C18 (48),"SELECT mean(""axialForceMeasured48"") AS ""mean_axialForceMeasured48"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.axialForcesMeasured"" WHERE time >= ':test_start:' AND time <= ':test_end:' GROUP BY time(1s)",influxql
Tangent Actuator 1 (ID 0deg),"SELECT mean(""tangentLink0DegForceMeasured"") AS ""mean_tangentLink0DegForceMeasured"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.tangentForcesMeasured"" WHERE time >= ':test_start:' AND time <= ':test_end:' GROUP BY time(1s)",influxql
Actuator B2 (ID 1),"SELECT mean(""axialForceMeasured1"") AS ""mean_axialForceMeasured1"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.axialForcesMeasured"" WHERE time >= ':test_start:' AND time <= ':test_end:' GROUP BY time(1s)",influxql
Tangent force steps,"SELECT mean(""tangentLink0DegAbsolutePositionSteps"") AS ""mean_tangentLink0DegAbsolutePositionSteps"", mean(""tangentLink120DegAbsolutePositionSteps"") AS ""mean_tangentLink120DegAbsolutePositionSteps"", mean(""tangentLink180DegAbsolutePositionSteps"") AS ""mean_tangentLink180DegAbsolutePositionSteps"", mean(""tangentLink240DegAbsolutePositionSteps"") AS ""mean_tangentLink240DegAbsolutePositionSteps"", mean(""tangentLink300DegAbsolutePositionSteps"") AS ""mean_tangentLink300DegAbsolutePositionSteps"", mean(""tangentLink60DegAbsolutePositionSteps"") AS ""mean_tangentLink60DegAbsolutePositionSteps"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.tangentActuatorAbsolutePositionSteps"" WHERE time >= ':test_start:' AND time <= ':test_end:' GROUP BY time(1s)",influxql
ESS:112 (m2- Not available yet),"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ESS.logevent_summaryState"" WHERE salIndex = 112 ORDER BY time DESC LIMIT 1",influxql
ESS:113 (m1m3),"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ESS.logevent_summaryState"" WHERE salIndex = 113 ORDER BY time DESC LIMIT 1",influxql
ESS:111 (camera),"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ESS.logevent_summaryState"" WHERE salIndex = 111 ORDER BY time DESC LIMIT 1",influxql
ESS:109,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ESS.logevent_summaryState"" WHERE salIndex = 109 ORDER BY time DESC LIMIT 1",influxql
ESS:202,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ESS.logevent_summaryState"" WHERE salIndex = 202 ORDER BY time DESC LIMIT 1",influxql
WeatherForecast,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.WeatherForecast.logevent_summaryState"" ORDER BY time DESC LIMIT 1",influxql
HVAC,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.logevent_summaryState"" ORDER BY time DESC LIMIT 1",influxql
ESS:103,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ESS.logevent_summaryState"" WHERE salIndex = 103 ORDER BY time DESC LIMIT 1",influxql
ESS:201,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ESS.logevent_summaryState"" WHERE salIndex = 201 ORDER BY time DESC LIMIT 1",influxql
ESS:102 -> ESS:112,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ESS.logevent_summaryState"" WHERE salIndex = 102 ORDER BY time DESC LIMIT 1",influxql
ESS:101 -> ESS:111,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ESS.logevent_summaryState"" WHERE salIndex = 101 ORDER BY time DESC LIMIT 1",influxql
DSM:1,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.DSM.logevent_summaryState"" WHERE ""salIndex"" = 1 ORDER BY DESC LIMIT 1",influxql
DIMM:1,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.DIMM.logevent_summaryState"" WHERE ""salIndex"" = 1 ORDER BY DESC LIMIT 1",influxql
DSM:2,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.DSM.logevent_summaryState"" WHERE ""salIndex"" = 2 ORDER BY DESC LIMIT 1",influxql
DIMM:2,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.DIMM.logevent_summaryState"" WHERE ""salIndex"" = 2 ORDER BY DESC LIMIT 1",influxql
ESS:1,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ESS.logevent_summaryState"" WHERE salIndex = 1 ORDER BY time DESC LIMIT 1",influxql
ESS:301,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ESS.logevent_summaryState"" WHERE salIndex = 301 ORDER BY time DESC LIMIT 1",influxql
CCW current values,"SELECT current0, current1 FROM ""efd"".""autogen"".""lsst.sal.MTMount.cameraCableWrap"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
"CCW actual Position, Velocity, Acceleration","SELECT ""actualPosition"", ""actualAcceleration"", ""actualVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.cameraCableWrap"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Position 1,"SELECT ""actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.cameraCableWrap"" WHERE time > :dashboardTime:",influxql
Position 1,"SELECT ""actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.rotation"" WHERE time > :dashboardTime: ",influxql
Untitled Graph,"SELECT ""code"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_error"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Untitled Graph,"SELECT ""text"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_error"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Untitled Graph,"SELECT ""limits"", ""private_efdStamp"", ""private_identity"", ""private_kafkaStamp"", ""private_rcvStamp"", ""private_sndStamp"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_cameraCableWrapLimits"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Z Angular Acceleration (deg/s2) ,"SELECT mean(""angularAccelerationZ"") AS ""mean_angularAccelerationZ"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.accelerometerData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Y Angular Acceleration (deg/s2) ,"SELECT mean(""angularAccelerationY"") AS ""mean_angularAccelerationY"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.accelerometerData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Test: X Angular acc deg/s2 (from Ac4Y and Ac3Y) ,"import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] =~ /rawAccelerometer[57]/)
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> map(fn: (r) => ({r with _value:((((r.rawAccelerometer7-0.0179)/1.992)-((r.rawAccelerometer5-0.0170)/1.996))*1.051*9.8*57.3)}))


if v.Function == ""Raw"" then
  data |> drop(columns: [""rawAccelerometer2"", ""rawAccelerometer6""])
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Test: Z Angular acc deg/s2 (from Ac4X and Ac2X),"import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] =~ /rawAccelerometer[62]/)
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> map(fn: (r) => ({r with _value:((((r.rawAccelerometer2-0.0125)/1.994)-((r.rawAccelerometer6+0.0108)/1.994))*0.2353*9.8*57.3)}))


if v.Function == ""Raw"" then
  data |> drop(columns: [""rawAccelerometer2"", ""rawAccelerometer6""])
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Test: Y angular acc deg/s2 (from Ac2X and Ac1X),"import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] =~ /rawAccelerometer[02]/)
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> map(fn: (r) => ({r with _value:((((r.rawAccelerometer2-0.0125)/1.994)-((r.rawAccelerometer0-0.0090)/1.993))*1.051*9.8*57.3)})) 


if v.Function == ""Raw"" then
  data |> drop(columns: [""rawAccelerometer5"", ""rawAccelerometer7""])
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
TMA Azimuth acceleration,"import ""math""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.azimuth"")
  |> filter(fn: (r) => r[""_field""] == ""actualVelocity"" or r[""_field""] == ""demandVelocity"" or r[""_field""] == ""timestamp"")
  |> difference()  
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> map(fn: (r) => ({_time: r._time, demandAcceleration: r.demandVelocity / r.timestamp, actualAcceleration: r.actualVelocity / r.timestamp}) )
  

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false, column: ""actualAcceleration"")      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false, column: ""actualAcceleration"")
    else 
      data",flux
Mount Azimuth,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Mount Elevation,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
TMA Elevation acceleration,"import ""math""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevation"")
  |> filter(fn: (r) => r[""_field""] == ""actualVelocity"" or r[""_field""] == ""demandVelocity"" or r[""_field""] == ""timestamp"")
  |> difference()  
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> map(fn: (r) => ({_time: r._time, demandAcceleration: r.demandVelocity / r.timestamp, actualAcceleration: r.actualVelocity / r.timestamp}) )
  

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false, column: ""actualAcceleration"")      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false, column: ""actualAcceleration"")
    else 
      data",flux
Hardpoints Forces,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /measuredForce./)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Inclinometer angle,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.inclinometerData"")
  |> filter(fn: (r) => r[""_field""] == ""inclinometerAngle"")
  

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
X Angular Acceleration (deg/s2) ,"SELECT mean(""angularAccelerationX"") AS ""mean_angularAccelerationX"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.accelerometerData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Rotator Status,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.Rotator.logevent_summaryState"" WHERE time >= :test_start: AND time <= :test_end:",influxql
CCW Status,"SELECT ""CCW_Status"" AS ""CCW_Status"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.Camera_Cable_Wrap"" WHERE time >= :test_start: AND time <= :test_end:",influxql
CCW Rotator Position(CCW),"SELECT mean(""CCW_Angle_1""), mean(""CCW_Angle_2"") FROM ""efd"".""autogen"".""lsst.sal.MTMount.Camera_Cable_Wrap"" WHERE time >= :test_start: AND time <= :test_end: GROUP BY time(1s)",influxql
Rotator Position and Demand,"SELECT mean(""Demand""), mean(""Position"") FROM ""efd"".""autogen"".""lsst.sal.Rotator.Application"" WHERE time >= :test_start: AND time <= :test_end: GROUP BY time(1s)",influxql
Pointing Model,"SELECT mean(""angle"") FROM ""efd"".""autogen"".""lsst.sal.Rotator.command_track"" WHERE time >= :test_start: AND time <= :test_end: GROUP BY time(1s)",influxql
TEST END,"SELECT ""message"" FROM ""efd"".""autogen"".""lsst.sal.Script.logevent_logMessage"" WHERE message =~ /END/ order by desc",influxql
TEST START,"SELECT ""message"" FROM ""efd"".""autogen"".""lsst.sal.Script.logevent_logMessage"" WHERE message =~ /START/ order by desc",influxql
Watcher History,"SELECT ""reason"" AS ""reason"" FROM ""efd"".""autogen"".""lsst.sal.Watcher.logevent_alarm"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Watcher History,"SELECT ""severity"" AS ""severity"" FROM ""efd"".""autogen"".""lsst.sal.Watcher.logevent_alarm"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Watcher History,"SELECT ""name"" AS ""name"" FROM ""efd"".""autogen"".""lsst.sal.Watcher.logevent_alarm"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
ATMCS-Tracking,"SELECT ""state"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.logevent_atMountState"" ORDER BY DESC LIMIT 1",influxql
GenericCamera:1,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.GenericCamera.logevent_summaryState"" WHERE ""salIndex"" = 1 ORDER BY DESC LIMIT 1",influxql
ATAOS,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATHexapod,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATHexapod.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATDome,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATDome.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATPtg,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATPtg.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATDomeTrajectory,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATDomeTrajectory.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATMCS,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATMonochromator,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATMonochromator.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATHeaderService,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATHeaderService.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATArchiver,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATArchiver.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATCamera,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
Electrometer,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.Electrometer.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATSpectrograph,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATSpectrograph.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATPneumatics,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATPneumatics.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
FiberSpectrograph,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.FiberSpectrograph.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
Scheduler,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.Scheduler.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
OCPS,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.OCPS.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
Comatic modes,"SELECT ""aggregatedDoF35"" AS ""M2 B6"", ""aggregatedDoF36"" AS ""M2 B7"", ""aggregatedDoF48"" AS ""M2 B19"", ""aggregatedDoF49"" AS ""M2 B20"", ""aggregatedDoF15"" AS ""M1M3 B6"", ""aggregatedDoF16"" AS ""M1M3 B7"",""aggregatedDoF24"" AS ""M1M3 B15"", ""aggregatedDoF25"" AS ""M1M3 B16"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_degreeOfFreedom"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Spherical-like modes,"SELECT ""aggregatedDoF12"" AS ""M1M3 B3"", ""aggregatedDoF21"" AS ""M1M3 B12"", ""aggregatedDoF34"" AS ""M2 B5"", ""aggregatedDoF47"" AS ""M2 B18"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_degreeOfFreedom"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Trefoil-like modes,"SELECT ""aggregatedDoF13"" AS ""M1M3 B4"", ""aggregatedDoF14"" AS ""M1M3 B5"", ""aggregatedDoF32"" AS ""M2 B3"", ""aggregatedDoF33"" AS ""M2 B4"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_degreeOfFreedom"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Astigmatism-like modes,"SELECT ""aggregatedDoF10"" AS ""M1M3 B1"", ""aggregatedDoF11"" AS ""M1M3 B2"", ""aggregatedDoF30"" AS ""M2 B1"", ""aggregatedDoF31"" AS ""M2 B2"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_degreeOfFreedom"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Pistoning,"SELECT ""aggregatedDoF0"" AS ""M2 dZ"", ""aggregatedDoF5"" AS ""Camera dZ"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_degreeOfFreedom"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Decenterings,"SELECT ""aggregatedDoF1"" AS ""M2 dX"", ""aggregatedDoF2"" AS ""M2 dY"", ""aggregatedDoF6"" AS ""Camera dX"", ""aggregatedDoF7"" AS ""Camera dY"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_degreeOfFreedom"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Untitled Graph,"SELECT ""annularZernikeCoeff0"", ""annularZernikeCoeff1"", ""annularZernikeCoeff10"", ""annularZernikeCoeff12"", ""annularZernikeCoeff11"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_wavefrontError"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Tips and Tilts,"SELECT ""aggregatedDoF3"" AS ""M2 dRX"", ""aggregatedDoF4"" AS ""M2 dRY"", ""aggregatedDoF8"" AS ""Camera dRX"", ""aggregatedDoF9"" AS ""Camera dRY"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_degreeOfFreedom"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Quadrafoil modes,"SELECT ""aggregatedDoF17"" AS ""M1M3 B8"", ""aggregatedDoF18"" AS ""M1M3 B9"", ""aggregatedDoF37"" AS ""M2 B8"", ""aggregatedDoF38"" AS ""M2 B9"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_degreeOfFreedom"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Pentafoil modes,"SELECT ""aggregatedDoF24"" AS ""M1M3 B13"", ""aggregatedDoF25"" AS ""M1M3 B14"", ""aggregatedDoF41"" AS ""M2 B12"", ""aggregatedDoF42"" AS ""M2 B13"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_degreeOfFreedom"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Untitled Graph,"SELECT mean(""actualVelocity"") AS ""mean_actualVelocity"", mean(""demandVelocity"") AS ""mean_demandVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Untitled Graph,"SELECT mean(""demandVelocity"") AS ""mean_demandVelocity"", mean(""actualVelocity"") AS ""mean_actualVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Applied Balance Forces,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.appliedBalanceForces"")
  |> filter(fn: (r) => r[""_field""] =~ /^[fm][xyz]$/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoints Forces and Moments,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /^[fm][xyz]$/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Untitled Graph,"SELECT ""ra"", ""declination"", ""positionAngle"", ""parallacticAngle""  FROM ""efd"".""autogen"".""lsst.sal.Scheduler.observatoryState"" ORDER BY time DESC LIMIT 10",influxql
Scheduler.logevent_detailedState,"SELECT ""salIndex"" AS ""mean_salIndex"" FROM ""efd"".""autogen"".""lsst.sal.Scheduler.logevent_detailedState"" ORDER BY time DESC LIMIT 10",influxql
Untitled Graph,"SELECT ""isNight"" FROM ""efd"".""autogen"".""lsst.sal.Scheduler.logevent_generalInfo"" ORDER BY time DESC LIMIT 10",influxql
needFilterSwap,"SELECT ""needSwap"" FROM ""efd"".""autogen"".""lsst.sal.Scheduler.logevent_needFilterSwap"" ORDER BY time DESC LIMIT 10",influxql
Untitled Graph,"SELECT ""message"", ""name"" FROM ""efd"".""autogen"".""lsst.sal.Scheduler.logevent_logMessage"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Offline State,"SELECT ""substate"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.logevent_offlineDetailedState"" ORDER BY DESC LIMIT 1",influxql
Image Readiness,"SELECT ""substate"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.logevent_imageReadinessDetailedState"" ORDER BY DESC LIMIT 1",influxql
Rafts,"SELECT ""substate"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.logevent_raftsDetailedState"" ORDER BY DESC LIMIT 1",influxql
Calibration,"SELECT ""substate"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.logevent_calibrationDetailedState"" ORDER BY DESC LIMIT 1",influxql
Shutter,"SELECT ""substate"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.logevent_shutterDetailedState"" ORDER BY DESC LIMIT 1",influxql
Ready To Take Images,"SELECT ""substate"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.logevent_ccsCommandState"" ORDER BY time DESC LIMIT 1",influxql
M1 Cover State,"SELECT (""state"") AS ""mean_state"" FROM ""efd"".""autogen"".""lsst.sal.ATPneumatics.logevent_m1CoverState"" ",influxql
Dome trajectory Enabled,"SELECT (""enabled"")FROM ""efd"".""autogen"".""lsst.sal.ATDomeTrajectory.logevent_followingMode"" ",influxql
Telescope All axes in position,"SELECT ""inPosition"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.logevent_allAxesInPosition"" ORDER BY time DESC LIMIT 1",influxql
ATAOS corrections enabled?,"SELECT ""atspectrograph"", ""hexapod"", ""m1"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_correctionEnabled"" ORDER BY DESC LIMIT 1",influxql
ATDome All axes in position,"SELECT ""inPosition"" FROM ""efd"".""autogen"".""lsst.sal.ATDome.logevent_allAxesInPosition"" ORDER BY time DESC LIMIT 1",influxql
DropOut Shutter Opening Percentage ,"SELECT (""dropoutDoorOpeningPercentage"") FROM ""efd"".""autogen"".""lsst.sal.ATDome.position"" ORDER BY time DESC LIMIT 1",influxql
Main Shutter Opening Percentage,"SELECT (""mainDoorOpeningPercentage"") FROM ""efd"".""autogen"".""lsst.sal.ATDome.position"" ORDER BY time DESC LIMIT 1",influxql
Dome Azimuth Position,"SELECT (""azimuthPosition"") FROM ""efd"".""autogen"".""lsst.sal.ATDome.position"" ORDER BY DESC LIMIT 1",influxql
ATMCS-Tracking,"SELECT ""state"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.logevent_atMountState"" ORDER BY DESC LIMIT 1",influxql
Telescope Elevation,"SELECT ""elevationCalculatedAngle99"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.mount_AzEl_Encoders"" ORDER BY DESC LIMIT 1",influxql
Telescope Azimuth,"SELECT ""azimuthCalculatedAngle99"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.mount_AzEl_Encoders"" ORDER BY DESC LIMIT 1",influxql
ATAOS,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATHexapod,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATHexapod.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATDome,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATDome.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATPtg,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATPtg.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATDomeTrajectory,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATDomeTrajectory.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATMCS,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATHeaderService,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATHeaderService.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATArchiver,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATArchiver.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATCamera,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATSpectrograph,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATSpectrograph.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATPneumatics,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATPneumatics.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
Main Power Supply Voltage and Current  (clone 2),"SELECT mean(""powerSupplyCurrent"") AS ""mean_powerSupplyCurrent"", mean(""powerSupplyVoltage"") AS ""mean_powerSupplyVoltage"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.mainPowerSupply"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Main Power Supply Voltage and Current (clone 1),"SELECT mean(""powerSupplyCurrent"") AS ""mean_powerSupplyCurrent"", mean(""powerSupplyVoltage"") AS ""mean_powerSupplyVoltage"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.mainPowerSupply"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Main Power Supply Voltage and Current,"SELECT mean(""powerSupplyCurrent"") AS ""mean_powerSupplyCurrent"", mean(""powerSupplyVoltage"") AS ""mean_powerSupplyVoltage"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.mainPowerSupply"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
EL Torque,"SELECT mean(""actualTorque"") AS ""mean_actualTorque"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
AZ Torque,"SELECT mean(""actualTorque"") AS ""mean_actualTorque"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
EL Drives currents,"SELECT mean(""current0"") AS ""mean_current0"", mean(""current1"") AS ""mean_current1"", mean(""current10"") AS ""mean_current10"", mean(""current11"") AS ""mean_current11"", mean(""current2"") AS ""mean_current2"", mean(""current3"") AS ""mean_current3"", mean(""current4"") AS ""mean_current4"", mean(""current5"") AS ""mean_current5"", mean(""current6"") AS ""mean_current6"", mean(""current7"") AS ""mean_current7"", mean(""current8"") AS ""mean_current8"", mean(""current9"") AS ""mean_current9"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevationDrives"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
AZ Drives currents,"SELECT mean(""current0"") AS ""mean_current0"", mean(""current1"") AS ""mean_current1"", mean(""current10"") AS ""mean_current10"", mean(""current11"") AS ""mean_current11"", mean(""current12"") AS ""mean_current12"", mean(""current13"") AS ""mean_current13"", mean(""current14"") AS ""mean_current14"", mean(""current15"") AS ""mean_current15"", mean(""current2"") AS ""mean_current2"", mean(""current3"") AS ""mean_current3"", mean(""current4"") AS ""mean_current4"", mean(""current5"") AS ""mean_current5"", mean(""current6"") AS ""mean_current6"", mean(""current7"") AS ""mean_current7"", mean(""current8"") AS ""mean_current8"", mean(""current9"") AS ""mean_current9"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuthDrives"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
EL actual position and demand,"SELECT ""actualPosition"", ""demandPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
AZ actual position and demand,"SELECT ""actualPosition"", ""demandPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
EL actual velocity and demand,"SELECT ""actualVelocity"", ""demandVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
AZ actual velocity and demand,"SELECT ""actualVelocity"", ""demandVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Service timer,"SELECT ""lowestServiceCounter"" as ""lowestServiceCounter 1"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.logevent_timerInfo"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 1 FILL(null)",influxql
Service timer,"SELECT ""lowestServiceCounter"" as ""lowestServiceCounter 2"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.logevent_timerInfo"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 2 FILL(null)",influxql
Loaded hours,"SELECT ""loadedHours"" AS ""loadedHours 1"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.logevent_timerInfo"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 1 FILL(null)",influxql
Loaded hours,"SELECT ""loadedHours"" AS ""loadedHours 2"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.logevent_timerInfo"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 2 FILL(null)",influxql
Mount azimuth velocity,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.azimuth"")
  |> filter(fn: (r) => r[""_field""] =~ /(actual|demand)Velocity/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Mount elevation,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevation"")
  |> filter(fn: (r) => r[""_field""] =~ /(actual|demand)Position/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Z DC acceleration,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] == ""angularAccelerationZ"")


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Y DC acceleration,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] == ""angularAccelerationY"")


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
X DC acceleration,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] == ""angularAccelerationX"")


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Mount elevation velocity,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevation"")
  |> filter(fn: (r) => r[""_field""] =~ /(actual|demand)Velocity/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Z angular velocity,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.gyroData"")
  |> filter(fn: (r) => r[""_field""] == ""angularVelocityZ"")


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Y angular velocity,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.gyroData"")
  |> filter(fn: (r) => r[""_field""] == ""angularVelocityY"")


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
X angular velocity,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.gyroData"")
  |> filter(fn: (r) => r[""_field""] == ""angularVelocityX"")


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
19:00 hr Forecast,"SELECT mean(""temperature22"") AS ""mean_temperature22"" FROM ""efd"".""autogen"".""lsst.sal.WeatherForecast.hourlyTrend"" WHERE time > now() - 24h GROUP BY time(:interval:) FILL(previous)",influxql
Wind Speed,"SELECT ""speed"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Wind Direction,"SELECT mean(""direction"") AS ""mean_direction"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(previous)",influxql
M2 Air Temperature,"SELECT mean(""temperatureItem0"") AS ""M2 air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 112 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(previous)",influxql
M1M3 air Temperature,"SELECT mean(""temperatureItem0"") AS ""M1M3 air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 113 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(previous)",influxql
Outside,"SELECT mean(""temperatureItem0"") AS ""Outside air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(previous)",influxql
Ambient Air Temperature above M1M3 RoC (<1C/hr),"SELECT difference(last(""temperatureItem0"")) FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 113 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(1h)",influxql
M1M3 temps,"SELECT mean(""temperatureItem0"") AS ""Outside air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 temps,"SELECT mean(""temperatureItem0"") AS ""Camera air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 111 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 temps,"SELECT mean(""temperatureItem0"") AS ""M2 air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 112 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 temps,"SELECT mean(""temperatureItem0"") AS ""M1M3 air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 113 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 temps,"SELECT ""insideCellTemperature1"", ""insideCellTemperature2"", ""insideCellTemperature3"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.glycolLoopTemperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Glycol delivered temp vs. ambient,"SELECT mean(""glycolTemperaturePier0001"") AS ""Glycol General Temp 0001"", mean(""glycolTemperaturePier0002"") AS ""Glycol General Temp 0002"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.generalPurposeGlycolWater"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Glycol delivered temp vs. ambient,"SELECT mean(""ambientTemperature"") AS ""Azimuth Floor Air Ambient Temp"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.topEndChiller"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Glycol delivered temp vs. ambient,"SELECT mean(""glycolTemperaturePier0101"") AS ""Cold Glycol Temp 0101"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.cooling"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Glycol delivered temp vs. ambient,"SELECT mean(""absoluteTemperature0"") AS ""mean_absoluteTemperature0"", mean(""absoluteTemperature1"") AS ""mean_absoluteTemperature1"", mean(""absoluteTemperature10"") AS ""mean_absoluteTemperature10"", mean(""absoluteTemperature11"") AS ""mean_absoluteTemperature11"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.thermalData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""temperatureItem0"") AS ""Outside air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""temperatureItem0"") AS ""Camera air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 111 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""temperatureItem0"") AS ""M2 air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 112 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""temperatureItem0"") AS ""M1M3 air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 113 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""mainCabinetExternalTemperature"") AS ""Tekniker Cabinet External air temp"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.mainCabinetThermal"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""ambientTemperature"") AS ""Azimuth Floor Air Ambient Temp"", mean(""ambientTemperatureSensor0502"") AS ""Top End Hex Return air temp"", mean(""temperatureSensor0501"") AS ""Top End Rear air temp"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.topEndChiller"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Chiller 1/2,"SELECT mean(""setpointActivo"") AS ""mean_setpointActivo"", mean(""temperaturaAguaImpulsionEvaporador"") AS ""mean_temperaturaAguaImpulsionEvaporador"", mean(""temperaturaAguaRetornoEvaporador"") AS ""mean_temperaturaAguaRetornoEvaporador"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.chiller01P01"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Chiller 1/2,"SELECT mean(""setpointActivo"") AS ""mean_setpointActivo"", mean(""temperaturaAguaImpulsionEvaporador"") AS ""mean_temperaturaAguaImpulsionEvaporador"", mean(""temperaturaAguaRetornoEvaporador"") AS ""mean_temperaturaAguaRetornoEvaporador"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.chiller02P01"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Chiller 3,"SELECT mean(""setpointActivo"") AS ""mean_setpointActivo"", mean(""temperaturaAguaImpulsionEvaporador"") AS ""mean_temperaturaAguaImpulsionEvaporador"", mean(""temperaturaAguaRetornoEvaporador"") AS ""mean_temperaturaAguaRetornoEvaporador"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.chiller03P01"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Outside Temperature RoC (<1.0C/hr),"SELECT difference(last(""temperatureItem0"")) FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(1h)",influxql
Outside Temperature RoC (1 min sampling),"SELECT difference(last(""temperatureItem0"")) FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(1m)",influxql
18:00 hr Forecast,"SELECT mean(""temperature21"") AS ""mean_temperature21"" FROM ""efd"".""autogen"".""lsst.sal.WeatherForecast.hourlyTrend"" WHERE time > now() - 24h GROUP BY time(:interval:) FILL(previous)",influxql
 Buffer size (messages),"SELECT mean(""buffer_size"") AS ""mean_buffer_size"" FROM ""telegraf"".""autogen"".""telegraf_internal_write"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:), ""instance"" FILL(null)",influxql
Parser errors,"SELECT mean(""errors"") AS ""mean_errors"" FROM ""telegraf"".""autogen"".""telegraf_internal_parser"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:), ""instance"" FILL(null)",influxql
Memory usage (bytes),"SELECT mean(""alloc_bytes"") AS ""mean_alloc_bytes"" FROM ""telegraf"".""autogen"".""telegraf_internal_memstats"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:), ""instance"" FILL(null)",influxql
Gather errors,"SELECT mean(""errors"") AS ""mean_errors"" FROM ""telegraf"".""autogen"".""telegraf_internal_gather"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:), ""instance"" FILL(null)",influxql
Trhoughput (messages/s),"SELECT non_negative_derivative(mean(""metrics_written"")) AS ""mean_metrics_written"" FROM ""telegraf"".""autogen"".""telegraf_internal_agent"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:  GROUP BY time(1s), instance FILL(null)",influxql
Write errors,"SELECT mean(""errors"") AS ""mean_errors"" FROM ""telegraf"".""autogen"".""telegraf_internal_write"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:), ""instance"" FILL(null)",influxql
Manejadora Lower Misc.,"// Manejadora Salas Misc Table

import ""strings""

from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) =>
    strings.containsStr(v: r[""_measurement""], substr: ""manejadoraL"") and
    strings.containsStr(v: r[""_measurement""], substr: ""P05"")
  )
  |> last()
  |> pivot(rowKey: [""_measurement""], columnKey: [""_field""], valueColumn: ""_value"")
  |> group()
  |> map(fn: (r) => ({
    r with
    hvac_unit: strings.split(v: r._measurement, t: ""."")[3],
    })
  )
  |> keep(columns: [
    ""hvac_unit"",
    ""valorConsigna"",
    ""setpointTrabajo"",
    ""temperaturaAnticongelante"",
    ""temperaturaInyeccion"",
    ""temperaturaRetorno"",
    ""estadoValvula"",
    ""temperaturaAmbienteExterior"",
    ""setpointVentiladorMin"",
    ""setpointVentiladorMax"",
    ""caudalVentiladorImpulsion"",
    ""horometro"",
  ])
",flux
Manejadora Lower Summary State,"// Manejadora Lower Summary State

import ""strings""

from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) =>
    strings.containsStr(v: r[""_measurement""], substr: ""manejadoraL"") and
    strings.containsStr(v: r[""_measurement""], substr: ""P05"")
  )
  |> last()
  |> pivot(rowKey: [""_measurement""], columnKey: [""_field""], valueColumn: ""_value"")
  |> group()
  |> map(fn: (r) => ({
    r with
    hvac_unit: strings.split(v: r._measurement, t: ""."")[3],
    alarmaGeneral:
      if r.alarmaGeneral == true then 1 else 0,
    alarmaFiltro:
      if r.alarmaFiltro == true then 1 else 0,
    estadoFuncionamiento:
      if r.estadoFuncionamiento == true then 1 else 0,
    estadoDamper:
      if r.estadoDamper == true then 1 else 0,
    resetAlarma:
      if r.resetAlarma == true then 1 else 0,
    calefaccionEtapa01:
      if r.calefaccionEtapa01 == true then 1 else 0,
    calefaccionEtapa02:
      if r.calefaccionEtapa02 == true then 1 else 0,
    comandoEncendido:
      if r.comandoEncendido == true then 1 else 0,
  }))
  |> keep(columns: [
    ""hvac_unit"",
    ""alarmaGeneral"",
    ""alarmaFiltro"",
    ""estadoFuncionamiento"",
    ""estadoDamper"",
    ""resetAlarma"",
    ""calefaccionEtapa01"",
    ""calefaccionEtapa02"",
    ""comandoEncendido""
  ])
",flux
Valvula Summary State,"// Valvula Summary State

import ""strings""

from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) =>
    strings.containsStr(v: r[""_measurement""], substr: ""valvula"")
  )
  |> last()
  |> pivot(rowKey: [""_measurement""], columnKey: [""_field""], valueColumn: ""_value"")
  |> group()
  |> map(fn: (r) => ({
    r with
    hvac_unit: strings.split(v: r._measurement, t: ""."")[3],
    estadoValvula12:
      if r.estadoValvula12 == true then 1 else 0,
    estadoValvula03:
      if r.estadoValvula03 == true then 1 else 0,
    estadoValvula04:
      if r.estadoValvula04 == true then 1 else 0,
    estadoValvula05:
      if r.estadoValvula05 == true then 1 else 0,
    estadoValvula06:
      if r.estadoValvula06 == true then 1 else 0,
  }))
  |> keep(columns: [
    ""hvac_unit"",
    ""estadoValvula12"",
    ""estadoValvula03"",
    ""estadoValvula04"",
    ""estadoValvula05"",
    ""estadoValvula06"",
  ])
",flux
General Temperature,"// General Summary State

import ""strings""

from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.HVAC.generalP01"" )
  |> last()
  |> pivot(rowKey: [""_measurement""], columnKey: [""_field""], valueColumn: ""_value"")
  |> group()
  |> map(fn: (r) => ({
    r with
    hvac_unit: strings.split(v: r._measurement, t: ""."")[3],
  }))
  |> keep(columns: [
    ""hvac_unit"",
    ""temperaturaAmbiente""
  ])
",flux
"Vea, Vec, Vex, Vin Summary State","// Cracks Summary State

import ""strings""

from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) =>
    strings.containsStr(v: r[""_measurement""], substr: ""vea"") or
    strings.containsStr(v: r[""_measurement""], substr: ""vec"") or
    strings.containsStr(v: r[""_measurement""], substr: ""vex"") or
    strings.containsStr(v: r[""_measurement""], substr: ""vin0"")
  )
  |> last()
  |> pivot(rowKey: [""_measurement""], columnKey: [""_field""], valueColumn: ""_value"")
  |> group()
  |> map(fn: (r) => ({
    r with
    hvac_unit: strings.split(v: r._measurement, t: ""."")[3],
    estadoFuncionamiento:
      if r.estadoFuncionamiento == true then 1 else 0,
    fallaTermica:
      if r.fallaTermica == true then 1 else 0,
    comandoEncendido:
      if r.comandoEncendido == true then 1 else 0,
    estadoSelector:
      if r.estadoSelector == true then 1 else 0,
    estadoValvula12:
      if r.estadoValvula12 == true then 1 else 0,
    estadoValvula03:
      if r.estadoValvula03 == true then 1 else 0,
    estadoValvula04:
      if r.estadoValvula04 == true then 1 else 0,
    estadoValvula05:
      if r.estadoValvula05 == true then 1 else 0,
    estadoValvula06:
      if r.estadoValvula06 == true then 1 else 0,
  }))
  |> keep(columns: [
    ""hvac_unit"",
    ""estadoFuncionamiento"",
    ""fallaTermica"",
    ""comandoEncendido"",
    ""estadoSelector"",
  ])
",flux
Crack Misc.,"// Crack Misc Table

import ""strings""

from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] =~ /lsst.sal.HVAC.crack*/ )
  |> last()
  |> pivot(rowKey: [""_measurement""], columnKey: [""_field""], valueColumn: ""_value"")
  |> group()
  |> map(fn: (r) => ({
    r with
    hvac_unit: strings.split(v: r._measurement, t: ""."")[3],
    })
  )
  |> keep(columns: [
    ""hvac_unit"",
    ""temperaturaInyeccion"",
    ""temperaturaRetorno"",
    ""humedadSala"",
    ""aperturaValvula"",
    ""setpointHumidificador"",
    ""setpointDeshumidificador"",
    ""setpointCooling"",
    ""setpointHeating"",
    ""modoOperacionUnidad"",
    ""estadoDeUnidad"",
    ""numeroCircuitos"",
    ""horometro""
  ])
",flux
Crack Summary State,"// Cracks Summary State

import ""strings""

from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] =~ /lsst.sal.HVAC.crack*/ )
  |> last()
  |> pivot(rowKey: [""_measurement""], columnKey: [""_field""], valueColumn: ""_value"")
  |> group()
  |> map(fn: (r) => ({
    r with
    hvac_unit: strings.split(v: r._measurement, t: ""."")[3],
    estadoFuncionamiento:
      if r.estadoFuncionamiento == true then 1 else 0,
    estadoPresenciaAlarma:
      if r.estadoPresenciaAlarma == true then 1 else 0,
    comandoEncendido:
      if r.comandoEncendido == true then 1 else 0,
  }))
  |> keep(columns: [
    ""hvac_unit"",
    ""estadoFuncionamiento"",
    ""estadoPresenciaAlarma"",
    ""comandoEncendido""
  ])
",flux
Manejadora Sala Summary State,"// Manejadora Salas Summary State

import ""strings""

from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) =>
    strings.containsStr(v: r[""_measurement""], substr: ""manejadoraS"")
  )
  |> last()
  |> pivot(rowKey: [""_measurement""], columnKey: [""_field""], valueColumn: ""_value"")
  |> group()
  |> map(fn: (r) => ({
    r with
    hvac_unit: strings.split(v: r._measurement, t: ""."")[3],
    estadoFuncionamiento:
      if r.estadoFuncionamiento == true then 1 else 0,
    alarmaGeneral:
      if r.alarmaGeneral == true then ""ALARM!!!"" else ""No Alarm"",
    alarmaFiltro:
      if r.alarmaFiltro == true then ""ALARM!!!"" else ""No Alarm"",
    resetAlarma:
      if r.resetAlarma == true then 1 else 0,
    calefaccionEtapa01:
      if r.calefaccionEtapa01 == true then 1 else 0,
    calefaccionEtapa02:
      if r.calefaccionEtapa02 == true then 1 else 0,
    estadoDamper:
      if r.estadoDamper == true then 1 else 0,
    comandoEncendido:
      if r.comandoEncendido == true then 1 else 0,
  }))
  |> keep(columns: [
    ""hvac_unit"",
    ""estadoFuncionamiento"",
    ""alarmaGeneral"",
    ""alarmaFiltro"",
    ""resetAlarma"",
    ""calefaccionEtapa01"",
    ""calefaccionEtapa02"",
    ""estadoDamper"",
    ""comandoEncendido""
  ])
",flux
Manejadora Sala Misc.,"// Manejadora Salas Misc Table

import ""strings""

from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) =>
    strings.containsStr(v: r[""_measurement""], substr: ""manejadoraS"")
  )
  |> last()
  |> pivot(rowKey: [""_measurement""], columnKey: [""_field""], valueColumn: ""_value"")
  |> group()
  |> map(fn: (r) => ({
    r with
    hvac_unit: strings.split(v: r._measurement, t: ""."")[3],
    })
  )
  |> keep(columns: [
    ""hvac_unit"",
    ""valorConsigna"",
    ""estadoTemperaturaAmbiente"",
    ""estadoTemperaturaExterior"",
    ""estadoTemperaturaAnticongelante"",
    ""setpointTrabajo"",
    ""temperaturaInyeccion"",
    ""temperaturaRetorno"",
    ""caudalVentiladorImpulsion"",
    ""setpointVentiladorMin"",
    ""setpointVentiladorMax"",
    ""estadoValvula"",
    ""horometro""
  ])
",flux
Chiller Misc.,"// Chillers Misc table

import ""strings""

from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] =~ /lsst.sal.HVAC.chiller*/ )
  |> last()
  |> pivot(rowKey: [""_measurement""], columnKey: [""_field""], valueColumn: ""_value"")
  |> group()
  |> map(fn: (r) => ({r with hvac_unit: strings.split(v: r._measurement, t: ""."")[3], }))
  |> keep(columns: [
    ""hvac_unit"",
	""horasCompresorPromedio"", 
    ""horasCompresor01"", 
    ""horasCompresor02"", 
    ""horasCompresor03"", 
    ""horasCompresor04"",
    ""modoOperacion"",
    ""estadoUnidad"",
    ""potenciaDisponibleChiller"",
    ""potenciaTrabajo"",
    ""presionBajaCto1"",
    ""presionBajaCto2"",
    ""setpointActivo"",
    ""temperaturaAguaRetornoEvaporador"",
    ""temperaturaAguaImpulsionEvaporador""
  ])
",flux
Chiller Summary State,"// Chillers Summary State

import ""strings""

from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] =~ /lsst.sal.HVAC.chiller*/ )
  |> last()
  |> pivot(rowKey: [""_measurement""], columnKey: [""_field""], valueColumn: ""_value"")
  |> group()
  |> map(fn: (r) => ({
    r with
    hvac_unit: strings.split(v: r._measurement, t: ""."")[3],
    compresor01Funcionando:
      if r.compresor01Funcionando == true then 1 else 0,
    compresor02Funcionando:
      if r.compresor02Funcionando == true then 1 else 0,
    compresor03Funcionando:
      if r.compresor03Funcionando == true then 1 else 0,
    compresor04Funcionando:
      if r.compresor04Funcionando == true then 1 else 0,
    compresor01Alarmado:
      if r.compresor01Alarmado == true then ""ALARM!!!"" else ""No Alarm"",
    compresor02Alarmado:
      if r.compresor02Alarmado == true then ""ALARM!!!"" else ""No Alarm"",
    compresor03Alarmado:
      if r.compresor03Alarmado == true then ""ALARM!!!"" else ""No Alarm"",
    compresor04Alarmado:
      if r.compresor04Alarmado == true then ""ALARM!!!"" else ""No Alarm"",
    alarmaGeneral:
      if r.alarmaGeneral == true then ""ALARM!!!"" else ""No Alarm"",
    comandoEncendido:
      if r.comandoEncendido == true then 1 else 0,
  }))
  |> keep(columns: [
    ""hvac_unit"", 
    ""compresor01Funcionando"", 
    ""compresor02Funcionando"", 
    ""compresor03Funcionando"", 
    ""compresor04Funcionando"", 
    ""compresor01Alarmado"", 
    ""compresor02Alarmado"", 
    ""compresor03Alarmado"", 
    ""compresor04Alarmado"", 
    ""alarmaGeneral"", 
    ""comandoEncendido""
  ])
",flux
Fan Coil Temperature Summary ,"// Fan Coil Temperature Summary Table

import ""strings""

from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] =~ /lsst.sal.HVAC.fancoil*/ )
  |> last()
  |> pivot(rowKey: [""_measurement""], columnKey: [""_field""], valueColumn: ""_value"")
  |> group()
  |> map(fn: (r) => ({
    r with
    hvac_unit: strings.split(v: r._measurement, t: ""."")[3],  
    })
  )
  |> keep(columns: [""hvac_unit"",  ""temperaturaSala"", ""aperturaValvulaFrio""])
 

 

  
  
 ",flux
Fan Coil Setpoint Temperatures,"// Fan Coil setpoint temperatures table

import ""strings""
import ""math""

from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] =~ /lsst.sal.HVAC.fancoil*/ )
  |> last()
  |> pivot(rowKey: [""_measurement""], columnKey: [""_field""], valueColumn: ""_value"")
  |> group()
  |> map(fn: (r) => ({
    r with
    hvac_unit: strings.split(v: r._measurement, t: ""."")[3],
    // use the math flux package to round the float numbers before converting to string
	// use strings.joinStr() to display Day/Night setpoint temperatures in a single column 
    setpoint_cooling: strings.joinStr(arr: [string(v: math.round(x: r.setpointCoolingDay)), ""/"", string(v: math.round(x: r.setpointCoolingNight))], v: """"),
    setpoint_heating: strings.joinStr(arr: [string(v: math.round(x: r.setpointHeatingDay)), ""/"", string(v: math.round(x: r.setpointHeatingNight))], v: """")
    
    })
  )
  |> keep(columns: [""hvac_unit"", ""setpoint_cooling"", ""setpoint_heating"", ""setpointTrabajo""])",flux
Encendido,"// Count how many fancoil units are in the ""estadoEncendido"" state


from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart)
  |> filter(fn: (r) => r[""_measurement""] =~ /lsst.sal.HVAC.fancoil*/ and r._field =~ /comandoEncendido*/ )
  |> last()
  |> map(fn: (r) => ({
    r with
    state:
      if r._value == true then 1 else 0
    })
  )
  |> group()
  |> sum(column: ""state"")
 

  

  
 ",flux
Operacion,"// Count how many fancoil units are in the ""estadoOperacion"" state

from(bucket: ""efd/autogen"")
  // get values for the ""estadoOperacion"" field from the all measurements in the efd that match ""lsst.sal.HVAC.fancoil*""
  |> range(start: v.timeRangeStart)
  |> filter(fn: (r) => r[""_measurement""] =~ /lsst.sal.HVAC.fancoil*/ and r._field == ""estadoOperacion"" )
  |> last()
  // map that to a new column ""state"" and replace true/false with 1/0
  |> map(fn: (r) => ({
    r with
    state:
      if r._value == true then 1 else 0
    })
  )
  // group the results from individual measurements (fancoil units) into a single table
  |> group()
  // and sum them to count how many fancoil units are in that state
  |> sum(column: ""state"")
 

  

  
 ",flux
Fan Coil Summary State,"// Fan Coil summary state table

import ""strings""

from(bucket: ""efd/autogen"")
  // get data from all the measurements that match ""lsst.sal.HVAC.fancoil*""
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] =~ /lsst.sal.HVAC.fancoil*/ )
  |> last()
  // let the pivot function to do its magic https://docs.influxdata.com/flux/v0.x/stdlib/universe/pivot/
  |> pivot(rowKey: [""_measurement""], columnKey: [""_field""], valueColumn: ""_value"")
  |> group()

  |> map(fn: (r) => ({
    r with
    // use some string manipulation to display the name of the fancoil unit
    hvac_unit: strings.split(v: r._measurement, t: ""."")[3],
    // create new columns and replace true/false with 1/0 that's needed to configure thresholds 
    // and color the table cells
    estadoVentilador:
      if r.estadoVentilador == true then 1 else 0,
    estadoOperacion:
      if r.estadoOperacion == true then 1 else 0,
    comandoEncendido:
      if r.estadoEncendido == true then 1 else 0,
    estadoCalefactor:
      if r.estadoCalefactor == true then 1 else 0
    })
  )
  // keep only the columns of interest
  |> keep(columns: [""hvac_unit"", ""estadoVentilador"", ""comandoEncendido"", ""estadoCalefactor"", ""estadoOperacion""])

  
  
 ",flux
Fan Coil Units,"// Count the number of fancoil units, I know this looks too complicated but bear with me :)

from(bucket: ""efd/autogen"")
  // get all measumerements that match the ""lsst.sal.HVAC.fancoil*"" expression in the efd since the time set in the dashboard 
  |> range(start: v.timeRangeStart)
  |> filter(fn: (r) => r[""_measurement""] =~ /lsst.sal.HVAC.fancoil*/ )
  // get the most recent point in the timeseries 
  |> last()
  // because _measurement is a ""special"" column I'm mapping it to _value which is also the default name used by the unique() function
  // see https://docs.influxdata.com/flux/v0.x/stdlib/universe/unique/
  |> map(fn: (r) => ({
    r with
    _value: r._measurement
    })
  )
  |> keep(columns:[""_value""])
  // remove duplicate values
  |> unique()
  |> count()
  
 
 ",flux
Ventilador,"// Count how many fancoil units are in the ""estadoVentilador"" state

from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart)
  |> filter(fn: (r) => r[""_measurement""] =~ /lsst.sal.HVAC.fancoil*/ and r._field == ""estadoVentilador"" )
  |> last()
  |> map(fn: (r) => ({
    r with
    state:
      if r._value == true then 1 else 0
    })
  )
  |> group()
  |> sum(column: ""state"")
 

  

  
 ",flux
Calefactor,"// Count how many fancoil units are in the ""estadoCalefactor"" state


from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart)
  |> filter(fn: (r) => r[""_measurement""] =~ /lsst.sal.HVAC.fancoil*/ and r._field =~ /estadoCalefactor*/ )
  |> last()
  |> map(fn: (r) => ({
    r with
    state:
      if r._value == true then 1 else 0
    })
  )
  |> group()
  |> sum(column: ""state"")
 


  
  

  
 ",flux
Bomba Agua Fria Summary State,"// Misc Summary State

import ""strings""

from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.HVAC.bombaAguaFriaP01"" )
  |> last()
  |> pivot(rowKey: [""_measurement""], columnKey: [""_field""], valueColumn: ""_value"")
  |> group()
  |> map(fn: (r) => ({
    r with
    hvac_unit: strings.split(v: r._measurement, t: ""."")[3],
    estadoFuncionando:
      if r.estadoFuncionando == true then 1 else 0,
    comandoEncendido:
      if r.comandoEncendido == true then 1 else 0,
  }))
  |> keep(columns: [
    ""hvac_unit"",
    ""estadoFuncionando"",
    ""comandoEncendido""
  ])
",flux
AuxTel-ESS - ESSID 201 Temperatures (with Outside Temp),"SELECT ""temperatureItem1"" as ""Air"", ""temperatureItem2"" as ""Truss"", ""temperatureItem3"" as ""M2"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 201 AND ""sensorName"" = 'AuxTel-ESS01' AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
AuxTel-ESS - ESSID 201 Temperatures (with Outside Temp),"SELECT mean(""temperatureItem0"") AS ""mean_temperatureItem0"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
AuxTel-ESS - ESSID 201 Humidity,"SELECT ""relativeHumidityItem"" FROM ""efd"".""autogen"".""lsst.sal.ESS.relativeHumidity"" WHERE salIndex = 201 and time > :dashboardTime: AND time < :upperDashboardTime:",influxql
AuxTel-ESS - ESSID 201 Humidity,"SELECT ""temperature0"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 201 and time > :dashboardTime: AND time < :upperDashboardTime:",influxql
AuxTel-ESS - ESSID 201 Humidity,"SELECT ""dewPoint"" FROM ""efd"".""autogen"".""lsst.sal.ESS.dewPoint"" WHERE salIndex = 201 and time > :dashboardTime: AND time < :upperDashboardTime:",influxql
AuxTel-ESS - ESSID 201 Air Pressure,"SELECT ""pressureItem0"" /100 as ""barometricPressure [mbar]"" FROM ""efd"".""autogen"".""lsst.sal.ESS.pressure"" WHERE salIndex = 201 and time > :dashboardTime: AND time < :upperDashboardTime: and ""pressureItem0"" / 100 > 710 and ""pressureItem0"" / 100 < 9000",influxql
M1 Mirror Temperature,"SELECT ""temperatureItem0"" as ""M1 sensor 1"", ""temperatureItem1"" as ""M1 sensor 2"", ""temperatureItem2"" as ""M1 sensor 3"", ""temperatureItem3"" as ""M1 sensor 4"", ""temperatureItem4"" as ""M1 sensor 5"", ""temperatureItem5"" as ""M1 sensor 6"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 201 AND ""sensorName"" = 'AuxTel-ESS03' AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Anemometer Sonic Temperature,"SELECT mean(""sonicTemperature"") AS ""mean_sonicTemperature"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airTurbulence"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 201 GROUP BY time(:interval:) FILL(null)",influxql
3D Anemometer,"SELECT mean(""speed0"") AS ""mean_speed0"", mean(""speed1"") AS ""mean_speed1"", mean(""speed2"") AS ""mean_speed2"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airTurbulence"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 201 GROUP BY time(:interval:) FILL(null)",influxql
2D Anemometer Direction,"SELECT ""direction"", ""directionStdDev"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow"" WHERE salIndex = 204 and time > :dashboardTime: AND time < :upperDashboardTime:",influxql
2D Anemometer Speed,"SELECT ""maxSpeed"", ""speed"", ""speedStdDev"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow"" WHERE salIndex = 204 and time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Azimuth,"SELECT ""azimuthCalculatedAngle0"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.mount_AzEl_Encoders"" WHERE time > :dashboardTime: ",influxql
Azimuth,"SELECT ""azimuth"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.command_trackTarget"" WHERE time > :dashboardTime:",influxql
Elevation,"SELECT ""elevationCalculatedAngle0"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.mount_AzEl_Encoders"" WHERE time > :dashboardTime: ",influxql
Elevation,"SELECT ""elevation"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.command_trackTarget"" WHERE time > :dashboardTime:",influxql
Nasmyth2 target,"SELECT ""nasmyth2CalculatedAngle0"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.mount_Nasmyth_Encoders"" WHERE time > :dashboardTime:",influxql
Nasmyth2 target,"SELECT ""nasmyth2RotatorAngle"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.command_trackTarget"" WHERE time > :dashboardTime: ",influxql
Nasmyth2 Rotator Angle,"SELECT ""nasmyth2CalculatedAngle99"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.mount_Nasmyth_Encoders"" ORDER BY time DESC LIMIT 1",influxql
Nasmyth1 Rotator Angle,"SELECT ""nasmyth1CalculatedAngle99"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.mount_Nasmyth_Encoders"" ORDER BY time DESC LIMIT 1",influxql
Mount Status,"SELECT ""inPosition"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.logevent_allAxesInPosition"" ORDER BY time DESC LIMIT 1",influxql
M1M3 Acceleration,"SELECT ""angularAccelerationX"", ""angularAccelerationY"", ""angularAccelerationZ"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.accelerometerData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Azimuth Torques,"SELECT ""actualTorque"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
TMA Elevation Torques,"SELECT ""actualTorque"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Azimuth,"SELECT ""actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Elevation,"SELECT ""actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
HP  Breakaway Pressure,"SELECT mean(""breakawayPressure0"") AS ""mean_breakawayPressure0"", mean(""breakawayPressure1"") AS ""mean_breakawayPressure1"", mean(""breakawayPressure2"") AS ""mean_breakawayPressure2"", mean(""breakawayPressure3"") AS ""mean_breakawayPressure3"", mean(""breakawayPressure4"") AS ""mean_breakawayPressure4"", mean(""breakawayPressure5"") AS ""mean_breakawayPressure5"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointMonitorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 Lowering/Raising,"SELECT ""weightSupportedPercent"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.logevent_raisingLoweringInfo"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Hardpoint Forces,"SELECT mean(""measuredForce1"") AS ""mean_measuredForce1"", mean(""measuredForce0"") AS ""mean_measuredForce0"", mean(""measuredForce2"") AS ""mean_measuredForce2"", mean(""measuredForce3"") AS ""mean_measuredForce3"", mean(""measuredForce4"") AS ""mean_measuredForce4"", mean(""measuredForce5"") AS ""mean_measuredForce5"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(1s) FILL(null)",influxql
Elevation Velocity,"SELECT ""actualVelocity"", ""demandVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Azimuth Velocity,"SELECT ""actualVelocity"", ""demandVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Compressor Motor current,"SELECT ""motorCurrent"" as ""Current 1"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE salIndex=1 and time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Compressor Motor current,"SELECT ""motorCurrent"" as ""Current 2"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE salIndex=2 and time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Line 2,"SELECT ""linePressure"" as ""Line 2"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE salIndex=2 and time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Line 1,"SELECT ""linePressure"" as ""Line 1"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE salIndex=1 and time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Compressor line pressure,"SELECT ""linePressure"" as ""Line 1"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE salIndex=1 and time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Compressor line pressure,"SELECT ""linePressure"" as ""Line 2"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE salIndex=2 and time > :dashboardTime: AND time < :upperDashboardTime:",influxql
HP 5,"SELECT ""breakawayPressure4"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointMonitorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
HP 6,"SELECT ""breakawayPressure5"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointMonitorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
HP 4,"SELECT ""breakawayPressure3"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointMonitorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
HP 3,"SELECT ""breakawayPressure2"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointMonitorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
HP 2,"SELECT ""breakawayPressure1"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointMonitorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
HP 1,"SELECT ""breakawayPressure0"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointMonitorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
HP Breakaway pressure,"SELECT ""breakawayPressure0"", ""breakawayPressure1"", ""breakawayPressure2"", ""breakawayPressure3"", ""breakawayPressure4"", ""breakawayPressure5"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointMonitorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Motor Speed,"SELECT ""motorSpeedPercentage"" as ""Speed 1"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE salIndex=1 and time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Motor Speed,"SELECT ""motorSpeedPercentage"" as ""Speed 2"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.analogData"" WHERE salIndex=2 and time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Untitled Graph,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
MTAirCompressor,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
OCPS:2,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.OCPS.logevent_summaryState"" WHERE salIndex = 2 ORDER BY DESC LIMIT 1",influxql
CCHeaderService,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.CCHeaderService.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
CCOODS,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.CCOODS.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
CCCamera,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
Average Measured Hardpoint Force,"SELECT (""measuredForce0"" + ""measuredForce1"" + ""measuredForce2"" +  ""measuredForce3"" +  ""measuredForce4"" + ""measuredForce5"")/6 AS ""mean_measuredForce1"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: FILL(null)",influxql
Hardpoint Force,"SELECT mean(""measuredForce0"") AS ""mean_measuredForce0"", mean(""measuredForce1"") AS ""mean_measuredForce1"", mean(""measuredForce2"") AS ""mean_measuredForce2"", mean(""measuredForce3"") AS ""mean_measuredForce3"", mean(""measuredForce4"") AS ""mean_measuredForce4"", mean(""measuredForce5"") AS ""mean_measuredForce5"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
vacuum (smoothed 10 min),"SELECT median(""vacuum"") AS ""median_vacuum"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.vacuum"" WHERE time > :dashboardTime: GROUP BY time(5m) FILL(null)",influxql
vacuum (unsmoothed),"SELECT ""vacuum"" as ""vacuum (torr)"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.vacuum"" WHERE time > :dashboardTime:",influxql
CCD Temp -- WREB,"SELECT ""ccdTemp0"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.wreb"" WHERE time > :dashboardTime:",influxql
CCD Temp Smoothed (5 minutes),"SELECT mean(""temp10"") AS ""mean_temp10"", mean(""temp20"") AS ""mean_temp20"", mean(""temp30"") AS ""mean_temp30"", mean(""temp40"") AS ""mean_temp40"", mean(""temp50"") AS ""mean_temp50"", mean(""temp60"") AS ""mean_temp60"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.focal_plane_Reb"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M2 STO,"SELECT max(""geffects_A13"") AS ""max_geffects_A13"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_effects"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(none)",influxql
M2 STO Causes,"SELECT max(""gcauses_D3"") AS ""max_gcauses_D3"", max(""gcauses_D4"") AS ""max_gcauses_D4"", max(""gcauses_D9"") AS ""max_gcauses_D9"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_causes"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(none)",influxql
5th Level Pier Door,"SELECT max(""gcauses_D5"") AS ""max_gcauses_D5"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_causes"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(none)",influxql
Testing Plot,"SELECT mean(""dynCH02retGPGLYpres"") AS ""mean_dynCH02retGPGLYpres"", mean(""dynCH02retGPGLYtemp"") AS ""mean_dynCH02retGPGLYtemp"", mean(""dynCH02supGPGLYpres"") AS ""mean_dynCH02supGPGLYpres"", mean(""dynCH02supGPGLYtemp"") AS ""mean_dynCH02supGPGLYtemp"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Testing,"SELECT mean(""dynCH01supPS11"") AS ""mean_dynCH01supPS11"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Dynalene Chillers Dynalene Supply Pressures [PA],"SELECT ""dynCH01supPS11"", ""dynCH02supPS13"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dynalene Chillers Dynalene Supply Temperatures [C],"SELECT ""dynCH01supTS05"", ""dynCH02supTS07"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dynalene Chillers Dynalene Supply Flowrates [LPM],"SELECT ""dynCH01supFS01"", ""dynCH02supFS02"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dynalene TA Thermal Power Dissipation (kW),"SELECT ""dynTAtpd"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dynalene Return Pressure for TA [PSI] [CONVERTED],"SELECT ""dynTAretPS04"" / 6894.76 FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dynalene Return Temperature for TA [C],"SELECT ""dynTAretTS04"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dynalene Supply Flowrate for TA [LPM] & [GPM],"SELECT ""dynTAsupFS04"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dynalene Supply Flowrate for TA [LPM] & [GPM],"SELECT ""dynTAsupFS04""*0.22 FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dynalene Supply Pressure for TA [PSI] [CONVERTED],"SELECT ""dynTAsupPS03""  / 6894.76 FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dynalene Supply Temperature for TA [C],"SELECT ""dynTAsupTS03"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dynalene TMA Thermal Power Dissipation [kW],"SELECT ""dynTMAtpd"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dynalene Chillers Tank Levels [%],"SELECT ""dynCH01LS01"", ""dynCH02LS02"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dynalene Return Pressure for TMA [PSI] [CONVERTED],"SELECT ""dynTMAretPS02"" / 6894.76 FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dynalene Supply Flowrate for TMA [LPM],"SELECT ""dynTMAsupFS03"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dynalene Supply Pressure for TMA [PSI] [CONVERTED],"SELECT ""dynTMAsupPS01"" / 6894.76 FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dynalene Supply Temperature for TMA [C],"SELECT mean(""dynTMAsupTS01"") AS ""mean_dynTMAsupTS01"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Dynalene Return Temperature for TMA [C],"SELECT ""dynTMAretTS02"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.dynaleneP05"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
DC Accelerometers raw mV,"import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] =~ regexp.compile(v: ""rawAccelerometer"" + v.Accelerometers))
  |> map(fn: (r) => ({r with _value: r._value * 1000.0}))

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
TMA Azimuth velocity,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.azimuth"")
  |> filter(fn: (r) => r[""_field""] == ""actualVelocity"" or r[""_field""] == ""demandVelocity"")
  

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
TMA Elevation acceleration,"import ""math""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevation"")
  |> filter(fn: (r) => r[""_field""] == ""actualVelocity"" or r[""_field""] == ""demandVelocity"" or r[""_field""] == ""timestamp"")
  |> difference()  
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> map(fn: (r) => ({_time: r._time, demandAcceleration: r.demandVelocity / r.timestamp, actualAcceleration: r.actualVelocity / r.timestamp}) )
  

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false, column: ""actualAcceleration"")      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false, column: ""actualAcceleration"")
    else 
      data",flux
TMA Azimuth acceleration,"import ""math""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.azimuth"")
  |> filter(fn: (r) => r[""_field""] == ""actualVelocity"" or r[""_field""] == ""demandVelocity"" or r[""_field""] == ""timestamp"")
  |> difference()  
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> map(fn: (r) => ({_time: r._time, demandAcceleration: r.demandVelocity / r.timestamp, actualAcceleration: r.actualVelocity / r.timestamp}) )
  

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false, column: ""actualAcceleration"")      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false, column: ""actualAcceleration"")
    else 
      data",flux
TMA Elevation velocity,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevation"")
  |> filter(fn: (r) => r[""_field""] == ""actualVelocity"" or r[""_field""] == ""demandVelocity"" )

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
DC Angular Acceleration (deg/sec^2),"import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] =~ regexp.compile(v: ""angularAcceleration"" + v.Axis))

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
DC Accelerometers calibrated (m/sec^2),"import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] =~ regexp.compile(v: ""accelerometer"" + v.Accelerometers))
  |> map(fn: (r) => ({r with _value: r._value}))

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
"DC Accelerometers raw (*500.0), mg","import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] =~ regexp.compile(v: ""rawAccelerometer"" + v.Accelerometers))
  |> map(fn: (r) => ({r with _value: r._value * 500.0}))

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
Hardpoints Forces,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /measuredForce./)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
TMA Elevation,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevation"")
  |> filter(fn: (r) => r[""_field""] == ""actualPosition"" or r[""_field""] == ""demandPosition"")

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
TMA Azimuth,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.azimuth"")
  |> filter(fn: (r) => r[""_field""] == ""actualPosition"")

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
Inclinometer angle,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.inclinometerData"")
  |> filter(fn: (r) => r[""_field""] == ""inclinometerAngle"")
  

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
Gyro velocities,"import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.gyroData"")
  |> filter(fn: (r) => r[""_field""] =~ regexp.compile(v: ""angularVelocity[XYZ]"" ))

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
DC Accelerometers Angular Acceleration,"import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] =~ regexp.compile(v: ""angularAcceleration[XYZ]"" ))

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
Applied Forces,"import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.appliedForces"")
  |> filter(fn: (r) => r[""_field""] =~ regexp.compile(v: v.Forces))


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
Applied Balance Forces,"import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.appliedBalanceForces"")
  |> filter(fn: (r) => r[""_field""] =~ regexp.compile(v: v.Forces))


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
Force Actuator Measured forces,"import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.forceActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ regexp.compile(v: v.Forces))


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
Applied Velocity Forces,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.appliedVelocityForces"")
  |> filter(fn: (r) => r[""_field""] =~ /^[fm][xyz]$/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
Applied Acceleration Forces,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.appliedAccelerationForces"")
  |> filter(fn: (r) => r[""_field""] =~ /^[fm][xyz]$/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
Hardpoints Forces and Moments,"import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ regexp.compile(v: v.Forces))


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
Hardpoints Load Cell Forces,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /measuredForce./)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
Hardpoints Load Cell Forces - max,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /measuredForce./)
  
if v.Downsample == ""Default"" then  
  data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
else  
  data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)",flux
TMA Azimuth velocity,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.azimuth"")
  |> filter(fn: (r) => r[""_field""] == ""actualVelocity"" or r[""_field""] == ""demandVelocity"")
  

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
TMA Elevation acceleration,"import ""math""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevation"")
  |> filter(fn: (r) => r[""_field""] == ""actualVelocity"" or r[""_field""] == ""demandVelocity"" or r[""_field""] == ""timestamp"")
  |> difference()  
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> map(fn: (r) => ({_time: r._time, demandAcceleration: r.demandVelocity / r.timestamp, actualAcceleration: r.actualVelocity / r.timestamp}) )
  

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false, column: ""actualAcceleration"")      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false, column: ""actualAcceleration"")
    else 
      data",flux
TMA Azimuth acceleration,"import ""math""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.azimuth"")
  |> filter(fn: (r) => r[""_field""] == ""actualVelocity"" or r[""_field""] == ""demandVelocity"" or r[""_field""] == ""timestamp"")
  |> difference()  
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> map(fn: (r) => ({_time: r._time, demandAcceleration: r.demandVelocity / r.timestamp, actualAcceleration: r.actualVelocity / r.timestamp}) )
  

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false, column: ""actualAcceleration"")      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false, column: ""actualAcceleration"")
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false, column: ""actualAcceleration"")
    else 
      data",flux
TMA Elevation velocity,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevation"")
  |> filter(fn: (r) => r[""_field""] == ""actualVelocity"" or r[""_field""] == ""demandVelocity"" )

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
Hardpoints Load Cell Forces - min,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /measuredForce./)
  |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)

if v.Downsample == ""Default"" then  
  data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
else  
  data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)",flux
TMA Elevation,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevation"")
  |> filter(fn: (r) => r[""_field""] == ""actualPosition"" or r[""_field""] == ""demandPosition"")

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
TMA Azimuth,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.azimuth"")
  |> filter(fn: (r) => r[""_field""] == ""actualPosition"")

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
Inclinometer angle,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.inclinometerData"")
  |> filter(fn: (r) => r[""_field""] == ""inclinometerAngle"")
  

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
"Ambient (from ComCam, 1C resolution)","SELECT mean(""cntrlrAirTemperature"") AS ""mean_cntrlrAirTemperature"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.vacuum_Turbo"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
camera hexapod actuator temperatures,"SELECT ""temperatureC03"", ""temperatureC05"", ""temperatureC06"", ""temperatureC01"", ""temperatureC04"", ""temperatureC02"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature8Ch"" WHERE salIndex = 1 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
camera hexapod inPosition,"SELECT ""inPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_inPosition"" WHERE salIndex = 1 AND time > :dashboardTime: AND time < :upperDashboardTime: order by desc limit 4",influxql
camera Hexapod compensationOffset-y,"SELECT mean(""y"") AS ""mean_y"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_compensationOffset"" WHERE salIndex = 1 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
camera hexapod y-position,"SELECT mean(""position1"") AS ""mean_position1"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 1. GROUP BY time(:interval:) FILL(null)",influxql
target elevation,"SELECT mean(""elevation"") AS ""mean_elevation"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_target"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Filter Position (??? units),"SELECT mean(""filterPosition"") FROM ""efd"".""autogen"".""lsst.sal.CCCamera.logevent_endSetFilter"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(1s) FILL(null)",influxql
Last SetFilter Command,"SELECT ""name"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.command_setFilter"" ORDER BY time DESC LIMIT 1",influxql
Current Filter,"SELECT ""filterName"", ""filterPosition"", ""filterSlot"", ""filterType"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.logevent_endSetFilter"" ORDER BY time DESC LIMIT 1",influxql
Available Filters,"SELECT ""filterNames"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.logevent_availableFilters"" ORDER BY time DESC LIMIT 1",influxql
Config,"SELECT ""drivesEnabled"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_configuration"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Move Command,"SELECT ""private_sndStamp"", ""position"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.command_move"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Stop Command,"SELECT ""private_sndStamp"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.command_stop"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
enabledSubstate,"SELECT ""enabledSubstate"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_controllerState"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Command stop,"SELECT ""private_efdStamp"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.command_stop"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Bus Voltage,"SELECT ""busVoltage"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.motors"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Rotator Currents,"SELECT ""current0"", ""current1"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.motors"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Rotator Torque Values,"SELECT torque0, torque1 FROM ""efd"".""autogen"".""lsst.sal.MTRotator.motors"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
Rotator Logevent,"SELECT ""level"", ""message"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_logMessage"" ORDER BY DESC LIMIT 100",influxql
Fault_command,"SELECT ""private_sndStamp"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.command_fault"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Following Error Rotator-CCW,"SELECT ""positionError"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.ccwFollowingError"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
CCW followingErrorThreshold,"SELECT ""followingErrorThreshold"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_configuration"" ORDER BY DESC LIMIT 1",influxql
Rot Motors calibrated motor position [deg],"SELECT ""calibrated1"", ""calibrated0"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.motors"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Rotator Velocity,"SELECT ""actualVelocity"", ""demandVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.rotation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Error Code,"SELECT ""errorCode"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_errorCode"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Controller State,"SELECT ""controllerState"", ""faultSubstate"", ""enabledSubstate"", ""applicationStatus"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_controllerState"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: ORDER BY DESC LIMIT 10",influxql
Commandable by DDS,"SELECT ""state"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_commandableByDDS"" ORDER BY DESC LIMIT 3",influxql
In Position,"SELECT ""inPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_inPosition"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Summary State,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
Position,"SELECT ""actualPosition"", ""demandPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.rotation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Logevent_target: position,"SELECT ""position"", ""velocity"", ""private_sndStamp"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_target"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: ORDER BY DESC LIMIT 5",influxql
Last Error Code,"SELECT ""errorCode"", ""errorReport"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_errorCode"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Rotator Currents,"SELECT /current/ FROM ""efd"".""autogen"".""lsst.sal.MTRotator.motors"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Difference between actual and demanded velocity,"SELECT ""demandVelocity""-""actualVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.rotation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Difference between demanded and actual position (arcsec),"SELECT (""actualPosition""-""demandPosition"") * 3600 FROM ""efd"".""autogen"".""lsst.sal.MTRotator.rotation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Electrical,"SELECT ""copleyFaultStatus0"", ""copleyFaultStatus1"", ""copleyLatchingFaultStatus0"", ""copleyLatchingFaultStatus1"", ""copleyStatusWordDrive0"", ""copleyStatusWordDrive1"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.electrical"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Temperature,"SELECT ""temperatureItem6"" as ""Motor 1"", ""temperatureItem7"" as ""Motor 2"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 1 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
TMA Elevation Torques,"SELECT ""actualTorque"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
TMA Azimuth Torques,"SELECT ""actualTorque"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Hardpoint Displacement LVDT 6,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] =~ /displacementLVDT5/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoint Displacement LVDT 5,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] =~ /displacementLVDT4/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoint Displacement LVDT 4,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] =~ /displacementLVDT3/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoint Displacement LVDT 3,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] =~ /displacementLVDT2/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoint Displacement LVDT 2,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] =~ /displacementLVDT1/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoint Displacement LVDT 1,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] =~ /displacementLVDT0/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoint Breakaway LVDT 6,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] =~ /breakawayLVDT5/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoint Breakaway LVDT 5,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] =~ /breakawayLVDT4/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoint Breakaway LVDT 4,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] =~ /breakawayLVDT3/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoint Breakway LVDT 3,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] =~ /breakawayLVDT2/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoint Breakway LVDT 2,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] =~ /breakawayLVDT1/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoint Breakaway LVDT 1,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] =~ /breakawayLVDT0/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
IMS [xyz]Position (arcsec) spread,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.imsData"")
  |> filter(fn: (r) => r[""_field""] =~ /.Position/)
  |> map(fn: (r) => ({r with _value: r._value * 1000000.0}))
  |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)

data",flux
IMS yRotation (arcsec),"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.imsData"")
  |> filter(fn: (r) => r[""_field""] =~ /yRotation/)
  |> map(fn: (r) => ({r with _value: r._value * 3600.0}))


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoint displacement LVDT 3,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] =~ /displacementLVDT3/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoint displacement LVDT 4,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] =~ /displacementLVDT4/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoint displacement LVDT 2,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] =~ /displacementLVDT2/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoint displacement LVDT 5,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] =~ /displacementLVDT5/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoint displacement LVDT 1,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] =~ /displacementLVDT1/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoint breakaway LVDT 5,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] =~ /breakawayLVDT5/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoint breakaway LVDT 4,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] =~ /breakawayLVDT4/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoint breakaway LVDT 0 (clone 1),"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] =~ /breakawayLVDT0/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoint breakaway LVDT 2,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] =~ /breakawayLVDT2/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoint displacement LVDT 0,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] =~ /displacementLVDT0/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoint breakaway LVDT 0,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] =~ /breakawayLVDT0/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoints encoder 5,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /encoder5/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoints encoder 2,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /encoder2/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoint encoder 3,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /encoder3/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoints encoder 4,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /encoder4/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoints encoder 1,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /encoder1/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoint encoder 0,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /encoder0/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
IMS raw 7,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.imsData"")
  |> filter(fn: (r) => r[""_field""] =~ /rawSensorData7/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
TMA Azimuth,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.azimuth"")
  |> filter(fn: (r) => r[""_field""] =~ /actualPosition/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
TMA Elevation,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevation"")
  |> filter(fn: (r) => r[""_field""] =~ /actualPosition/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
IMS raw 3,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.imsData"")
  |> filter(fn: (r) => r[""_field""] =~ /rawSensorData3/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
IMS raw 4,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.imsData"")
  |> filter(fn: (r) => r[""_field""] =~ /rawSensorData4/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
IMS raw 5,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.imsData"")
  |> filter(fn: (r) => r[""_field""] =~ /rawSensorData5/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
IMS raw 6,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.imsData"")
  |> filter(fn: (r) => r[""_field""] =~ /rawSensorData6/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
IMS raw 2,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.imsData"")
  |> filter(fn: (r) => r[""_field""] =~ /rawSensorData2/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
IMS raw 1,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.imsData"")
  |> filter(fn: (r) => r[""_field""] =~ /rawSensorData1/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
IMS raw 0,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.imsData"")
  |> filter(fn: (r) => r[""_field""] =~ /rawSensorData0/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
IMS [xyz]Rotation (arcsec) spread,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.imsData"")
  |> filter(fn: (r) => r[""_field""] =~ /.Rotation/)
  |> map(fn: (r) => ({r with _value: r._value * 3600.0}))
  |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)

data",flux
IMS zRotation (arcsec),"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.imsData"")
  |> filter(fn: (r) => r[""_field""] =~ /zRotation/)
|> map(fn: (r) => ({r with _value: r._value * 3600.0}))

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
IMS xRotation (arcsec),"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.imsData"")
  |> filter(fn: (r) => r[""_field""] =~ /xRotation/)
  |> map(fn: (r) => ({r with _value: r._value * 3600.0}))

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
IMS zPosition (microns),"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.imsData"")
  |> filter(fn: (r) => r[""_field""] =~ /zPosition/)
  |> map(fn: (r) => ({r with _value: r._value * 1000000.0}))

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
IMS xPosition (microns),"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.imsData"")
  |> filter(fn: (r) => r[""_field""] =~ /xPosition/)
  |> map(fn: (r) => ({r with _value: r._value * 1000000.0}))


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
IMS yPosition (microns),"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.imsData"")
  |> filter(fn: (r) => r[""_field""] =~ /yPosition/)
  |> map(fn: (r) => ({r with _value: r._value * 1000000.0}))

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoints forces,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /measuredForce./)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoint breakaway LVDT 3,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointMonitorData"")
  |> filter(fn: (r) => r[""_field""] =~ /breakawayLVDT3/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Chronograf,"SELECT last(""numSeries"") AS ""last_numSeries"", last(""numMeasurements"") AS ""last_numMeasurements"" FROM ""_internal"".""monitor"".""database"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND ""database""='chronograf'  limit 1",influxql
Internal,"SELECT last(""numSeries"") AS ""last_numSeries"", last(""numMeasurements"") AS ""last_numMeasurements"" FROM ""_internal"".""monitor"".""database"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND ""database""='_internal'  limit 1",influxql
Telegraf,"SELECT last(""numSeries"") AS ""last_numSeries"", last(""numMeasurements"") AS ""last_numMeasurements"" FROM ""_internal"".""monitor"".""database"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND ""database""='telegraf'  limit 1",influxql
EFD,"SELECT last(""numSeries"") AS ""last_numSeries"", last(""numMeasurements"") AS ""last_numMeasurements"" FROM ""_internal"".""monitor"".""database"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND ""database""='efd'  limit 1",influxql
InfluxDB write errors,"SELECT mean(""writeError"") AS ""mean_writeError"" FROM ""_internal"".""monitor"".""write"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(0)",influxql
Queries per minute,"SELECT non_negative_derivative(mean(""queriesExecuted""),1m) AS ""mean_queriesExecuted"" FROM ""_internal"".""monitor"".""queryExecutor"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Mallocs per minute,"SELECT non_negative_derivative(mean(""Mallocs""),60s) AS ""mean_Mallocs"" FROM ""_internal"".""monitor"".""runtime"" WHERE time > :dashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Writes per min,"SELECT non_negative_derivative(max(""pointReq""),1m) AS ""points_written"" FROM ""_internal"".""monitor"".""write"" WHERE time > :dashboardTime: GROUP BY time(:interval:)",influxql
Query duration vs. memory usage,"SELECT mean(""queryDurationNs"") AS ""mean_queryDurationNs"" FROM ""_internal"".""monitor"".""queryExecutor"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Query duration vs. memory usage,"SELECT mean(""Mallocs"")*10 AS ""mean_Mallocs"" FROM ""_internal"".""monitor"".""runtime"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
diskBytes/s (_internal.monitor.shard),"SELECT non_negative_derivative(mean(""diskBytes""),1s) AS ""mean_diskBytes"" FROM ""_internal"".""monitor"".""shard"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND ""database""='efd' GROUP BY time(1m) FILL(null)",influxql
Elevation Angle measured by M2 (clone 1),"SELECT ""inclinometerRaw"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.zenithAngle"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Closed Loop Control Mode,"from(bucket: ""efd/autogen"")
  |> range(start: -36h)
  |> filter(fn: (r) => r._measurement == ""lsst.sal.MTM2.logevent_closedLoopControlMode"" and (r._field == ""mode""))
  |> sort(columns: [""_time""], desc: true)  // Ordena por tiempo en orden descendente
  |> limit(n: 5)  // Limita a los ltimos 5 eventos
  |> map(fn: (r) => ({
        r with 
        summaryState: if r._value == 1 then ""IDLE""
                      else if r._value == 2 then ""TELEMETRY""
                      else if r._value == 3 then ""OPEN LOOP""
                      else if r._value == 4 then ""CLOSED LOOP""
                      else string(v: r._value)
    }))
",flux
Closed Loop Control Mode,"SELECT ""mode"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_closedLoopControlMode"" ORDER BY DESC LIMIT 1",influxql
Power Voltage,"SELECT ""motorVoltage"", ""commVoltage"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.powerStatus"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Hardpoints (1-based),"SELECT /actuators/ FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_hardpointList"" ORDER BY DESC LIMIT 3",influxql
Summary State,"from(bucket: ""efd/autogen"")
  |> range(start: -36h)
  |> filter(fn: (r) => r._measurement == ""lsst.sal.MTM2.logevent_summaryState"" and (r._field == ""summaryState""))
  |> last()
  |> map(fn: (r) => ({
        r with 
        summaryState: if r._value == 1 then ""DISABLED""
                      else if r._value == 2 then ""ENABLED""
                      else if r._value == 3 then ""FAULT""
                      else if r._value == 4 then ""OFFLINE""
                      else if r._value == 5 then ""STANDBY""
                      else string(v: r._value)
    }))",flux
ErrorCodes,"SELECT ""errorCode"", ""errorReport"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_errorCode"" ORDER BY DESC LIMIT 10",influxql
TMA Azimuth Position,"SELECT ""actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
 Tangent Actuator measured forces,"SELECT ""measured0"",""measured1"",""measured2"",""measured3"",""measured4"",""measured5"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.tangentForce"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
 Tangent Actuator steps all,"SELECT ""steps0"",""steps1"",""steps2"",""steps3"",""steps4"",""steps5"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.tangentActuatorSteps"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Tangent force errors,"SELECT ""force0"",""force1"",""force2"",""force3"",""force4"",""force5"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.forceErrorTangent"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Log Message,"SELECT ""message"", ""level"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_logMessage"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Net Moments Total,"SELECT ""mx"", ""my"", ""mz"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.netMomentsTotal"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Measured Axail actuators Forces,"SELECT /measured/ FROM ""efd"".""autogen"".""lsst.sal.MTM2.axialForce"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Mirror Position IMS,"SELECT ""x"", ""xRot"", ""y"", ""yRot"", ""z"", ""zRot"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.positionIMS"" ORDER BY DESC LIMIT 3",influxql
Assembly in Position,"SELECT ""inPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_m2AssemblyInPosition"" ORDER BY DESC LIMIT 3",influxql
Mirror Position,"SELECT ""x"", ""y"", ""z"", ""xRot"", ""yRot"", ""zRot"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.position"" ORDER BY DESC LIMIT 3",influxql
Summary State,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_summaryState"" ORDER BY DESC LIMIT 10",influxql
Elevation Angle measured by M2,"SELECT ""inclinometerProcessed"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.zenithAngle"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Commandable by DDS,"SELECT ""state""  FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_commandableByDDS"" ORDER BY DESC LIMIT 3",influxql
IMS RBP,"SELECT ""x"",""y"",""z"",""xRot"", ""yRot"", ""zRot"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.positionIMS"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
TMA Elevation Position,"SELECT ""actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Power Current,"SELECT ""motorCurrent"", ""commCurrent"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.powerStatus"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTM1M3TS,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
MTAirCompressor:1,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.logevent_summaryState"" WHERE salIndex = 1 ORDER BY DESC LIMIT 1",influxql
Electrometer:1,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.Electrometer.logevent_summaryState"" WHERE salIndex = 1 ORDER BY DESC LIMIT 1",influxql
Elevation,"SELECT ""actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" ORDER BY time DESC LIMIT 1",influxql
Azimuth,"SELECT ""actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" ORDER BY time DESC LIMIT 1",influxql
MTM2,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
MTAOS,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
M2-Hexapod,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_summaryState"" WHERE salIndex = 2 ORDER BY DESC LIMIT 1",influxql
MTDome,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTDome.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
MTPtg,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTPtg.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
MTDomeTrajectory,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTDomeTrajectory.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
MTMount,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
MTM1M3,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
CCHeaderService,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.CCHeaderService.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
CCOODS,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.CCOODS.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
CCCamera,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
MTRotator,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
Cam-Hexapod,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_summaryState"" WHERE salIndex = 1 ORDER BY DESC LIMIT 1",influxql
Watcher,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.Watcher.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
MTAirCompressor:2,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTAirCompressor.logevent_summaryState"" WHERE salIndex = 2 ORDER BY DESC LIMIT 1",influxql
Elevation Angle RAW,"SELECT ""inclinometerRaw"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.zenithAngle"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Closed Loop Control Mode,"from(bucket: ""efd/autogen"")
  |> range(start: -36h)
  |> filter(fn: (r) => r._measurement == ""lsst.sal.MTM2.logevent_closedLoopControlMode"" and (r._field == ""mode""))
  |> sort(columns: [""_time""], desc: true)  // Ordena por tiempo en orden descendente
  |> limit(n: 5)  // Limita a los ltimos 5 eventos
  |> map(fn: (r) => ({
        r with 
        summaryState: if r._value == 1 then ""IDLE""
                      else if r._value == 2 then ""TELEMETRY""
                      else if r._value == 3 then ""OPEN LOOP""
                      else if r._value == 4 then ""CLOSED LOOP""
                      else string(v: r._value)
    }))
",flux
Closed Loop Control Mode,"SELECT ""mode"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_closedLoopControlMode"" ORDER BY DESC LIMIT 1",influxql
Power Voltage,"SELECT ""motorVoltage"", ""commVoltage"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.powerStatus"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Hardpoints (1-based),"SELECT /actuators/ FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_hardpointList"" ORDER BY DESC LIMIT 3",influxql
Tangential Actuators Temp,"SELECT /temperature/ FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 106",influxql
Summary Faults Status,"SELECT ""status"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_summaryFaultsStatus"" ORDER BY DESC LIMIT 3",influxql
Enabled Faults Mask,"SELECT ""mask"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_enabledFaultsMask"" ORDER BY DESC LIMIT 3",influxql
Summary State,"from(bucket: ""efd/autogen"")
  |> range(start: -36h)
  |> filter(fn: (r) => r._measurement == ""lsst.sal.MTM2.logevent_summaryState"" and (r._field == ""summaryState""))
  |> last()
  |> map(fn: (r) => ({
        r with 
        summaryState: if r._value == 1 then ""DISABLED""
                      else if r._value == 2 then ""ENABLED""
                      else if r._value == 3 then ""FAULT""
                      else if r._value == 4 then ""OFFLINE""
                      else if r._value == 5 then ""STANDBY""
                      else string(v: r._value)
    }))",flux
ErrorCodes,"SELECT ""errorCode"", ""errorReport"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_errorCode"" ORDER BY DESC LIMIT 10",influxql
TMA Azimuth Position,"SELECT ""actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
 Tangent Actuator measured forces,"SELECT ""measured0"",""measured1"",""measured2"",""measured3"",""measured4"",""measured5"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.tangentForce"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
 Tangent Actuator steps all,"SELECT ""steps0"",""steps1"",""steps2"",""steps3"",""steps4"",""steps5"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.tangentActuatorSteps"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Tangent force errors,"SELECT ""force0"",""force1"",""force2"",""force3"",""force4"",""force5"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.forceErrorTangent"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
 Axial Force all,"SELECT ""measured0"",""measured1"",""measured2"",""measured3"",""measured4"",""measured5"",""measured6"",""measured7"",""measured8"",""measured9"",""measured10"",""measured11"",""measured12"",""measured13"",""measured14"",""measured15"",""measured16"",""measured17"",""measured18"",""measured19"",""measured20"",""measured21"",""measured22"",""measured23"",""measured24"",""measured25"",""measured26"",""measured27"",""measured28"",""measured29"",""measured30"",""measured31"",""measured32"",""measured33"",""measured34"",""measured35"",""measured36"",""measured37"",""measured38"",""measured39"",""measured40"",""measured41"",""measured42"",""measured43"",""measured44"",""measured45"",""measured46"",""measured47"",""measured48"",""measured49"",""measured50"",""measured51"",""measured52"",""measured53"",""measured54"",""measured55"",""measured56"",""measured57"",""measured58"",""measured59"",""measured60"",""measured61"",""measured62"",""measured63"",""measured64"",""measured65"",""measured66"",""measured67"",""measured68"",""measured69"",""measured70"",""measured71"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.axialForce"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Log Message,"SELECT ""message"", ""level"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_logMessage"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Inclination Telemetry Source,"SELECT ""source"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_inclinationTelemetrySource"" ORDER BY DESC LIMIT 6",influxql
Net Moments Total,"SELECT ""mx"", ""my"", ""mz"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.netMomentsTotal"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Measured Axail actuators Forces,"SELECT /measured/ FROM ""efd"".""autogen"".""lsst.sal.MTM2.axialForce"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Mirror Position IMS,"SELECT ""x"", ""xRot"", ""y"", ""yRot"", ""z"", ""zRot"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.positionIMS"" ORDER BY DESC LIMIT 3",influxql
Assembly in Position,"SELECT ""inPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_m2AssemblyInPosition"" ORDER BY DESC LIMIT 3",influxql
Mirror Position,"SELECT ""x"", ""y"", ""z"", ""xRot"", ""yRot"", ""zRot"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.position"" ORDER BY DESC LIMIT 3",influxql
Summary State,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_summaryState"" ORDER BY DESC LIMIT 10",influxql
Intake/Exhaust Temperatures,"SELECT /exhaust/, /intake/ FROM ""efd"".""autogen"".""lsst.sal.MTM2.temperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Elevation Angle measured by M2,"SELECT ""inclinometerProcessed"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.zenithAngle"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Heartbeat,"SELECT ""heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Commandable by DDS,"SELECT ""state""  FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_commandableByDDS"" ORDER BY DESC LIMIT 3",influxql
Interlock,"SELECT ""state"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_interlock"" ORDER BY DESC LIMIT 10",influxql
IMS RBP,"SELECT ""x"",""y"",""z"",""xRot"", ""yRot"", ""zRot"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.positionIMS"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
Tangent Fault,"SELECT ""sum"", ""weight"", ""force0"",""force1"", ""force2"",""force3"", ""force4"", ""force5"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.forceErrorTangent"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
TMA Elevation Position,"SELECT ""actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Power Current,"SELECT ""motorCurrent"", ""commCurrent"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.powerStatus"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Temperature high warning,"SELECT ""hiWarning"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_cellTemperatureHiWarning"" ORDER BY DESC LIMIT 5",influxql
Ring Temperatures,"SELECT /ring/ FROM ""efd"".""autogen"".""lsst.sal.MTM2.temperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Fault Reports,"SELECT ""errorCode"", ""errorReport"", ""traceback"" FROM ""efd"".""autogen"".""lsst.sal.:CSCList:.logevent_errorCode"" ORDER BY time DESC LIMIT 10",influxql
MTAOS command_addAberration.config,"SELECT ""config"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.command_addAberration"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
command addAberration wfX,"SELECT ""wf1"", ""wf2"", ""wf3"", ""wf4"", ""wf5"", ""wf6"", ""wf7"", ""wf8"", ""wf9"", ""wf18"", ""wf17"", ""wf16"", ""wf15"", ""wf14"", ""wf13"", ""wf12"", ""wf11"", ""wf10"", ""wf0"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.command_addAberration"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTAOS M1M3 forces,"SELECT mean(""zForces1"") AS ""mean_zForces1"", mean(""zForces10"") AS ""mean_zForces10"", mean(""zForces100"") AS ""mean_zForces100"", mean(""zForces150"") AS ""mean_zForces150"", mean(""zForces30"") AS ""mean_zForces30"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_m1m3Correction"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
MTAOS heartbeat,"SELECT heartbeat FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_heartbeat"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
AOS,"SELECT appliedSettingsMatchStartIsTrue FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_appliedSettingsMatchStart"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
CameraHexapodCorrections,"SELECT ""u"", ""v"", ""w"", ""x"", ""y"", ""z"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_cameraHexapodCorrection"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Zernike Polinomials,"SELECT ""annularZernikeCoeff1"" AS ""Z01"",""annularZernikeCoeff1"" AS ""Z02"",""annularZernikeCoeff3"" AS ""Z03"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_wavefrontError"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
WEP Visit,"SELECT ""visitId"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.command_runWEP"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Settings,"SELECT ""recommendedSettingsLabels"", ""recommendedSettingsVersion"" FROM ""efd"".""autogen"".""lsst.sal.:CSCList:.logevent_settingVersions"" ORDER BY time DESC LIMIT 10",influxql
TMA Azimuth Torque,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.azimuth"")
  |> filter(fn: (r) => r[""_field""] == ""actualTorque"")


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
TMA Azimuth,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.azimuth"")
  |> filter(fn: (r) => r[""_field""] == ""actualPosition"")


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoints Forces,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /measuredForce./)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
TMA Elevation,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevation"")
  |> filter(fn: (r) => r[""_field""] == ""actualPosition"")

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
TMA Elevation Torque,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevation"")
  |> filter(fn: (r) => r[""_field""] == ""actualTorque"")

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
DAQ Store Capacity,"SELECT ""capacity"", ""freeSpace"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.daq_monitor_Store"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
DAQ Store Free Fraction,"SELECT ""freeFraction"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.daq_monitor_Store"" ORDER BY time DESC LIMIT 1",influxql
Streaming Mode sequence,"SELECT ""expTime"" FROM ""efd"".""autogen"".""lsst.sal.GenericCamera.logevent_streamingModeStarted"" WHERE salIndex = :salIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
Streaming Mode sequence,"SELECT ""avgFrameRate"", ""numFrames"" FROM ""efd"".""autogen"".""lsst.sal.GenericCamera.logevent_streamingModeStopped"" WHERE salIndex = :salIndex: AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Spectrum Analyzer,"from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart)
  |> filter(fn: (r) => r._measurement == ""lsst.sal.ESS.spectrumAnalyzer"" and r._field =~ /spectrum*/ )
  |> pivot(rowKey:[""_time""], columnKey: [""_field""], valueColumn: ""_value"")",flux
Spectrum Analyzer (clone 1),"from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart)
  |> filter(fn: (r) => r._measurement == ""lsst.sal.ESS.spectrumAnalyzer"" and r._field =~ /spectrum*/ )
  |> pivot(rowKey:[""_time""], columnKey: [""_field""], valueColumn: ""_value"")",flux
Untitled Graph,"SELECT mean(""ambientTemperature"") AS ""mean_ambientTemperature"", mean(""supplyTemperature"") AS ""mean_supplyTemperature"", mean(""setTemperature"") AS ""mean_setTemperature"" FROM ""efd"".""autogen"".""lsst.sal.ATWhiteLight.chillerTemperatures"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M3 encoders!!,"SELECT mean(""m3Encoder12"") AS ""mean_m3Encoder12"", mean(""m3Encoder13"") AS ""mean_m3Encoder13"", mean(""m3Encoder14"") AS ""mean_m3Encoder14"", mean(""m3Encoder15"") AS ""mean_m3Encoder15"", mean(""m3Encoder16"") AS ""mean_m3Encoder16"", mean(""m3Encoder17"") AS ""mean_m3Encoder17"", mean(""m3Encoder1"") AS ""mean_m3Encoder1"", mean(""m3Encoder10"") AS ""mean_m3Encoder10"", mean(""m3Encoder11"") AS ""mean_m3Encoder11"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.nasymth_m3_mountMotorEncoders"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
DropOut Door Opening Percentage,"SELECT (""dropoutDoorOpeningPercentage"") AS ""dropoutDoorOpeningPercentage"" FROM ""efd"".""autogen"".""lsst.sal.ATDome.position"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
Main Door Opening Percentage,"SELECT (""mainDoorOpeningPercentage"") AS ""Main Door Opening Percentage"" FROM ""efd"".""autogen"".""lsst.sal.ATDome.position"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
Focus Offset Summary - Total and User Applied,"SELECT (""total"") AS ""mean_total"", (""userApplied"") AS ""mean_userApplied"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_focusOffsetSummary"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
"Tracking errors x, y & z","SELECT (""positionFollowingError0"") AS ""Trackingerror in x"", (""positionFollowingError1"") AS ""Tracking Error in y"", (""positionFollowingError2"") AS ""tracking error in z"" FROM ""efd"".""autogen"".""lsst.sal.ATHexapod.positionStatus"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
"Correction Offsets (x, y, z) (mm)","SELECT (""x"") AS ""x"", (""y"") AS ""y"", (""z"") AS ""z"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_correctionOffsets"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
Nasmyth Angle,"SELECT (""nasmyth1CalculatedAngle99"") AS ""Rotator Position"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.mount_Nasmyth_Encoders"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
Azimuth & Elevation,"SELECT (""azimuthCalculatedAngle99"") AS ""az"", (""elevationCalculatedAngle99"") AS ""el"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.mount_AzEl_Encoders"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
Hexapod x y & z Reported Positions (mm),"SELECT (""reportedPosition0"") AS ""x"", (""reportedPosition1"") AS ""y"", (""reportedPosition2"") AS ""z"" FROM ""efd"".""autogen"".""lsst.sal.ATHexapod.positionStatus"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
Wind Direction min/max & Wind gust direction,"SELECT (""min2M"") AS ""min2M"", (""max2M"") AS ""max2M"" FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.windDirection"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Wind Direction min/max & Wind gust direction,"SELECT (""value10M"") AS ""value10M"" FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.windGustDirection"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: ",influxql
Sonic Temperature Standard Deviation,"SELECT mean(""sonicTemperatureStdDev"") AS ""sonicT_Sigma_gill""FROM ""efd"".""autogen"".""lsst.sal.ESS.airTurbulence"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 110 GROUP BY time(:interval:) FILL(null)",influxql
Wind Speed Magnitude,"SELECT mean(""speedMagnitude"") AS ""mean_speedMagnitude_gill""FROM ""efd"".""autogen"".""lsst.sal.ESS.airTurbulence"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 110 GROUP BY time(:interval:) FILL(null)",influxql
CSC Messages,"SELECT ""message"", ""traceback"" FROM ""efd"".""autogen"".""lsst.sal.ESS.logevent_logMessage"" WHERE salIndex = 110 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Sonic Temperature,"SELECT mean(""sonicTemperature"") AS ""mean_sonic_temperature_gill"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airTurbulence"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 110 GROUP BY time(:interval:) FILL(null)",influxql
Wind Speeds - Gill,"SELECT mean(""speed0"") AS ""mean_speed0"", mean(""speed1"") AS ""mean_speed1"", mean(""speed2"") AS ""mean_speed2"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airTurbulence"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND salIndex = 110 GROUP BY time(:interval:) FILL(null)",influxql
zPosition,"SELECT mean(""zPosition"") AS ""mean_zPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.imsData"" WHERE :m1m3_test: GROUP BY time(1s) FILL(null)",influxql
yPosition,"SELECT mean(""yPosition"") AS ""mean_yPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.imsData"" WHERE :m1m3_test: GROUP BY time(1s) FILL(null)",influxql
xPosition,"SELECT mean(""xPosition"") AS ""mean_xPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.imsData"" WHERE :m1m3_test: GROUP BY time(1s) FILL(null)",influxql
Dome Position,"SELECT ""positionActual"", ""positionCommanded"" FROM ""efd"".""autogen"".""lsst.sal.MTDome.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dome Drives Currents,"SELECT ""driveCurrentActual0"", ""driveCurrentActual1"", ""driveCurrentActual2"", ""driveCurrentActual3"", ""driveCurrentActual4"" FROM ""efd"".""autogen"".""lsst.sal.MTDome.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dome Velocity,"SELECT ""velocityActual"" FROM ""efd"".""autogen"".""lsst.sal.MTDome.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Wind Speed,"SELECT ""value"",""min2M"",""avg2M"",""avg10M"" FROM ""efd"".""autogen"".""lsst.sal.Environment.windSpeed"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Wind Speed (clone 1),"SELECT mean(""avg10M"") AS ""mean_avg10M"", mean(""avg2M"") AS ""mean_avg2M"", mean(""min2M"") AS ""mean_min2M"", mean(""value"") AS ""mean_value"" FROM ""efd"".""autogen"".""lsst.sal.Environment.windSpeed"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Axial Actuators Applied Forces,"SELECT ""applied0"",""applied1"",""applied2"",""applied3"",""applied4"",""applied5"",""applied6"",""applied7"",""applied8"",""applied9"",""applied10"",""applied11"",""applied12"",""applied13"",""applied14"",""applied15"",""applied16"",""applied17"",""applied18"",""applied19"",""applied20"",""applied21"",""applied22"",""applied23"",""applied24"",""applied25"",""applied26"",""applied27"",""applied28"",""applied29"",""applied30"",""applied31"",""applied32"",""applied33"",""applied34"",""applied35"",""applied36"",""applied37"",""applied38"",""applied39"",""applied40"",""applied41"",""applied42"",""applied43"",""applied44"",""applied45"",""applied46"",""applied47"",""applied48"",""applied49"",""applied50"",""applied51"",""applied52"",""applied53"",""applied54"",""applied55"",""applied56"",""applied57"",""applied58"",""applied59"",""applied60"",""applied61"",""applied62"",""applied63"",""applied64"",""applied65"",""applied66"",""applied67"",""applied68"",""applied69"",""applied70"",""applied71"",""applied72"",""applied73"",""applied74"",""applied75"",""applied76"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.axialForce"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Axial Actuators Measured Forces,"SELECT ""measured0"",""measured1"", ""measured2"", ""measured3"", ""measured4"", ""measured5"", ""measured6"", ""measured7"", ""measured8"", ""measured9"", ""measured10"", ""measured11"", ""measured12"", ""measured13"", ""measured14"", ""measured15"", ""measured16"", ""measured17"", ""measured18"", ""measured19"", ""measured20"",""measured21"", ""measured22"", ""measured23"", ""measured24"", ""measured25"", ""measured26"", ""measured27"", ""measured28"", ""measured29"", ""measured30"",""measured31"", ""measured32"", ""measured33"", ""measured34"", ""measured35"", ""measured36"", ""measured37"", ""measured38"", ""measured39"", ""measured40"",""measured41"", ""measured42"", ""measured43"", ""measured44"", ""measured45"", ""measured46"", ""measured47"", ""measured48"", ""measured49"", ""measured50"",""measured51"", ""measured52"", ""measured53"", ""measured54"", ""measured55"", ""measured56"", ""measured57"", ""measured58"", ""measured59"", ""measure60"",""measured61"", ""measured62"", ""measured63"", ""measured64"", ""measured65"", ""measured66"", ""measured67"", ""measured68"", ""measured69"", ""measured70"", ""measured71"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.axialForce"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dropout Shutter Open Percentage,"SELECT ""dropoutDoorOpeningPercentage"" FROM ""efd"".""autogen"".""lsst.sal.ATDome.position"" ORDER BY time DESC LIMIT 1",influxql
Dome Status,"SELECT ""inPosition"" FROM ""efd"".""autogen"".""lsst.sal.ATDome.logevent_allAxesInPosition"" ORDER BY time DESC LIMIT 1",influxql
Azimuth Position,"SELECT ""azimuthPosition"" FROM ""efd"".""autogen"".""lsst.sal.ATDome.position"" ORDER BY time DESC LIMIT 1",influxql
Main Shutter Open Percentage,"SELECT ""mainDoorOpeningPercentage"" FROM ""efd"".""autogen"".""lsst.sal.ATDome.position"" ORDER BY time DESC LIMIT 1",influxql
Ambient Air Temperature above M1M3 RoC (<1C/hr),"SELECT difference(last(""temperatureItem0"")) FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 113 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(1h)",influxql
M1M3 temps,"SELECT mean(""temperatureItem0"") AS ""Outside air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 temps,"SELECT mean(""temperatureItem0"") AS ""M1M3 air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 113 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 temps,"SELECT mean(""absoluteTemperature0"") AS ""mean_absoluteTemperature0"", mean(""absoluteTemperature10"") AS ""mean_absoluteTemperature10"", mean(""absoluteTemperature20"") AS ""mean_absoluteTemperature20"", mean(""absoluteTemperature30"") AS ""mean_absoluteTemperature30"", mean(""absoluteTemperature40"") AS ""mean_absoluteTemperature40"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.thermalData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Glycol delivered temp vs. ambient,"SELECT mean(""glycolTemperaturePier0001"") AS ""Glycol General Temp 0001"", mean(""glycolTemperaturePier0002"") AS ""Glycol General Temp 0002"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.generalPurposeGlycolWater"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Glycol delivered temp vs. ambient,"SELECT mean(""ambientTemperature"") AS ""Azimuth Floor Air Ambient Temp"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.topEndChiller"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Glycol delivered temp vs. ambient,"SELECT mean(""glycolTemperaturePier0101"") AS ""Cold Glycol Temp 0101"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.cooling"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Glycol delivered temp vs. ambient,"SELECT mean(""absoluteTemperature0"") AS ""mean_absoluteTemperature0"", mean(""absoluteTemperature1"") AS ""mean_absoluteTemperature1"", mean(""absoluteTemperature10"") AS ""mean_absoluteTemperature10"", mean(""absoluteTemperature11"") AS ""mean_absoluteTemperature11"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.thermalData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""temperatureItem0"") AS ""Outside air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""temperatureItem0"") AS ""Camera air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 111 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""temperatureItem0"") AS ""M2 air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 112 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""temperatureItem0"") AS ""M1M3 air temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 113 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""mainCabinetExternalTemperature"") AS ""Tekniker Cabinet External air temp"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.mainCabinetThermal"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Inside/Outside Temps,"SELECT mean(""ambientTemperature"") AS ""Azimuth Floor Air Ambient Temp"", mean(""ambientTemperatureSensor0502"") AS ""Top End Hex Return air temp"", mean(""temperatureSensor0501"") AS ""Top End Rear air temp"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.topEndChiller"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Chiller 1/2,"SELECT mean(""setpointActivo"") AS ""mean_setpointActivo"", mean(""temperaturaAguaImpulsionEvaporador"") AS ""mean_temperaturaAguaImpulsionEvaporador"", mean(""temperaturaAguaRetornoEvaporador"") AS ""mean_temperaturaAguaRetornoEvaporador"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.chiller01P01"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Chiller 1/2,"SELECT mean(""setpointActivo"") AS ""mean_setpointActivo"", mean(""temperaturaAguaImpulsionEvaporador"") AS ""mean_temperaturaAguaImpulsionEvaporador"", mean(""temperaturaAguaRetornoEvaporador"") AS ""mean_temperaturaAguaRetornoEvaporador"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.chiller02P01"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Chiller 3,"SELECT mean(""setpointActivo"") AS ""mean_setpointActivo"", mean(""temperaturaAguaImpulsionEvaporador"") AS ""mean_temperaturaAguaImpulsionEvaporador"", mean(""temperaturaAguaRetornoEvaporador"") AS ""mean_temperaturaAguaRetornoEvaporador"" FROM ""efd"".""autogen"".""lsst.sal.HVAC.chiller03P01"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Outside Temperature RoC (<1.0C/hr),"SELECT difference(last(""temperatureItem0"")) FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(1h)",influxql
M1M3 Internal Air Cell Temperature RoC (<0.75C/hr),"SELECT difference(last(""absoluteTemperature0"")), difference(last(""absoluteTemperature1"")), difference(last(""absoluteTemperature2"")), difference(last(""absoluteTemperature3"")) , difference(last(""absoluteTemperature4"")) , difference(last(""absoluteTemperature5"")) , difference(last(""absoluteTemperature6"")) , difference(last(""absoluteTemperature7"")) , difference(last(""absoluteTemperature8"")) , difference(last(""absoluteTemperature9"")) , difference(last(""absoluteTemperature10"")) , difference(last(""absoluteTemperature11"")) , difference(last(""absoluteTemperature12"")) , difference(last(""absoluteTemperature13"")) , difference(last(""absoluteTemperature14"")) , difference(last(""absoluteTemperature15"")) , difference(last(""absoluteTemperature16"")) , difference(last(""absoluteTemperature17"")) , difference(last(""absoluteTemperature18"")) , difference(last(""absoluteTemperature19"")) , difference(last(""absoluteTemperature20"")) , difference(last(""absoluteTemperature21"")) , difference(last(""absoluteTemperature22"")) , difference(last(""absoluteTemperature23"")) , difference(last(""absoluteTemperature24"")) , difference(last(""absoluteTemperature25"")) , difference(last(""absoluteTemperature26"")) , difference(last(""absoluteTemperature27"")) , difference(last(""absoluteTemperature28"")) , difference(last(""absoluteTemperature29"")) , difference(last(""absoluteTemperature30"")) , difference(last(""absoluteTemperature31"")) , difference(last(""absoluteTemperature32"")) , difference(last(""absoluteTemperature33"")) , difference(last(""absoluteTemperature34"")) , difference(last(""absoluteTemperature35"")) , difference(last(""absoluteTemperature36"")) , difference(last(""absoluteTemperature37"")) , difference(last(""absoluteTemperature38"")) , difference(last(""absoluteTemperature39"")) , difference(last(""absoluteTemperature40"")) , difference(last(""absoluteTemperature41"")) , difference(last(""absoluteTemperature42"")) , difference(last(""absoluteTemperature43"")) , difference(last(""absoluteTemperature44"")) , difference(last(""absoluteTemperature45"")) , difference(last(""absoluteTemperature46"")) , difference(last(""absoluteTemperature47"")) , difference(last(""absoluteTemperature48"")) , difference(last(""absoluteTemperature49"")) , difference(last(""absoluteTemperature50"")) , difference(last(""absoluteTemperature51"")) , difference(last(""absoluteTemperature52"")) , difference(last(""absoluteTemperature53"")) , difference(last(""absoluteTemperature54"")) , difference(last(""absoluteTemperature55"")) , difference(last(""absoluteTemperature56"")) , difference(last(""absoluteTemperature57"")) , difference(last(""absoluteTemperature58"")) , difference(last(""absoluteTemperature59"")) , difference(last(""absoluteTemperature60"")) , difference(last(""absoluteTemperature61"")) , difference(last(""absoluteTemperature62"")) , difference(last(""absoluteTemperature63"")) , difference(last(""absoluteTemperature64"")) , difference(last(""absoluteTemperature65"")) , difference(last(""absoluteTemperature66"")) , difference(last(""absoluteTemperature67"")) , difference(last(""absoluteTemperature68"")) , difference(last(""absoluteTemperature69"")) , difference(last(""absoluteTemperature70"")) , difference(last(""absoluteTemperature71"")) , difference(last(""absoluteTemperature72"")) , difference(last(""absoluteTemperature73"")) , difference(last(""absoluteTemperature74"")) , difference(last(""absoluteTemperature75"")) , difference(last(""absoluteTemperature76"")) , difference(last(""absoluteTemperature77"")) , difference(last(""absoluteTemperature78"")) , difference(last(""absoluteTemperature79"")) , difference(last(""absoluteTemperature80"")) , difference(last(""absoluteTemperature81"")) , difference(last(""absoluteTemperature82"")) , difference(last(""absoluteTemperature83"")) , difference(last(""absoluteTemperature84"")) , difference(last(""absoluteTemperature85"")) , difference(last(""absoluteTemperature86"")) , difference(last(""absoluteTemperature87"")) , difference(last(""absoluteTemperature88"")) , difference(last(""absoluteTemperature89"")) , difference(last(""absoluteTemperature90"")) , difference(last(""absoluteTemperature91"")), difference(last(""absoluteTemperature92"")) , difference(last(""absoluteTemperature93"")) , difference(last(""absoluteTemperature94"")) , difference(last(""absoluteTemperature95""))    FROM ""efd"".""autogen"".""lsst.sal.MTM1M3TS.thermalData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(1h)",influxql
Outside Temperature RoC (1 min sampling),"SELECT difference(last(""temperatureItem0"")) FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(1m)",influxql
Flux,"SELECT fluxL, fluxR FROM ""efd"".""autogen"".""lsst.sal.DIMM.logevent_dimmMeasurement"" WHERE time > :start:",influxql
Seeing,"SELECT ""fwhm"" FROM ""efd"".""autogen"".""lsst.sal.DIMM.logevent_dimmMeasurement"" WHERE time > :start:",influxql
rotator rotation,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.rotation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Detailed State,"SELECT ""detailedState"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_detailedState"" ORDER BY DESC LIMIT 1",influxql
Inclination TelemetrySo urce,"SELECT ""source"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_inclinationTelemetrySource"" ORDER BY DESC LIMIT 1",influxql
Net Moments Total,"SELECT ""mx"", ""my"", ""mz"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.netMomentsTotal"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Net Forces Total,"SELECT ""fx"", ""fy"", ""fz"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.netForcesTotal"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
TcpIpConnected,"SELECT ""isConnected"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_tcpIpConnected"" ORDER BY DESC LIMIT 1",influxql
Power Status (Voltage),"SELECT ""motorVoltage"", ""commVoltage"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.powerStatus"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
 Axial Force 0,"SELECT ""applied0"", ""lutGravity0"", ""hardpointCorrection0"", ""lutTemperature0"", ""measured0"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.axialForce"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Mirror Position IMS,"SELECT ""x"", ""xRot"", ""y"", ""yRot"", ""z"", ""zRot"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.positionIMS"" ORDER BY DESC LIMIT 3",influxql
Assembly in Position,"SELECT ""inPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_m2AssemblyInPosition"" ORDER BY DESC LIMIT 1",influxql
Applied Settings Match,"SELECT ""appliedSettingsMatchStartIsTrue"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_appliedSettingsMatchStart"" ORDER BY DESC LIMIT 1",influxql
Mirror Position,"SELECT ""x"", ""y"", ""z"", ""xRot"", ""yRot"", ""zRot"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.position"" ORDER BY DESC LIMIT 3",influxql
Error Code,"SELECT ""errorCode"", ""errorReport"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_errorCode"" ORDER BY DESC LIMIT 3",influxql
Summary State,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
Temperatures,"SELECT ""exhaust0"", ""exhaust1"", ""intake0"", ""intake1"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.temperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Zenith Angle,"SELECT ""measured"", ""inclinometerProcessed"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.zenithAngle"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Heartbeat,"SELECT ""heartbeat"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_heartbeat"" ORDER BY DESC LIMIT 1",influxql
Commandable by DDS,"SELECT ""state""  FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_commandableByDDS"" ORDER BY DESC LIMIT 1",influxql
Interlock,"SELECT ""state"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_interlock"" ORDER BY DESC LIMIT 1",influxql
Mount Status,"SELECT (""summaryState"") AS ""mean_summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_summaryState"" order by desc limit 1",influxql
Mount elevation,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
rotator status,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_summaryState"" order by desc limit 1",influxql
Ptg status,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTPtg.logevent_summaryState"" order by desc limit 1",influxql
CCW position,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.cameraCableWrap"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
axial steps,"SELECT mean(""steps0"") AS ""mean_steps0"", mean(""steps10"") AS ""mean_steps10"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.axialActuatorSteps"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
tangent steps,"SELECT mean(""steps0"") AS ""mean_steps0"", mean(""steps4"") AS ""mean_steps4"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.tangentActuatorSteps"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
axial encoder,"SELECT mean(""position0"") AS ""mean_position0"", mean(""position1"") AS ""mean_position1"", mean(""position10"") AS ""mean_position10"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.axialEncoderPositions"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
tangent encoder,"SELECT mean(""position0"") AS ""mean_position0"", mean(""position4"") AS ""mean_position4"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.tangentEncoderPositions"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
power,"SELECT mean(""motorVoltage"") AS ""mean_motorVoltage"", mean(""motorCurrent"") AS ""mean_motorCurrent"", mean(""commCurrent"") AS ""mean_commCurrent"", mean(""commVoltage"") AS ""mean_commVoltage"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.powerStatus"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
FB,"SELECT mean(""hardpointCorrection0"") AS ""mean_hardpointCorrection0"", mean(""hardpointCorrection39"") AS ""mean_hardpointCorrection39"", mean(""hardpointCorrection67"") AS ""mean_hardpointCorrection67"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.axialForce"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
accelerationX (SST spider spindle),"SELECT /accelerationX/ FROM ""efd"".""autogen"".""lsst.sal.ESS.accelerometer"" WHERE salIndex = 104 AND sensorName =~ /^SST spider spindle/ AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
accelerationY (SST Spider Spindle),"SELECT /accelerationY/ FROM ""efd"".""autogen"".""lsst.sal.ESS.accelerometer"" WHERE salIndex = 104 AND sensorName =~ /^SST spider spindle/ AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
accelerationZ (SST Spider Spindle),"SELECT /accelerationZ/ FROM ""efd"".""autogen"".""lsst.sal.ESS.accelerometer"" WHERE salIndex = 104 AND sensorName =~ /^SST spider spindle/ AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Elevation Position (clone 1),"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Current,"SELECT mean(""powerSupplyCurrent"") AS ""mean_powerSupplyCurrent"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.mainPowerSupply"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Voltage,"SELECT mean(""powerSupplyVoltage"") AS ""mean_powerSupplyVoltage"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.mainPowerSupply"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Elevation Position,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Main Power Supply Voltage,"SELECT mean(""powerSupplyVoltage"") AS ""mean_powerSupplyVoltage"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.mainPowerSupply"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 Mirror Cover Status,"SELECT mean(""actualPosition0"") AS ""mean_actualPosition0"", mean(""actualPosition1"") AS ""mean_actualPosition1"", mean(""actualPosition2"") AS ""mean_actualPosition2"", mean(""actualPosition3"") AS ""mean_actualPosition3"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.mirrorCover"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
M1M3 Hardpoint Forces,"SELECT mean(""measuredForce0"") AS ""mean_measuredForce0"", mean(""measuredForce1"") AS ""mean_measuredForce1"", mean(""measuredForce3"") AS ""mean_measuredForce3"", mean(""measuredForce2"") AS ""mean_measuredForce2"", mean(""measuredForce4"") AS ""mean_measuredForce4"", mean(""measuredForce5"") AS ""mean_measuredForce5"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Elevation Encoders,"SELECT mean(""elevationEncoderAbsolutePosition0"") AS ""mean_elevationEncoderAbsolutePosition0"", mean(""elevationEncoderAbsolutePosition1"") AS ""mean_elevationEncoderAbsolutePosition1"", mean(""elevationEncoderAbsolutePosition2"") AS ""mean_elevationEncoderAbsolutePosition2"", mean(""elevationEncoderAbsolutePosition3"") AS ""mean_elevationEncoderAbsolutePosition3"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.encoder"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Elevation Encoders,"SELECT ""actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Elevation Velocity,"SELECT ""demandVelocity"", ""actualVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Azimuth Velocity,"SELECT ""actualVelocity"", ""demandVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Rotator ,"SELECT ""actualPosition"", ""demandPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.rotation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Elevation,"SELECT mean(""demandPosition"") AS ""mean_demandPosition"", mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Azimuth,"SELECT mean(""demandPosition"") AS ""mean_demandPosition"", mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Rotator Status,"SELECT ""inPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_inPosition"" ORDER BY time DESC LIMIT 1",influxql
Rotator Angle,"SELECT ""position"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_target"" ORDER BY time DESC LIMIT 1",influxql
Mount Status,"SELECT ""inPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_azimuthInPosition"" ORDER BY time DESC LIMIT 1",influxql
Mount Status,"SELECT ""inPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_elevationInPosition"" ORDER BY time DESC LIMIT 1",influxql
Rotator Angle Velocity,"SELECT ""velocity"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.logevent_target"" ORDER BY time DESC LIMIT 1",influxql
CCW,"SELECT ""actualPosition"", ""demandPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.cameraCableWrap"" WHERE time > :dashboardTime: ",influxql
"logevent_cameraCableWrapTarget, position an velocity","SELECT ""position"", ""velocity"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_cameraCableWrapTarget"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Main Cabinet Internal Temperature,"SELECT mean(""mainCabinetExternalTemperature"") AS ""mean_mainCabinetExternalTemperature"", mean(""mainCabinetInternalTemperature0"") AS ""mean_mainCabinetInternalTemperature0"", mean(""mainCabinetInternalTemperature1"") AS ""mean_mainCabinetInternalTemperature1"", mean(""setpointTemperature"") AS ""mean_setpointTemperature"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.mainCabinetThermal"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Azimuth Encoders,"SELECT mean(""azimuthEncoderAbsolutePosition0"") AS ""mean_azimuthEncoderAbsolutePosition0"", mean(""azimuthEncoderAbsolutePosition1"") AS ""mean_azimuthEncoderAbsolutePosition1"", mean(""azimuthEncoderAbsolutePosition2"") AS ""mean_azimuthEncoderAbsolutePosition2"", mean(""azimuthEncoderAbsolutePosition3"") AS ""mean_azimuthEncoderAbsolutePosition3"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.encoder"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Azimuth Encoders,"SELECT ""actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
M2  CLOSE LOOP STATUS,"SELECT ""mode"" FROM ""efd"".""autogen"".""lsst.sal.MTM2.logevent_closedLoopControlMode"" ORDER BY time DESC LIMIT 1",influxql
Azimuth Motion State,"from(bucket: ""efd/autogen"")
  |> range(start: -30d)
  |> filter(fn: (r) => r[""_measurement""] =~ /lsst.sal.MTDome.logevent_azMotion/ )
  |> last()
  |> pivot(rowKey: [""_measurement""], columnKey: [""_field""], valueColumn: ""_value"")
  |> group()
  |> map(fn: (r) => ({
    r with
    ""1"": 
      if r.state == 1 then ""ERROR""
      else if r.state == 2 then ""CLOSED""
      else if r.state == 3 then ""CLOSING""
      else if r.state == 4 then ""CRAWLING""
      else if r.state == 5 then ""MOVING""
      else if r.state == 6 then ""OPEN""
      else if r.state == 7 then ""OPENING""
      else if r.state == 8 then ""PARKED""
      else if r.state == 9 then ""PARKING""
      else if r.state == 10 then ""STOPPED""
      else if r.state == 11 then ""STOPPING""
      else if r.state == 12 then ""STOPPING_BRAKING""
      else if r.state == 13 then ""STOPPED_BRAKED""
      else if r.state == 14 then ""BRAKE_DISENGAGED""
      else if r.state == 15 then ""BRAKES_DISENGAGED""
      else if r.state == 16 then ""BRAKE_ENGAGED""
      else if r.state == 17 then ""BRAKES_ENGAGED""
      else if r.state == 18 then ""DEFLATED""
      else if r.state == 19 then ""DEFLATING""
      else if r.state == 20 then ""DISABLING_MOTOR_POWER""
      else if r.state == 21 then ""DISENGAGING_BRAKE""
      else if r.state == 22 then ""DISENGAGING_BRAKES""
      else if r.state == 23 then ""ENABLING_MOTOR_POWER""
      else if r.state == 24 then ""ENGAGING_BRAKE""
      else if r.state == 25 then ""ENGAGING_BRAKES""
      else if r.state == 26 then ""FINAL_DOWN_CLOSE_LS_ENGAGED""
      else if r.state == 27 then ""FINAL_DOWN_OPEN_LS_ENGAGED""
      else if r.state == 28 then ""FINAL_UP_CLOSE_LS_ENGAGED""
      else if r.state == 29 then ""FINAL_UP_OPEN_LS_ENGAGED""
      else if r.state == 30 then ""GLYCOL_FLOWING""
      else if r.state == 31 then ""GO_DEGRADED""
      else if r.state == 32 then ""GO_NORMAL""
      else if r.state == 33 then ""GO_STATIONARY""
      else if r.state == 34 then ""INCLINED""
      else if r.state == 35 then ""INFLATED""
      else if r.state == 36 then ""INFLATING""
      else if r.state == 37 then ""LP_DISENGAGED""
      else if r.state == 38 then ""LP_DISENGAGING""
      else if r.state == 39 then ""LP_ENGAGED""
      else if r.state == 40 then ""LP_ENGAGING""
      else if r.state == 41 then ""MOTOR_COOLING_OFF""
      else if r.state == 42 then ""MOTOR_COOLING_ON""
      else if r.state == 43 then ""MOTOR_POWER_OFF""
      else if r.state == 44 then ""MOTOR_POWER_ON""
      else if r.state == 45 then ""PROXIMITY_CLOSED_LS_ENGAGED""
      else if r.state == 46 then ""PROXIMITY_OPEN_LS_ENGAGED""
      else if r.state == 47 then ""STARTING_MOTOR_COOLING""
      else if r.state == 48 then ""STOPPING_MOTOR_COOLING""
      else if r.state == 49 then ""UNDETERMINED""
      else if r.state == 50 then ""VERTICAL""
      else if r.state == 51 then ""WAITING_AMCS_STATIONARY""
      else if r.state == 52 then ""DISABLED""
      else if r.state == 53 then ""DISABLING""
      else if r.state == 54 then ""ENABLED""
      else if r.state == 55 then ""ENABLING""
      else ""UNKNOWN"",
    })
  )
  |> keep(columns: [
    ""1"", 
  ])
",flux
Drive Temperatures,"SELECT ""driveTemperature0"", ""driveTemperature1"", ""driveTemperature10"", ""driveTemperature11"", ""driveTemperature12"", ""driveTemperature2"", ""driveTemperature3"", ""driveTemperature4"", ""driveTemperature5"", ""driveTemperature6"", ""driveTemperature7"", ""driveTemperature8"", ""driveTemperature9"" FROM ""efd"".""autogen"".""lsst.sal.MTDome.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Azimuth Drive Currents,"SELECT ""driveCurrentActual0"", ""driveCurrentActual1"", ""driveCurrentActual2"", ""driveCurrentActual3"", ""driveCurrentActual4"" FROM ""efd"".""autogen"".""lsst.sal.MTDome.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Azimuth Control Software Status,"from(bucket: ""efd/autogen"")
  |> range(start: -30d)
  |> filter(fn: (r) => r[""_measurement""] =~ /lsst.sal.MTDome.logevent_azEnabled/ )
  |> last()
  |> pivot(rowKey: [""_measurement""], columnKey: [""_field""], valueColumn: ""_value"")
  |> group()
  |> map(fn: (r) => ({
    r with
    ""1"": 
      if r.state == 1.00 then ""DISABLED""
      else if r.state == 2.00 then ""ENABLED""
      else if r.state == 3.00 then ""FAULT""
      else ""UNKNOWN"",
    ""2"": r.faultCode,
    })
  )
  |> keep(columns: [
    ""1"", 
    ""2""
  ])
",flux
Azimuth Velocity,"SELECT ""velocityActual"", ""velocityCommanded"" FROM ""efd"".""autogen"".""lsst.sal.MTDome.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Azimuth Position,"SELECT ""positionActual"", ""positionCommanded"" FROM ""efd"".""autogen"".""lsst.sal.MTDome.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Fault Code ,"SELECT ""faultCode"" FROM ""efd"".""autogen"".""lsst.sal.MTDome.logevent_azEnabled"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Outside Temperature,"SELECT min(""temperatureItem0"") as ""maxAirTemperature"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:  FILL(null)",influxql
Speed,"SELECT ""speed"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Max Wind Speed,"SELECT ""maxSpeed"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Min Temperature,"SELECT min(""temperatureItem0"") as ""maxAirTemperature"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:  FILL(null)",influxql
Heartbeat DIMM,"SELECT count(""heartbeat"") FROM ""efd"".""autogen"".""lsst.sal.DIMM.logevent_heartbeat"" WHERE time > :dashboardTime: GROUP BY time(5s) ORDER BY DESC LIMIT 1",influxql
Seeing,"SELECT mean(""fwhm"") AS ""mean_fwhm"" FROM ""efd"".""autogen"".""lsst.sal.DIMM.logevent_dimmMeasurement"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(previous)",influxql
DIMM Seeing,"SELECT ""fwhm"" FROM ""efd"".""autogen"".""lsst.sal.DIMM.logevent_dimmMeasurement"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Heartbeat ESS:301,"SELECT count(""heartbeat"") FROM ""efd"".""autogen"".""lsst.sal.ESS.logevent_heartbeat"" WHERE salIndex = 301 AND time > :dashboardTime: GROUP BY time(5s) ORDER BY DESC LIMIT 1",influxql
Wind Direction,"SELECT mean(""direction"") AS ""mean_direction"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Dewpoint,"SELECT ""dewPointItem"" FROM ""efd"".""autogen"".""lsst.sal.ESS.dewPoint"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:  FILL(null)",influxql
Relative Humidity,"SELECT ""relativeHumidityItem"" FROM ""efd"".""autogen"".""lsst.sal.ESS.relativeHumidity"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Wind Direction,"SELECT ""direction"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow""  WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:  FILL(null)",influxql
Wind Speed,"SELECT ""speed"" FROM ""efd"".""autogen"".""lsst.sal.ESS.airFlow"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:  FILL(null)",influxql
Barometric Pressure,"SELECT ""pressureItem0"" / 100.0 FROM ""efd"".""autogen"".""lsst.sal.ESS.pressure"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Relative Humidity,"SELECT ""relativeHumidityItem"" FROM ""efd"".""autogen"".""lsst.sal.ESS.relativeHumidity""  WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:  FILL(null)",influxql
Max Temperature,"SELECT max(""temperatureItem0"") as ""maxAirTemperature"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: FILL(null)",influxql
Air Temperature,"SELECT ""temperatureItem0"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Air Temperature,"SELECT mean(""dewPointItem"") AS ""mean_dewPointItem"" FROM ""efd"".""autogen"".""lsst.sal.ESS.dewPoint"" WHERE salIndex = 301 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Rubin - Sun Elevation,"SELECT mean(""sunAltitude"") AS ""mean_sunAltitude"" FROM ""efd"".""autogen"".""lsst.sal.ATPtg.skyEnvironment"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Ingest sequence,"SELECT ""obsid"", ""statusCode"", ""description"" FROM ""efd"".""autogen"".""lsst.sal.ATOODS.logevent_imageInOODS"" WHERE time > :dashboardTime:",influxql
FWHMx & HWHMy,"SELECT mean(""flux"") AS ""mean_flux"", mean(""fwhmx"") AS ""mean_fwhmx"", mean(""fwhmy"") AS ""mean_fwhmy"" FROM ""efd"".""autogen"".""lsst.sal.DIMM.logevent_dimmMeasurement"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
dx & dy,"SELECT mean(""dx"") AS ""mean_dx"", mean(""dy"") AS ""mean_dy"" FROM ""efd"".""autogen"".""lsst.sal.DIMM.logevent_dimmMeasurement"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
FluxL & FluxR,"SELECT mean(""fluxL"") AS ""mean_fluxL"", mean(""fluxR"") AS ""mean_fluxR"" FROM ""efd"".""autogen"".""lsst.sal.DIMM.logevent_dimmMeasurement"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
DIMM Left Strehl,"SELECT ""strehlL"" FROM ""efd"".""autogen"".""lsst.sal.DIMM.logevent_dimmMeasurement"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
"RA, DEC, AZ, ALT","SELECT ""azimuth"", ""altitude"" FROM ""efd"".""autogen"".""lsst.sal.DIMM.status"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Log messages,"SELECT ""level"", ""message"", ""traceback""  FROM ""efd"".""autogen"".""lsst.sal.DIMM.logevent_logMessage"" WHERE salIndex = :SalIndex: ORDER BY DESC LIMIT 20",influxql
DIMM Summary State,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.DIMM.logevent_summaryState"" WHERE salIndex = :SalIndex: ORDER BY DESC LIMIT 1",influxql
Heartbeat (DIMM),"SELECT count(""heartbeat"") FROM ""efd"".""autogen"".""lsst.sal.DIMM.logevent_heartbeat"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(5s) ORDER BY DESC LIMIT 1",influxql
DIMM FWHM,"SELECT ""fwhm"" FROM ""efd"".""autogen"".""lsst.sal.DIMM.logevent_dimmMeasurement"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
DIMM Right Strehl,"SELECT ""strehlR"" FROM ""efd"".""autogen"".""lsst.sal.DIMM.logevent_dimmMeasurement"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Query by SAL Index,"SELECT ""salIndex"", ""level"", ""lineNumber"", ""name"", ""message"", ""traceback"", ""filePath"" FROM ""efd"".""autogen"".""lsst.sal.Script.logevent_logMessage"" WHERE time > :dashboardTime: AND  time < :upperDashboardTime: and salIndex =~ /:salindex:/",influxql
Query by BLOCK ID,"SELECT ""salIndex"", ""groupId"", ""reason"", ""lastCheckpoint"" FROM ""efd"".""autogen"".""lsst.sal.Script.logevent_state"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: AND lastCheckpoint =~ /:block:/",influxql
Calibrated Actuator Position,"SELECT ""calibrated0"", ""calibrated1"", ""calibrated2"", ""calibrated3"", ""calibrated4"", ""calibrated5"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.actuators"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Commanded vs Reached Position,"SELECT ""demand0"", ""demand1"", ""demand2"", ""demand3"", ""demand4"", ""demand5"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Commanded vs Reached Position,"SELECT ""position0"", ""position1"", ""position2"", ""position3"", ""position4"", ""position5"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTHexapod.application error,"SELECT mean(""error0"") AS ""mean_error0"", mean(""error1"") AS ""mean_error1"", mean(""error2"") AS ""mean_error2"", mean(""error3"") AS ""mean_error3"", mean(""error4"") AS ""mean_error4"", mean(""error5"") AS ""mean_error5"", mean(""demand0"") AS ""mean_demand0"", mean(""demand1"") AS ""mean_demand1"", mean(""demand2"") AS ""mean_demand2"", mean(""demand3"") AS ""mean_demand3"", mean(""demand4"") AS ""mean_demand4"", mean(""demand5"") AS ""mean_demand5"", mean(""position0"") AS ""mean_position0"", mean(""position1"") AS ""mean_position1"", mean(""position2"") AS ""mean_position2"", mean(""position3"") AS ""mean_position3"", mean(""position4"") AS ""mean_position4"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Motor voltages,"SELECT mean(""motorVoltage1"") AS ""mean_motorVoltage1"", mean(""motorVoltage2"") AS ""mean_motorVoltage2"", mean(""motorVoltage3"") AS ""mean_motorVoltage3"", mean(""motorVoltage4"") AS ""mean_motorVoltage4"", mean(""motorVoltage5"") AS ""mean_motorVoltage5"", mean(""motorVoltage0"") AS ""mean_motorVoltage0"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.electrical"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:sampling:) FILL(null)",influxql
Motor currents,"SELECT mean(""motorCurrent1"") AS ""mean_motorCurrent1"", mean(""motorCurrent2"") AS ""mean_motorCurrent2"", mean(""motorCurrent3"") AS ""mean_motorCurrent3"", mean(""motorCurrent4"") AS ""mean_motorCurrent4"", mean(""motorCurrent5"") AS ""mean_motorCurrent5"", mean(""motorCurrent0"") AS ""mean_motorCurrent0"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.electrical"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:sampling:) FILL(null)",influxql
"MTHexapod.logevent_uncompensatedPosition: u,v,w ","SELECT mean(u) as mean_u, mean(v) as mean_v, mean(w) as mean_w FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_uncompensatedPosition"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime:  GROUP BY time(:sampling:) FILL(null)",influxql
"logevent_compensatedPosition: u,v,w","SELECT mean(u) as mean_u ,mean(v) as mean_v, mean(w) as mean_w FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_compensatedPosition"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime:  GROUP BY time(:sampling:) FILL(null)",influxql
Pivot position,"SELECT pivotX, pivotY, pivotZ FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_configuration"" WHERE salIndex = :SalIndex: ORDER BY DESC LIMIT 20;",influxql
"Compensation inputs: Mount AZ,EL; Rotator angle","SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:sampling:) FILL(null)",influxql
"Compensation inputs: Mount AZ,EL; Rotator angle","SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
"Compensation inputs: Mount AZ,EL; Rotator angle","SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.rotation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Calibrated Actuator Position (linear encoder),"SELECT mean(calibrated0) as mean_calibrated0, mean(calibrated1) as mean_calibrated1, mean(calibrated2) as mean_calibrated2, mean(calibrated3) as mean_calibrated3, mean(calibrated4) as mean_calibrated4, mean(calibrated5) as mean_calibrated5 FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.actuators"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:sampling:) FILL(null)",influxql
Camera Hexapod Temperatures,"SELECT ""temperature5"" as ""Strut 12 temp"", ""temperature4"" as ""Strut 11 temp"", ""temperature3"" as ""Strut 10 temp"", ""temperature2"" as ""Strut 9 temp"", ""temperature1"" as ""Strut 8 temp"", ""temperature0"" as ""Strut 7 temp"" FROM ""efd"".""autogen"".""lsst.sal.ESS.temperature"" WHERE salIndex = 1 AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Camera Hexapod Temperatures,"SELECT mean(avg1M) as mean_airTemperature FROM ""efd"".""autogen"".""lsst.sal.WeatherStation.airTemperature"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
"MTHexapod.logevent_uncompensatedPosition: x,y,z","SELECT mean(x) as mean_x, mean(y) as mean_y, mean(z) as mean_z FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_uncompensatedPosition"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime:  GROUP BY time(:sampling:) FILL(null)",influxql
"MTHexapod.logevent_compensatedPosition, x,y,z","SELECT mean(x) as mean_x, mean(y) as mean_y, mean(z) as mean_z FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_compensatedPosition"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime:  GROUP BY time(:sampling:) FILL(null)",influxql
MTHexapod.command_setCompensationMode,"SELECT enable FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.command_setCompensationMode"" WHERE salIndex = :SalIndex: ORDER BY DESC LIMIT 20",influxql
Pivot command,"SELECT x, y, z FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.command_setPivot"" WHERE salIndex = :SalIndex: ORDER BY DESC LIMIT 20",influxql
command_stop,"SELECT private_seqNum, private_identity FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.command_stop"" WHERE salIndex = :SalIndex: ORDER BY DESC LIMIT 5",influxql
Connected,"SELECT connected FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_connected"" WHERE salIndex = :SalIndex: ORDER BY DESC LIMIT 3;",influxql
Position in w [deg],"SELECT mean(position5) as mean_w FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:sampling:) FILL(null)",influxql
Position in v [deg],"SELECT mean(position4) as mean_v FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:sampling:) FILL(null)",influxql
Position in u [deg],"SELECT mean(position3) as mean_u FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:sampling:) FILL(null)",influxql
Position in Y [um],"SELECT mean(position1) as mean_y FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
commandableByDDS,"SELECT state FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_commandableByDDS"" WHERE salIndex = :SalIndex: ORDER BY DESC LIMIT 3;",influxql
Position in Z [um],"SELECT mean(position2) as mean_z FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Position in X [um],"SELECT mean(position0) as mean_x FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.application"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:sampling:) FILL(null)",influxql
MTHexapod Summary State,"// CSC states
// STANDBY = 5
// OFFLINE = 4
// FAULT = 3
// ENABLED = 2
// DISABLED = 1

import ""strings""

from(bucket: ""efd/autogen"")
  |> range(start: -inf)
  |> filter(fn: (r) => r._measurement == ""lsst.sal.MTHexapod.logevent_summaryState"")
  |> filter(fn: (r) => r._field == ""summaryState"" or r._field == ""salIndex"")
  |> pivot(rowKey: [""_time""], columnKey: [""_field""], valueColumn: ""_value"")
  |> filter(fn: (r) => r.salIndex==int(v: v.SalIndex))
  |> map(fn: (r) => ({
    r with
    state:
      if r.summaryState == 5 then ""5 (STANDBY)""
      else if r.summaryState == 4 then ""4 (OFFLINE)""
      else if r.summaryState == 3 then ""3 (FAULT)""
      else if r.summaryState == 2 then ""2 (ENABLED)""
      else if r.summaryState == 1 then ""1 (DISABLED)""
      else ""UNKNOWN"",
    })
) |> sort(desc: true)
",flux
Script logevents,"SELECT ""ScriptID"", ""level"", ""message"" FROM ""efd"".""autogen"".""lsst.sal.Script.logevent_logMessage"" ORDER BY DESC LIMIT 100",influxql
MTHexapod Heartbeat,"SELECT count(""heartbeat"") FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_heartbeat"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:sampling:) FILL(null)",influxql
controllerState,"SELECT ""controllerState"", ""enabledSubstate"", ""offlineSubstate"", ""applicationStatus0"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_controllerState"" WHERE salIndex =:SalIndex: ORDER BY DESC LIMIT 1000",influxql
"Logevent ""inPosition""","SELECT ""inPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_inPosition"" WHERE salIndex = :SalIndex: ORDER BY DESC LIMIT 1000",influxql
MTHexapod log messages,"SELECT ""level"", ""message"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_logMessage"" WHERE salIndex = :SalIndex: ORDER BY DESC LIMIT 100",influxql
MTHexapod.command_move,"SELECT mean(x) as mean_x, mean(y) as mean_y, mean(z) as mean_z, mean(u) as mean_u, mean(v) as mean_v, mean(w) as mean_w FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.command_move"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime:  GROUP BY time(:sampling:) FILL(null)",influxql
Actutators raw (mean),"SELECT mean(""raw0"") AS ""mean_raw0"", mean(""raw1"") AS ""mean_raw1"", mean(""raw2"") AS ""mean_raw2"", mean(""raw3"") AS ""mean_raw3"", mean(""raw4"") AS ""mean_raw4"", mean(""raw5"") AS ""mean_raw5"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.actuators"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:sampling:) FILL(null)",influxql
Raw Acutators,"SELECT mean(""raw0"") as mean_raw0, mean(""raw1"") as mean_raw1, mean(""raw2"") as mean_raw2, mean(""raw3"") as mean_raw3, mean(""raw4"") as mean_raw4, mean(""raw5"") as mean_raw5 FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.actuators"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime:  GROUP BY time(:sampling:) FILL(null)",influxql
Copley Drive Status,"SELECT ""copleyStatusWordDrive3"", ""copleyStatusWordDrive4"", ""copleyStatusWordDrive5"", ""copleyStatusWordDrive2"", ""copleyStatusWordDrive1"", ""copleyStatusWordDrive0"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.electrical"" WHERE salIndex = :SalIndex: AND time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Position Error,"SELECT ""positionError0"", ""positionError1"", ""positionError2"", ""positionError3"", ""positionError4"", ""positionError5"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.actuators"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
REB 0 Currents,"SELECT ""OD_IaftLDO0"", ""OD_IaftLDO20"", ""OD_IaftSwch0"", ""OD_IbefLDO0"", ""analog_IaftLDO0"", ""analog_IaftSwch0"", ""analog_IbefLDO0"", ""clockhi_IaftLDO0"", ""clockhi_IaftSwch0"", ""clockhi_IbefLDO0"", ""clocklo_IaftLDO0"", ""clocklo_IaftLDO20"", ""clocklo_IaftSwch0"", ""clocklo_IbefLDO0"", ""digital_IaftLDO0"", ""digital_IaftSwch0"", ""digital_IbefLDO0"", ""heater_IaftLDO0"", ""heater_IaftSwch0"", ""heater_IbefLDO0"", ""hvbias_IbefSwch0"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.rebpower_Reb"" WHERE time > :dashboardTime:",influxql
REB 2 Voltages,"SELECT ""OD_VaftLDO2"", ""OD_VaftLDO22"", ""OD_VaftSwch2"", ""OD_VbefLDO2"", ""analog_VaftLDO2"", ""analog_VaftSwch2"", ""analog_VbefLDO2"", ""clockhi_VaftLDO2"", ""clockhi_VaftSwch2"", ""clockhi_VbefLDO2"", ""clocklo_VaftLDO2"", ""clocklo_VaftLDO22"", ""clocklo_VaftSwch2"", ""clocklo_VbefLDO2"", ""digital_VaftLDO2"", ""digital_VaftSwch2"", ""digital_VbefLDO2"", ""heater_VaftLDO2"", ""heater_VaftSwch2"", ""heater_VbefLDO2"", ""hvbias_VbefSwch2"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.rebpower_Reb"" WHERE time > :dashboardTime:",influxql
REB 1 Voltages,"SELECT ""OD_VaftLDO1"", ""OD_VaftLDO21"", ""OD_VaftSwch1"", ""OD_VbefLDO1"", ""analog_VaftLDO1"", ""analog_VaftSwch1"", ""analog_VbefLDO1"", ""clockhi_VaftLDO1"", ""clockhi_VaftSwch1"", ""clockhi_VbefLDO1"", ""clocklo_VaftLDO1"", ""clocklo_VaftLDO21"", ""clocklo_VaftSwch1"", ""clocklo_VbefLDO1"", ""digital_VaftLDO1"", ""digital_VaftSwch1"", ""digital_VbefLDO1"", ""heater_VaftLDO1"", ""heater_VaftSwch1"", ""heater_VbefLDO1"", ""hvbias_VbefSwch1"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.rebpower_Reb"" WHERE time > :dashboardTime:",influxql
REB 0 Voltages,"SELECT ""OD_VaftLDO0"", ""OD_VaftLDO20"", ""OD_VaftSwch0"", ""OD_VbefLDO0"", ""analog_VaftLDO0"", ""analog_VaftSwch0"", ""analog_VbefLDO0"", ""clockhi_VaftLDO0"", ""clockhi_VaftSwch0"", ""clockhi_VbefLDO0"", ""clocklo_VaftLDO0"", ""clocklo_VaftLDO20"", ""clocklo_VaftSwch0"", ""clocklo_VbefLDO0"", ""digital_VaftLDO0"", ""digital_VaftSwch0"", ""digital_VbefLDO0"", ""heater_VaftLDO0"", ""heater_VaftSwch0"", ""heater_VbefLDO0"", ""hvbias_VbefSwch0"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.rebpower_Reb"" WHERE time > :dashboardTime:",influxql
REB 1 Currents,"SELECT ""OD_IaftLDO1"", ""OD_IaftLDO21"", ""OD_IaftSwch1"", ""OD_IbefLDO1"", ""analog_IaftLDO1"", ""analog_IaftSwch1"", ""analog_IbefLDO1"", ""clockhi_IaftLDO1"", ""clockhi_IaftSwch1"", ""clockhi_IbefLDO1"", ""clocklo_IaftLDO1"", ""clocklo_IaftLDO21"", ""clocklo_IaftSwch1"", ""clocklo_IbefLDO1"", ""digital_IaftLDO1"", ""digital_IaftSwch1"", ""digital_IbefLDO1"", ""heater_IaftLDO1"", ""heater_IaftSwch1"", ""heater_IbefLDO1"", ""hvbias_IbefSwch1"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.rebpower_Reb"" WHERE time > :dashboardTime:",influxql
REB 2 Currents,"SELECT ""OD_IaftLDO2"", ""OD_IaftLDO22"", ""OD_IaftSwch2"", ""OD_IbefLDO2"", ""analog_IaftLDO2"", ""analog_IaftSwch2"", ""analog_IbefLDO2"", ""clockhi_IaftLDO2"", ""clockhi_IaftSwch2"", ""clockhi_IbefLDO2"", ""clocklo_IaftLDO2"", ""clocklo_IaftLDO22"", ""clocklo_IaftSwch2"", ""clocklo_IbefLDO2"", ""digital_IaftLDO2"", ""digital_IaftSwch2"", ""digital_IbefLDO2"", ""heater_IaftLDO2"", ""heater_IaftSwch2"", ""heater_IbefLDO2"", ""hvbias_IbefSwch2"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.rebpower_Reb"" WHERE time > :dashboardTime:",influxql
REB Power,"SELECT ""power0"", ""power1"", ""power2"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.rebpower_Reb"" WHERE time > :dashboardTime: ",influxql
Power Supply Board Temperatures,"SELECT ""boardTemp0"", ""boardTemp00"", ""boardTemp1"", ""boardTemp10"", ""boardTemp2"", ""boardTemp20"", ""boardTemp3"", ""boardTemp30"", ""boardTemp4"", ""boardTemp40"", ""boardTemp5"", ""boardTemp50"", ""boardTemp6"", ""boardTemp60"" FROM ""efd"".""autogen"".""lsst.sal.CCCamera.rebpower_Rebps"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Zernike values,"SELECT last(""nollZernikeValues0"") as z4, last(""nollZernikeValues1"") as z5, last(""nollZernikeValues2"") as z6, last(""nollZernikeValues3"") as z7, last(""nollZernikeValues3"") as z8, last(""nollZernikeValues3"") as z9, last(""nollZernikeValues3"") as z10, last(""nollZernikeValues3"") as z11, time FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_wavefrontError"" WHERE time > 0 ",influxql
Zernike time series,"SELECT last(""nollZernikeValues0"") AS ""z4"", last(""nollZernikeValues1"") AS ""z5"", last(""nollZernikeValues2"") AS ""z6"" FROM ""efd"".""autogen"".""lsst.sal.MTAOS.logevent_wavefrontError"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
AZ position,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
currents,"SELECT max(/current/) AS ""spread_current0"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevationDrives"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Untitled Graph,"SELECT mean(""actualTorque"") AS ""mean_actualTorque"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Untitled Graph,"SELECT mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
OCPS,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.OCPS.logevent_summaryState"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
DIMM:2 (Portable),"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.DIMM.logevent_summaryState"" WHERE ""salIndex"" = 2 ORDER BY DESC LIMIT 1",influxql
DSM:1,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.DSM.logevent_summaryState"" WHERE ""salIndex"" = 1 ORDER BY DESC LIMIT 1",influxql
DIMM:1,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.DIMM.logevent_summaryState"" WHERE ""salIndex"" = 1 ORDER BY DESC LIMIT 1",influxql
Camera Hexapod,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTHexapod.logevent_summaryState"" WHERE salIndex = 1. ORDER BY DESC LIMIT 1",influxql
ATMCS-Tracking,"SELECT ""state"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.logevent_atMountState"" ORDER BY DESC LIMIT 1",influxql
Elevation,"SELECT ""elevationCalculatedAngle99"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.mount_AzEl_Encoders"" ORDER BY DESC LIMIT 1",influxql
Azimuth,"SELECT ""azimuthCalculatedAngle99"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.mount_AzEl_Encoders"" ORDER BY DESC LIMIT 1",influxql
GenericCamera:1,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.GenericCamera.logevent_summaryState"" WHERE ""salIndex"" = 1 ORDER BY DESC LIMIT 1",influxql
Rotator,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.Rotator.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
MTPtg,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTPtg.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATAOS,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATAOS.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATHexapod,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATHexapod.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATDome,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATDome.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATPtg,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATPtg.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATDomeTrajectory,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATDomeTrajectory.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATMCS,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATMCS.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ScriptQueue,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ScriptQueue.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATMonochromator,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATMonochromator.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATHeaderService,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATHeaderService.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATArchiver,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATArchiver.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATCamera,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
Electrometer,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.Electrometer.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATSpectrograph,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATSpectrograph.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
Watcher,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.Watcher.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
ATPneumatics,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.ATPneumatics.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
FiberSpectrograph,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.FiberSpectrograph.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
Environment:1,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.Environment.logevent_summaryState"" WHERE ""salIndex"" = 1 ORDER BY DESC LIMIT 1",influxql
MTMount,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_summaryState"" ORDER BY DESC LIMIT 1",influxql
AFE Decentralized IO Free,"SELECT ""sdrAFEfree0"", ""sdrAFEfree1"", ""sdrAFEfree10"", ""sdrAFEfree11"", ""sdrAFEfree12"", ""sdrAFEfree13"", ""sdrAFEfree14"", ""sdrAFEfree15"", ""sdrAFEfree2"", ""sdrAFEfree3"", ""sdrAFEfree4"", ""sdrAFEfree5"", ""sdrAFEfree6"", ""sdrAFEfree7"", ""sdrAFEfree8"", ""sdrAFEfree9"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_afeDecentralizedIOFree"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
AFE Decentralized IO Inputs,"SELECT ""sdiAFEdomeaB"", ""sdiAFEetacA"", ""sdiAFEetacB"", ""sdiAFEeteaA"", ""sdiAFEeteaB"", ""sdiAFEetsfA"", ""sdiAFEetsfB"", ""sdiAFEfireA"", ""sdiAFEfireB"", ""sdiAFEfree1"", ""sdiAFEfree2"", ""sdiAFEpsb"", ""sdiAFEpsr"", ""sdiAFEudomeaA"", ""sdiAFEupieraA"", ""sdiAFEupieraB"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_afeDecentralizedIOInputs"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
AFE Decentralized IO Outputs,"SELECT ""sdoAFEetacA"", ""sdoAFEetacrst"", ""sdoAFEetacB"", ""sdoAFEetsfA"", ""sdoAFEetsfrst"", ""sdoAFEfree0"", ""sdoAFEfree2"", ""sdoAFEfree1"", ""sdoAFEfree3"", ""sdoAFEfree4"", ""sdoAFEfree5"", ""sdoAFEfree6"", ""sdoAFEfree7"", ""sdoAFEetsfB"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_afeDecentralizedIOOutputs"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
AUX CPU Inputs,"SELECT ""gnetAUX_simanliftpark"", ""gnetAUX_siplatliftabo"", ""gnetAUX_siplatliftpark"", ""gnetAUXfree0"", ""gnetAUXfree1"", ""gnetAUXfree10"", ""gnetAUXfree2"", ""gnetAUXfree11"", ""gnetAUXfree3"", ""gnetAUXfree4"", ""gnetAUXfree5"", ""gnetAUXfree6"", ""gnetAUXfree7"", ""gnetAUXfree8"", ""gnetAUXfree9"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_auxCpuInputs"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
AUX CPU Outputs,"SELECT ""gnetAUX_soplatlifttop"", ""gnetAUX_soplatlitfsto"", ""gnetAUXfree0"", ""gnetAUXfree1"", ""gnetAUXfree10"", ""gnetAUXfree11"", ""gnetAUXfree12"", ""gnetAUXfree13"", ""gnetAUXfree2"", ""gnetAUXfree3"", ""gnetAUXfree4"", ""gnetAUXfree5"", ""gnetAUXfree6"", ""gnetAUXfree7"", ""gnetAUXfree8"", ""gnetAUXfree9"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_auxCpuOutputs"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Causes,"SELECT ""gcauses_D1"", ""gcauses_D10"", ""gcauses_D11"", ""gcauses_D12"", ""gcauses_D13"", ""gcauses_D14"", ""gcauses_D15"", ""gcauses_D16"", ""gcauses_D2"", ""gcauses_D3"", ""gcauses_D4"", ""gcauses_D5"", ""gcauses_D6"", ""gcauses_D7"", ""gcauses_D8"", ""gcauses_D9"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_causes"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Causes 2,"SELECT ""gcauses_D17"", ""gcauses_D18"", ""gcauses_D19"", ""gcausesfree0"", ""gcausesfree1"", ""gcausesfree10"", ""gcausesfree11"", ""gcausesfree12"", ""gcausesfree3"", ""gcausesfree2"", ""gcausesfree4"", ""gcausesfree5"", ""gcausesfree6"", ""gcausesfree7"", ""gcausesfree8"", ""gcausesfree9"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_causes2"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Causes 2 Override,"SELECT ""govr_D17"", ""govr_D18"", ""govr_D19"", ""govrfree0"", ""govrfree1"", ""govrfree10"", ""govrfree11"", ""govrfree12"", ""govrfree2"", ""govrfree3"", ""govrfree5"", ""govrfree4"", ""govrfree6"", ""govrfree7"", ""govrfree8"", ""govrfree9"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_causes2Override"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Causes Override,"SELECT ""govr_D1"", ""govr_D11"", ""govr_D10"", ""govr_D12"", ""govr_D13"", ""govr_D14"", ""govr_D15"", ""govr_D16"", ""govr_D3"", ""govr_D2"", ""govr_D4"", ""govr_D5"", ""govr_D6"", ""govr_D7"", ""govr_D8"", ""govr_D9"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_causesOverride"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dome CPU Inputs,"SELECT ""gnetDOME_sicraneparked"", ""gnetDOME_sietpb"", ""gnetDOME_silockingpin"", ""gnetDOME_sireardoor"", ""gnetDomefree0"", ""gnetDomefree1"", ""gnetDomefree10"", ""gnetDomefree11"", ""gnetDomefree2"", ""gnetDomefree3"", ""gnetDomefree4"", ""gnetDomefree5"", ""gnetDomefree6"", ""gnetDomefree7"", ""gnetDomefree9"", ""gnetDomefree8"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_domeCpuInputs"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Dome CPU Outputs,"SELECT ""gnetDOME_soazdrivesto"", ""gnetDOME_socranesto"", ""gnetDOME_solockingpinsto"", ""gnetDOME_soreardoorsto"", ""gnetDOME_sowindscreensto"", ""gnetDOMEfree0"", ""gnetDOMEfree1"", ""gnetDOMEfree10"", ""gnetDOMEfree2"", ""gnetDOMEfree3"", ""gnetDOMEfree4"", ""gnetDOMEfree5"", ""gnetDOMEfree6"", ""gnetDOMEfree7"", ""gnetDOMEfree8"", ""gnetDOMEfree9"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_domeCpuOutputs"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Effects,"SELECT ""geffects_A1"", ""geffects_A10"", ""geffects_A11"", ""geffects_A12"", ""geffects_A13"", ""geffects_A14"", ""geffects_A15"", ""geffects_A2"", ""geffects_A3"", ""geffects_A4"", ""geffects_A5"", ""geffects_A6"", ""geffects_A7"", ""geffects_A8"", ""geffects_A9"", ""geffects_A16"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_effects"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Effects 2,"SELECT ""geffects_A17"", ""geffects_A18"", ""geffects_A19"", ""geffects_A20"", ""geffects_A21"", ""geffectsfree0"", ""geffectsfree1"", ""geffectsfree10"", ""geffectsfree2"", ""geffectsfree3"", ""geffectsfree4"", ""geffectsfree5"", ""geffectsfree6"", ""geffectsfree7"", ""geffectsfree8"", ""geffectsfree9"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_effects2"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
GIS CPU Inputs,"SELECT ""sdiCPUetw1A"", ""sdiCPUetw1B"", ""sdiCPUetw2A"", ""sdiCPUetw2B"", ""sdiCPUfree1"", ""sdiCPUfree10"", ""sdiCPUfree2"", ""sdiCPUfree3"", ""sdiCPUfree4"", ""sdiCPUfree5"", ""sdiCPUfree6"", ""sdiCPUfree7"", ""sdiCPUfree8"", ""sdiCPUfree9"", ""sdiCPUpsb"", ""sdiCPUpsr"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_gisCpuInputs"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
GIS CPU Outputs,"SELECT ""sdoCPUetw1rst"", ""sdoCPUetw2rst"", ""sdoCPUfireA"", ""sdoCPUfireB"", ""sdoCPUfree1"", ""sdoCPUfree10"", ""sdoCPUfree11"", ""sdoCPUfree12"", ""sdoCPUfree2"", ""sdoCPUfree3"", ""sdoCPUfree4"", ""sdoCPUfree5"", ""sdoCPUfree6"", ""sdoCPUfree7"", ""sdoCPUfree8"", ""sdoCPUfree9"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_gisCpuOutputs"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
GIS CPU Reserve,"SELECT ""sdrCPUfree0"", ""sdrCPUfree1"", ""sdrCPUfree10"", ""sdrCPUfree11"", ""sdrCPUfree12"", ""sdrCPUfree13"", ""sdrCPUfree14"", ""sdrCPUfree15"", ""sdrCPUfree2"", ""sdrCPUfree3"", ""sdrCPUfree4"", ""sdrCPUfree5"", ""sdrCPUfree6"", ""sdrCPUfree7"", ""sdrCPUfree8"", ""sdrCPUfree9"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_gisCpuReserve"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Laser Decentralized IO Free,"SELECT ""sdrLASfree0"", ""sdrLASfree9"", ""sdrLASfree1"", ""sdrLASfree10"", ""sdrLASfree11"", ""sdrLASfree12"", ""sdrLASfree14"", ""sdrLASfree13"", ""sdrLASfree15"", ""sdrLASfree2"", ""sdrLASfree3"", ""sdrLASfree4"", ""sdrLASfree5"", ""sdrLASfree6"", ""sdrLASfree7"", ""sdrLASfree8"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_laserDecentralizedIOFree"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Laser Decentralized IO Input,"SELECT ""sdiLASetA"", ""sdiLASpsr"", ""sdiLASetB"", ""sdiLASfree0"", ""sdiLASfree1"", ""sdiLASfree2"", ""sdiLASfree3"", ""sdiLASfree4"", ""sdiLASfree5"", ""sdiLASfree6"", ""sdiLASfree7"", ""sdiLASpsb"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_laserDecentralizedIOInput"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Laser Decentralized IO Outputs,"SELECT ""sdoLASetA"", ""sdoLASetB"", ""sdoLASetrst"", ""sdoLASfree0"", ""sdoLASfree1"", ""sdoLASfree10"", ""sdoLASfree2"", ""sdoLASfree3"", ""sdoLASfree4"", ""sdoLASfree5"", ""sdoLASfree6"", ""sdoLASfree7"", ""sdoLASfree8"", ""sdoLASfree9"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_laserDecentralizedIOOutputs"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
M1M3 CPU Inputs,"SELECT ""gnetM1M3_siheartbeat"", ""gnetM1M3_siinterlock"", ""gnetM1M3free0"", ""gnetM1M3free1"", ""gnetM1M3free10"", ""gnetM1M3free11"", ""gnetM1M3free13"", ""gnetM1M3free12"", ""gnetM1M3free2"", ""gnetM1M3free3"", ""gnetM1M3free4"", ""gnetM1M3free5"", ""gnetM1M3free6"", ""gnetM1M3free7"", ""gnetM1M3free8"", ""gnetM1M3free9"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_m1m3CpuInputs"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
M1M3 CPU Outputs,"SELECT ""gnetM1M3_soearthsto"", ""gnetM1M3_soheartbeat"", ""gnetM1M3_soemergsto"", ""gnetM1M3free0"", ""gnetM1M3free1"", ""gnetM1M3free10"", ""gnetM1M3free11"", ""gnetM1M3free12"", ""gnetM1M3free2"", ""gnetM1M3free3"", ""gnetM1M3free5"", ""gnetM1M3free4"", ""gnetM1M3free6"", ""gnetM1M3free7"", ""gnetM1M3free8"", ""gnetM1M3free9"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_m1m3CpuOutputs"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
M2c Decentralized IO Free,"SELECT ""sdrM2Cfree0"", ""sdrM2Cfree1"", ""sdrM2Cfree11"", ""sdrM2Cfree10"", ""sdrM2Cfree12"", ""sdrM2Cfree13"", ""sdrM2Cfree14"", ""sdrM2Cfree15"", ""sdrM2Cfree2"", ""sdrM2Cfree3"", ""sdrM2Cfree4"", ""sdrM2Cfree5"", ""sdrM2Cfree6"", ""sdrM2Cfree7"", ""sdrM2Cfree8"", ""sdrM2Cfree9"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_m2cDecentralizedIOFree"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
M2c Decentralized IO Input,"SELECT ""sdiM2CetchA"", ""sdiM2CetchB"", ""sdiM2CetcrA"", ""sdiM2Cetm2aA"", ""sdiM2CetcrB"", ""sdiM2Cetm2aB"", ""sdiM2Cetm2hA"", ""sdiM2Cetm2hB"", ""sdiM2Cfree0"", ""sdiM2Cfree1"", ""sdiM2Cfree2"", ""sdiM2Cfree3"", ""sdiM2Cpinins"", ""sdiM2Cpsb"", ""sdiM2Cpsr"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_m2cDecentralizedIOInput"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
M2c Decentralized IO Output,"SELECT ""sdoM2CetchA"", ""sdoM2CetchB"", ""sdoM2Cetchrst"", ""sdoM2CetcrA"", ""sdoM2CetcrB"", ""sdoM2Cetcrrst"", ""sdoM2Cetm2aA"", ""sdoM2Cetm2aB"", ""sdoM2Cetm2arst"", ""sdoM2Cetm2hA"", ""sdoM2Cetm2hB"", ""sdoM2Cetm2hst"", ""sdoM2Cfree0"", ""sdoM2Cfree1"", ""sdoM2Cfree2"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_m2cDecentralizedIOOutput"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
PF Decentralized IO Free,"SELECT ""sdrPFfree0"", ""sdrPFfree1"", ""sdrPFfree10"", ""sdrPFfree11"", ""sdrPFfree12"", ""sdrPFfree13"", ""sdrPFfree14"", ""sdrPFfree15"", ""sdrPFfree2"", ""sdrPFfree3"", ""sdrPFfree4"", ""sdrPFfree5"", ""sdrPFfree6"", ""sdrPFfree7"", ""sdrPFfree9"", ""sdrPFfree8"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_pfDecentralizedIoFree"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
PF Decentralized IO Inputs,"SELECT ""sdiPFLetA"", ""sdiPFLetB"", ""sdiPFLfree1"", ""sdiPFLmlnotpark"", ""sdiPFLpllowlevel"", ""sdiPFLplnotpark"", ""sdiPFLpsb"", ""sdiPFLpsr"", ""sdiPFfree0"", ""sdiPFfree1"", ""sdiPFfree2"", ""sdiPFfree3"", ""sdiPFfree4"", ""sdiPFfree5"", ""sdiPFfree6"", ""sdiPFfree7"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_pfDecentralizedIoInputs"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
PF Decentralized IO Output,"SELECT ""sdoPFLetauxcA"", ""sdoPFLetauxcB"", ""sdoPFLetauxcrst"", ""sdoPFLetpflowA"", ""sdoPFLetpflowB"", ""sdoPFLetpflowrst"", ""sdoPFLfree1"", ""sdoPFLmlSTOA"", ""sdoPFLmlSTOB"", ""sdoPFLmlrst"", ""sdoPFfree0"", ""sdoPFfree1"", ""sdoPFfree2"", ""sdoPFfree3"", ""sdoPFfree4"", ""sdoPFfree5"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_pfDecentralizedIoOutput"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
TMA CPU Inputs,"SELECT ""gnetTMA_sibrakeoff"", ""gnetTMA_sietpb"", ""gnetTMA_simcsfault"", ""gnetTMA_sipullcord"", ""gnetTMAfree0"", ""gnetTMAfree10"", ""gnetTMAfree1"", ""gnetTMAfree11"", ""gnetTMAfree2"", ""gnetTMAfree3"", ""gnetTMAfree4"", ""gnetTMAfree5"", ""gnetTMAfree6"", ""gnetTMAfree7"", ""gnetTMAfree8"", ""gnetTMAfree9"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_tmaCpuInputs"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
TMA CPU Outputs,"SELECT ""gnetTMA_soccwsto"", ""gnetTMA_sodischargecap"", ""gnetTMA_somainaxissto"", ""gnetTMA_soothersto"", ""gnetTMAfree0"", ""gnetTMAfree1"", ""gnetTMAfree10"", ""gnetTMAfree11"", ""gnetTMAfree2"", ""gnetTMAfree3"", ""gnetTMAfree4"", ""gnetTMAfree5"", ""gnetTMAfree6"", ""gnetTMAfree7"", ""gnetTMAfree8"", ""gnetTMAfree9"" FROM ""efd"".""autogen"".""lsst.sal.GIS.logevent_tmaCpuOutputs"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Polycold Return Pressure,"SELECT mean(""pressureItem1"") AS ""Return Pressure(Pa)"" FROM ""efd"".""autogen"".""lsst.sal.ESS.pressure"" WHERE ""sensorName"" = 'AuxTel-LabJack01' AND ""salIndex"" = 201 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Polycold Supply Pressure,"SELECT mean(""pressureItem0"") AS ""Supply Pressure(Pascal)"" FROM ""efd"".""autogen"".""lsst.sal.ESS.pressure"" WHERE ""sensorName"" = 'AuxTel-LabJack01' AND ""salIndex"" = 201 AND time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Cryocon Temperatures,"SELECT ""tempCCD"", ""tempColdPlate"", ""tempCryoHead"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.vacuum"" WHERE time > :dashboardTime:",influxql
Cryohead Temperature,"SELECT ""tempCryoHead"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.vacuum"" WHERE time > :dashboardTime:",influxql
Dewar Vacuum Pressure,"SELECT ""vacuum"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.vacuum"" WHERE time > :dashboardTime:",influxql
CCD,"SELECT mean(""ccdTemp0"") AS ""mean_ccdTemp0"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.wreb"" WHERE time > :dashboardTime: GROUP BY time(:interval:) FILL(none)",influxql
CCD,"SELECT ""tempCCD"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.vacuum"" WHERE time > :dashboardTime:",influxql
WREB On-Board,"SELECT mean(""temp10"") AS ""mean_temp1"", mean(""temp20"") AS ""mean_temp2"", mean(""temp30"") AS ""mean_temp3"", mean(""temp40"") AS ""mean_temp4"", mean(""temp50"") AS ""mean_temp5"", mean(""temp6"") AS ""mean_temp6"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.focal_plane_Reb"" WHERE time > :dashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
ASPIC,"SELECT ""aspicl_Temp00"", ""aspicu_Temp00"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.focal_plane_Reb"" WHERE time > :dashboardTime:",influxql
ColdPlate Temperature,"SELECT ""tempColdPlate"" FROM ""efd"".""autogen"".""lsst.sal.ATCamera.vacuum"" WHERE time > :dashboardTime:",influxql
CCW and Rotator Actual Positions,"SELECT ""actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.rotation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
CCW and Rotator Actual Positions,"SELECT ""actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.cameraCableWrap"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
CCW + Rotator Difference,"t1 = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.MTMount.cameraCableWrap/ and r._field == ""actualPosition"")
  |> aggregateWindow(every: 1s, fn: mean)
  |> keep(columns: [""_time"", ""_value""])
  
t2 = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r._measurement =~ /lsst.sal.MTRotator.rotation/ and r._field == ""actualPosition"")
  |> aggregateWindow(every: 1s, fn: mean)
  |> keep(columns: [""_time"", ""_value""])

join(tables: {t1: t1, t2: t2}, on: [""_time""])
  |> map(fn: (r) => ({ r with _value: r._value_t2 - r._value_t1}))
  |> keep(columns: [""_time"", ""_value""])
  |> yield(name: ""delta"")
  ",flux
CCW Position and Velocity,"SELECT ""actualPosition"", ""actualVelocity"", ""demandPosition"", ""demandVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.cameraCableWrap"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTRotator position and velocity,"SELECT ""actualPosition"", ""actualVelocity"", ""demandPosition"", ""demandVelocity"" FROM ""efd"".""autogen"".""lsst.sal.MTRotator.rotation"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
AZ Drives temperature,"SELECT mean(""actualTemperature0"") AS ""mean_actualTemperature0"", mean(""actualTemperature1"") AS ""mean_actualTemperature1"", mean(""actualTemperature2"") AS ""mean_actualTemperature2"", mean(""actualTemperature3"") AS ""mean_actualTemperature3"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuthDrivesThermal"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
AZ Drives currents,"SELECT ""current0"", ""current1"", ""current2"", ""current3"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuthDrives"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
AZ axis position/torque/speed,"SELECT mean(""actualTorque"") AS ""mean_actualTorque"", mean(""actualVelocity"") AS ""mean_actualVelocity"", mean(""actualPosition"") AS ""mean_actualPosition"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Moment in Z (mZ),"SELECT ""mz"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Moment in Y (mY),"SELECT ""my"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Moment in X (mX),"SELECT ""mx"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
"M1M MIrror Moments mX, mY, mZ Units=NewtonMeters","SELECT mean(""mx"") AS ""mean_mx"", mean(""my"") AS ""mean_my"", mean(""mz"") AS ""mean_mz"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
HP-4,"SELECT ""measuredForce4"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
HP-3,"SELECT ""measuredForce3"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
HP-2,"SELECT ""measuredForce2"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
HP-1,"SELECT ""measuredForce1"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
HP-0,"SELECT ""measuredForce0"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Measured Forces 0-5 Uniits=Newtons,"SELECT mean(""measuredForce0"") AS ""mean_measuredForce0"", mean(""measuredForce1"") AS ""mean_measuredForce1"", mean(""measuredForce2"") AS ""mean_measuredForce2"", mean(""measuredForce3"") AS ""mean_measuredForce3"", mean(""measuredForce4"") AS ""mean_measuredForce4"", mean(""measuredForce5"") AS ""mean_measuredForce5"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Force in Z (fZ),"SELECT ""fz"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Force in Y (fY),"SELECT ""fy"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Force in X (fX),"SELECT ""fx"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
"Principle Forces from Hardpoints - fX, fY, fZ Units=Newtons","SELECT mean(""fx"") AS ""mean_fx"", mean(""fy"") AS ""mean_fy"", mean(""fz"") AS ""mean_fz"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
HP-5,"SELECT ""measuredForce5"" FROM ""efd"".""autogen"".""lsst.sal.MTM1M3.hardpointActuatorData"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Mode:2,"SELECT ""simulationLoopTime"" FROM ""efd"".""autogen"".""lsst.sal.DSM.logevent_settingsAppliedSetup"" WHERE salIndex = 2 ORDER BY time DESC LIMIT 1",influxql
Mode:1,"SELECT ""simulationLoopTime"" FROM ""efd"".""autogen"".""lsst.sal.DSM.logevent_settingsAppliedSetup"" WHERE DSMID = 1 ORDER BY time DESC LIMIT 1",influxql
FWHM:2,"SELECT ""fwhm"" FROM ""efd"".""autogen"".""lsst.sal.DSM.domeSeeing"" WHERE salIndex = 2 AND time > :dashboardTime:",influxql
Flux:2,"SELECT ""flux"" FROM ""efd"".""autogen"".""lsst.sal.DSM.domeSeeing"" WHERE salIndex = 2 AND time > :dashboardTime:",influxql
Max ADC:2,"SELECT ""maxADC"" FROM ""efd"".""autogen"".""lsst.sal.DSM.domeSeeing"" WHERE salIndex = 2 AND time > :dashboardTime:",influxql
FWHM:1,"SELECT ""fwhm"" FROM ""efd"".""autogen"".""lsst.sal.DSM.domeSeeing"" WHERE salIndex = 1 AND time > :dashboardTime:",influxql
Max ADC:1,"SELECT ""maxADC"" FROM ""efd"".""autogen"".""lsst.sal.DSM.domeSeeing"" WHERE salIndex = 1 AND time > :dashboardTime:",influxql
Flux:1,"SELECT ""flux"" FROM ""efd"".""autogen"".""lsst.sal.DSM.domeSeeing"" WHERE salIndex = 1 AND time > :dashboardTime:",influxql
DSM:2,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.DSM.logevent_summaryState"" WHERE salIndex = 2 ORDER BY DESC LIMIT 1",influxql
DSM:1,"SELECT ""summaryState"" FROM ""efd"".""autogen"".""lsst.sal.DSM.logevent_summaryState"" WHERE salIndex = 1 ORDER BY DESC LIMIT 1",influxql
DSM:2 Configuration,"SELECT ""cameraFps"", ""cameraName"", ""dataAcquisitionTime"", ""dataBufferSize"", ""timestampConfigStart"", ""uiConfigFile"", ""uiVersionCode"", ""uiVersionConfig"", ""private_sndStamp"" FROM ""efd"".""autogen"".""lsst.sal.DSM.configuration"" WHERE salIndex = 2 ORDER BY time DESC LIMIT 1",influxql
RMS:2,"SELECT ""rmsX"", ""rmsY"" FROM ""efd"".""autogen"".""lsst.sal.DSM.domeSeeing"" WHERE DSMID = 2 AND time > :dashboardTime: ",influxql
RMS:1,"SELECT ""rmsX"", ""rmsY"" FROM ""efd"".""autogen"".""lsst.sal.DSM.domeSeeing"" WHERE salIndex = 1 AND time > :dashboardTime: ",influxql
Centroid:2,"SELECT ""centroidX"", ""centroidY"" FROM ""efd"".""autogen"".""lsst.sal.DSM.domeSeeing"" WHERE salIndex = 2 AND time > :dashboardTime: ",influxql
Centroid:1,"SELECT ""centroidX"", ""centroidY"" FROM ""efd"".""autogen"".""lsst.sal.DSM.domeSeeing"" WHERE salIndex = 1 AND time > :dashboardTime: ",influxql
DSM:1 Configuration,"SELECT ""cameraFps"", ""cameraName"", ""dataAcquisitionTime"", ""dataBufferSize"", ""timestampConfigStart"", ""uiConfigFile"", ""uiVersionCode"", ""uiVersionConfig"", ""private_sndStamp"" FROM ""efd"".""autogen"".""lsst.sal.DSM.configuration"" WHERE salIndex = 1 ORDER BY time DESC LIMIT 1",influxql
Ambient Temperature,"SELECT ""ambientTemperature"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.oilSupplySystem"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTMount_auxiliaryCabinetsThermal,"SELECT ""actualTemperatureAzimuthDriveCabinet0001"", ""actualTemperatureAzimuthPowerDistributionCabinet0001"", ""actualTemperatureAzimuthPowerDistributionTransformer0001"", ""actualTemperatureElevationPowerDistributionCabinet0001"", ""actualTemperatureElevationPowerDistributionCabinet0002"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.auxiliaryCabinetsThermal"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTMount_auxiliaryCabinetsThermal,"SELECT ""ambientTemperature"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.oilSupplySystem"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTMount_elevationDrivesThermal,"SELECT ""actualTemperature12"", ""actualTemperature2"", ""actualTemperature4"", ""actualTemperature6"", ""actualTemperature8"", ""setpointTemperature1"", ""actualTemperature10"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.elevationDrivesThermal"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTMount_elevationDrivesThermal,"SELECT ""ambientTemperature"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.oilSupplySystem"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTMount_mountControlMainCabinet,"SELECT ""mainCabinetExternalTemperature"", ""mainCabinetInternalTemperature0"", ""mainCabinetInternalTemperature1"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.mainCabinetThermal"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTMount_mountControlMainCabinet,"SELECT ""ambientTemperature"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.oilSupplySystem"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTMount_azimuthDrivesThermal,"SELECT ""actualTemperature0"", ""actualTemperature1"", ""actualTemperature10"", ""actualTemperature11"", ""actualTemperature12"", ""actualTemperature13"", ""actualTemperature14"", ""actualTemperature15"", ""actualTemperature2"", ""actualTemperature3"", ""actualTemperature4"", ""actualTemperature5"", ""actualTemperature6"", ""actualTemperature8"", ""actualTemperature9"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuthDrivesThermal"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTMount_azimuthDrivesThermal,"SELECT ""ambientTemperature"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.oilSupplySystem"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTMount_cabinet0101,"SELECT ""actualTemperature"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.cabinet0101Thermal"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTMount_cabinet0101,"SELECT ""ambientTemperature"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.oilSupplySystem"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
MTMount_mainCabinetThermal,"SELECT ""mainCabinetInternalTemperature0"", ""mainCabinetExternalTemperature"", ""mainCabinetInternalTemperature1"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.mainCabinetThermal"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Balance moments,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.appliedBalanceForces"")
  |> filter(fn: (r) => r[""_field""] =~ /^m[xyz]$/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
TMA Azimuth,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.azimuth"")
  |> filter(fn: (r) => r[""_field""] == ""actualPosition"")

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
TMA Azimuth Torque,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.azimuth"")
  |> filter(fn: (r) => r[""_field""] == ""actualTorque"")

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Balance forces,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.appliedBalanceForces"")
  |> filter(fn: (r) => r[""_field""] =~ /^f[xyz]$/)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Hardpoints Forces,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ /measuredForce./)


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else if v.Function == ""skew"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: skew, createEmpty: false)            
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""skew"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: skew, createEmpty: false)     
    else 
      data",flux
TMA Elevation,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevation"")
  |> filter(fn: (r) => r[""_field""] == ""actualPosition"")

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
TMA Elevation Torque,"data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTMount.elevation"")
  |> filter(fn: (r) => r[""_field""] == ""actualTorque"")

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Forces,"import ""regexp""
import ""strings""


data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ regexp.compile(v: strings.joinStr(arr: [""measuredForce"", v.HP, ""$""], v: """")))


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Encoders,"import ""regexp""
import ""strings""


data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.hardpointActuatorData"")
  |> filter(fn: (r) => r[""_field""] =~ regexp.compile(v: strings.joinStr(arr: [""encoder"", v.HP, ""$""], v: """")))


if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
"Accelerometer 3 Y raw (*500.0), mg","import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] == ""rawAccelerometer5"")
  |> map(fn: (r) => ({r with _value: r._value * 500.0}))

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
"Accelerometer 2 Y raw (*500.0), mg","import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] == ""rawAccelerometer3"")
  |> map(fn: (r) => ({r with _value: r._value * 500.0}))

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
"Accelerometer 1 Y raw (*500.0), mg","import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] == ""rawAccelerometer1"")
  |> map(fn: (r) => ({r with _value: r._value * 500.0}))

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
"Accelerometer 4 raw X (*500.0), mg","import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] == ""rawAccelerometer6"")
  |> map(fn: (r) => ({r with _value: r._value * 500.0}))

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
"Accelerometer 3 X raw (*500.0), mg","import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] == ""rawAccelerometer4"")
  |> map(fn: (r) => ({r with _value: r._value * 500.0}))

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: stddev, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
"Accelerometer 2 X raw (*500.0), mg","import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] == ""rawAccelerometer2"")
  |> map(fn: (r) => ({r with _value: r._value * 500.0}))

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
"Accelerometer 1 X raw (*500.0), mg","import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] == ""rawAccelerometer0"")
  |> map(fn: (r) => ({r with _value: r._value * 500.0}))

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: stddev, createEmpty: false)
    else 
      data",flux
"Accelerometer 4 Y raw (*500.0), mg","import ""regexp""

data = from(bucket: ""efd/autogen"")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r[""_measurement""] == ""lsst.sal.MTM1M3.accelerometerData"")
  |> filter(fn: (r) => r[""_field""] == ""rawAccelerometer7"")
  |> map(fn: (r) => ({r with _value: r._value * 500.0}))

if v.Function == ""Raw"" then
  data
else
  if v.Downsample == ""Default"" then
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: v.windowPeriod, fn: spread, createEmpty: false)      
    else 
      data
  else     
    if v.Function == ""min"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: min, createEmpty: false)
    else if v.Function == ""max"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: max, createEmpty: false)
    else if v.Function == ""mean"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: mean, createEmpty: false)
    else if v.Function == ""spread"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else if v.Function == ""stddev"" then 
      data |> aggregateWindow(every: duration(v: v.Downsample), fn: spread, createEmpty: false)
    else 
      data",flux
Power State,"SELECT ""powerState"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.logevent_oilSupplySystemState"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
variable,"SELECT ""oilPressureAzimuth5023"", ""oilPressureAzimuth5022"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.oilSupplySystem"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
OSS Main Tank Level [mm] Gauge TMA_FA_OS_CLM_5001,"SELECT ""oilLevelFacilities5001"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.oilSupplySystem"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Oil Pressure (clone 1),"SELECT ""oilFlowRateAzimuth5021"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.oilSupplySystem"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
Oil Pressure,"SELECT ""oilPressureFacilities5011"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.oilSupplySystem"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
TMA AZ_TOR:A,"SELECT mean(""actualTorque"") AS ""mean_actualTorque"" FROM ""efd"".""autogen"".""lsst.sal.MTMount.azimuth"" WHERE time > :dashboardTime: AND time < :upperDashboardTime: GROUP BY time(:interval:) FILL(null)",influxql
Explore,"SELECT ""salIndex"", ""message"", ""traceback"", ""filePath"" FROM ""efd"".""autogen"".""lsst.sal.Script.logevent_logMessage"" WHERE time > :dashboardTime: AND time < :upperDashboardTime:",influxql
